{"version":3,"sources":["../../../../../src/core/communication/data/settings/settingsHandler.js"],"names":["dataDir","Path","resolve","__dirname","prefix","SettingsHandler","createModuleSettings","requestPath","config","location","window","default","type","section","validation","value","moduleSettings","ModuleSettings","patterns","IPC","send","toString","promises","map","pattern","_create","then","settings","_addSettings","all","create","module","defaultData","path","getPath","ID","fileName","isModuleFile","data","Settings","_setData","__generateUUID","alphabet","format","replace","Math","floor","length","random","__getPathPatternUUID","requestPathPattern","isMain","RequestPathPattern","modulePath","getModuleID","pathPatternUUIDs","UUID","__setPathPatternUUID","__loadPathPatternUUIDS","__getFile","__getPath","__storePathPatternUUIDS","__setFile","FS","existsSync","JSON","parse","readFileSync","e","console","error","writeFileSync","__deleteFile","unlinkSync","join","__getPatternPath","__getUUIDpath","_getModuleLocation","RequestPath","defaultLocation","Registry","_getModule","getConfig","patternsData","filter","test","sort","a","b","comparePriority","pop","GlobalDataHandler","_getData","sendSync","__setup","on","event","instance","undefined","forEach","field","_changeField"],"mappings":"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","file":"settingsHandler.js","sourcesContent":["import Path from \"path\";\r\nimport FS from \"fs\";\r\n\r\nimport GlobalDataHandler from \"../globalData/globalDataHandler\";\r\nimport Settings from \"./settings\";\r\nimport ModuleSettings from \"./moduleSettings\";\r\nimport Registry from \"../../../registry/registry\";\r\nimport RequestPath from \"../../../registry/requestPath/requestPath\";\r\nimport RequestPathPattern from \"../../../registry/requestPath/requestPathPattern\";\r\nimport isMain from \"../../../isMain\";\r\nimport IPC from \"../../IPC\";\r\n\r\nconst dataDir = Path.resolve(__dirname, \"../../../../../data/settings\");\r\nconst prefix = \"Settings:\";\r\n\r\n/**\r\n * @classdesc A static class that allows you to create settings which will be synchronised between modules and can be saved in files. Takes care of both the settings and moduleSettings data handling needs.\r\n * @class\r\n * @hideconstructor\r\n */\r\nexport default class SettingsHandler {\r\n    /**\r\n     * Creates a new moduleSettings instance\r\n     * @param {RequestPath} requestPath - The request path to create moduleSettings for\r\n     * @param {ModuleSettings~Config} config - The settings config to use\r\n     * @returns {ModuleSettings} The settings instance\r\n     * @async\r\n     * @public\r\n     */\r\n    static async createModuleSettings(requestPath, config) {\r\n        // Augment the config with default settings that all modules should have\r\n        config.location = {\r\n            window: {\r\n                default: 1,\r\n                type: \"number\",\r\n            },\r\n            section: {\r\n                default: 0,\r\n                type: \"number\",\r\n                validation: value => value >= 0,\r\n            },\r\n        };\r\n\r\n        // Create an instance of the moduleSettings\r\n        const moduleSettings = new ModuleSettings(requestPath, config);\r\n\r\n        // Check what settings files exist for this requestPath\r\n        const patterns = (await IPC.send(\r\n            \"ModuleSettings.retrieve\",\r\n            {requestPath: requestPath.toString()},\r\n            0\r\n        ))[0];\r\n\r\n        // Create settings instances for each of these patterns\r\n        const promises = patterns.map(pattern => {\r\n            // Create the settings instance\r\n            return this._create(pattern, {}, pattern, true).then(settings => {\r\n                // Add the settings to moduleSettings\r\n                moduleSettings._addSettings(settings);\r\n            });\r\n        });\r\n\r\n        // Wait for all settings to be created and added\r\n        await Promise.all(promises);\r\n\r\n        // Return the module settings\r\n        return moduleSettings;\r\n    }\r\n\r\n    /**\r\n     * Creates a new settings instance\r\n     * @param {string} ID - The identifier of the settings (preferably prefixed with some class ID)\r\n     * @param {Object} defaultData - The data that the settings should contain if no file exists yet\r\n     * @returns {Settings} The settings instance\r\n     * @async\r\n     * @public\r\n     */\r\n    static create(module, defaultData) {\r\n        // Use the module class path as the filename by default\r\n        const path = module.getPath().toString();\r\n\r\n        // Use the path with a settings prefix as the data ID\r\n        const ID = prefix + path;\r\n\r\n        // Create the settings\r\n        return this._create(ID, defaultData, path);\r\n    }\r\n\r\n    /**\r\n     * Creates a new settings instance\r\n     * @param {string} ID - The identifier of the settings (preferably prefixed with some class ID)\r\n     * @param {Object} defaultData - The data that the settings should contain if no file exists yet\r\n     * @param {string} fileName - The name of the file to store the settings in\r\n     * @param {boolean} isModuleFile - Whether or not the settings are for a module\r\n     * @returns {Settings} The settings instance\r\n     * @async\r\n     * @protected\r\n     */\r\n    static async _create(ID, defaultData, fileName, isModuleFile) {\r\n        if (!fileName) fileName = ID;\r\n        // Get the currently stored data for this ID from main, will be set to default if absent\r\n        const data = (await IPC.send(\r\n            \"Settings.retrieve\",\r\n            {\r\n                ID: ID,\r\n                fileName: fileName,\r\n                defaultData: defaultData,\r\n                isModuleFile: isModuleFile,\r\n            },\r\n            0\r\n        ))[0];\r\n\r\n        // Createa a new settings instance\r\n        const settings = new Settings(ID, fileName, isModuleFile);\r\n\r\n        // Add the data retrieved from main to this instance\r\n        settings._setData(data);\r\n\r\n        // Return the instance\r\n        return settings;\r\n    }\r\n\r\n    //UUID related methods\r\n    /**\r\n     * Generates a UUID\r\n     * @returns {string} The UUID\r\n     * @private\r\n     */\r\n    static __generateUUID() {\r\n        const alphabet = \"abcdefghijklmnopqrstuvwxyz0123456789\";\r\n        const format = \"xxxx-xxxx-xxxx-xxxx-xxxx\";\r\n        return format.replace(\r\n            /x/g,\r\n            () => alphabet[Math.floor(alphabet.length * Math.random())]\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets the UUID, used for the filename, that belongs to a specific request path pattern (only accessible in main)\r\n     * @param {(RequestPathPattern|string)} requestPathPattern - The request path to get the UUID for\r\n     * @returns {string} The file name of the file with this pattern\r\n     * @private\r\n     */\r\n    static __getPathPatternUUID(requestPathPattern) {\r\n        if (isMain) {\r\n            // Normalize the requestPathPattern\r\n            if (typeof requestPathPattern == \"string\")\r\n                requestPathPattern = new RequestPathPattern(requestPathPattern);\r\n\r\n            // Get the module that this path would lead to\r\n            const modulePath = requestPathPattern.getModuleID().module;\r\n\r\n            // Check if there already are UUIDs for this end point\r\n            const patterns = this.pathPatternUUIDs[modulePath];\r\n            if (!patterns) return;\r\n\r\n            // Check if there is a UUID for this specific pattern\r\n            const UUID = patterns[requestPathPattern.toString()];\r\n            if (!UUID) return;\r\n\r\n            // Return the UUID\r\n            return UUID;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the UUID, used for the filename, that belongs to the given request path pattern (only accessible in main)\r\n     * @param {RequestPath~pattern} requestPathPattern - The request path to set the UUID for\r\n     * @param {string} UUID - The UUID to set\r\n     * @returns {undefined}\r\n     * @private\r\n     */\r\n    static __setPathPatternUUID(requestPathPattern, UUID) {\r\n        if (isMain) {\r\n            // Normalize the requestPathPattern\r\n            if (typeof requestPathPattern == \"string\")\r\n                requestPathPattern = new RequestPathPattern(requestPathPattern);\r\n\r\n            // Get the module that this path would lead to\r\n            const modulePath = requestPathPattern.getModuleID().module;\r\n\r\n            // Get the map of UUIDs for this endpoint\r\n            let patterns = this.pathPatternUUIDs[modulePath];\r\n\r\n            // If no such map exists yet, create it\r\n            if (!patterns) patterns = this.pathPatternUUIDs[modulePath] = {};\r\n\r\n            // Add this request path pattern to the map\r\n            patterns[requestPathPattern] = UUID;\r\n\r\n            // If the new UUID isn't defined, delete the field completely\r\n            if (!UUID) delete patterns[requestPathPattern];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the UUID data out of the text file (only accessible in main)\r\n     * @returns {undefined}\r\n     * @private\r\n     */\r\n    static __loadPathPatternUUIDS() {\r\n        if (isMain)\r\n            this.pathPatternUUIDs =\r\n                this.__getFile(this.__getPath(\"moduleSettingPaths\")) || {};\r\n    }\r\n\r\n    /**\r\n     * Saves the UUID data to the text file (only accessible in main)\r\n     * @returns {undefined}\r\n     * @private\r\n     */\r\n    static __storePathPatternUUIDS() {\r\n        if (isMain)\r\n            this.__setFile(\r\n                this.__getPath(\"moduleSettingPaths\"),\r\n                this.pathPatternUUIDs\r\n            );\r\n    }\r\n\r\n    // Some file manipulation methods\r\n    /**\r\n     * Gets the contents of the file at the speciifed path\r\n     * @param {string} path - The path to get the data from\r\n     * @returns {Object} The data that was retrieved from the file\r\n     * @private\r\n     */\r\n    static __getFile(path) {\r\n        // Check if a file exists at this path\r\n        if (FS.existsSync(path)) {\r\n            try {\r\n                // If it exists, read the contents and parse it to json\r\n                const data = JSON.parse(FS.readFileSync(path));\r\n\r\n                // Return the data\r\n                return data;\r\n            } catch (e) {\r\n                // If anything goes wrong, just log an error. TODO: Properly handle these errors\r\n                console.error(\r\n                    `Something went wrong while retrieving ${path}:`,\r\n                    e\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Writes contents in the file at the speciifed path\r\n     * @param {string} path - The path to write the data to\r\n     * @param {Object} data - The data to write to the file\r\n     * @returns {undefined}\r\n     * @private\r\n     */\r\n    static __setFile(path, data) {\r\n        // Turn the data to json and write at the path\r\n        return FS.writeFileSync(path, JSON.stringify(data, null, 4));\r\n    }\r\n\r\n    /**\r\n     * Deletes the file at the speciifed path\r\n     * @param {string} path - The path to write the data to\r\n     * @returns {undefined}\r\n     * @private\r\n     */\r\n    static __deleteFile(path) {\r\n        return FS.unlinkSync(path);\r\n    }\r\n\r\n    /**\r\n     * Gets the correct fle path based on the file name (without extension)\r\n     * @param {string} fileName - The name of the file\r\n     * @returns {Object} The data that was retrieved from the file\r\n     * @private\r\n     */\r\n    static __getPath(fileName) {\r\n        // Combine the escaped file with the settings path and add th json extension\r\n        return Path.join(dataDir, fileName) + \".json\";\r\n    }\r\n\r\n    /**\r\n     * Gets the path for the specified pattern (only accessible in main)\r\n     * @param {(requestPathPattern|string)} requestPathPattern - The pattern to get the path for\r\n     * @returns {string} The file path for the settings of the pattern\r\n     * @private\r\n     */\r\n    static __getPatternPath(requestPathPattern) {\r\n        if (isMain) {\r\n            // Get the file UUID\r\n            const UUID = this.__getPathPatternUUID(requestPathPattern);\r\n\r\n            // Get the path to the file with this UUID\r\n            return this.__getUUIDpath(UUID);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the path for the specified UUID\r\n     * @param {string} UUID - The UUID that you want to get the file for\r\n     * @returns {string} The file path for the settings of the UUID\r\n     * @private\r\n     */\r\n    static __getUUIDpath(UUID) {\r\n        return this.__getPath(Path.join(\"moduleSettings\", UUID));\r\n    }\r\n\r\n    // /**\r\n    //  * Gets the contents of a file corresponding to a specific requestPath\r\n    //  * @param {RequestPath} requestPath - The path for which to get a file\r\n    //  * @returns {Object} The data that was retrieved from the file\r\n    //  * @protected\r\n    //  */\r\n    // static _getModuleFile(requestPath) {\r\n    //     // Get the data from the combined escaped request path and the settings path\r\n    //     return this.__getFile(\r\n    //         Path.join(dataDir, escapePath(requestPath.toString())) + \".json\"\r\n    //     );\r\n    // }\r\n\r\n    // Methods for interfacing with the settings\r\n    /**\r\n     * Gets the location from the settings for a module with the specified path (only accessible in main)\r\n     * @param {(RequestPath|string)} requestPath - The path to find the location for\r\n     * @returns {object} The location of the module\r\n     * @protected\r\n     */\r\n    static _getModuleLocation(requestPath) {\r\n        if (isMain) {\r\n            // Normalize the requestPathPattern\r\n            if (typeof requestPath == \"string\")\r\n                requestPath = new RequestPath(requestPath);\r\n\r\n            // Get the module that this path would lead to\r\n            const modulePath = requestPath.getModuleID().module;\r\n\r\n            // Define a default location\r\n            const defaultLocation = {\r\n                window: 1,\r\n                section: 0,\r\n            };\r\n\r\n            // Get the module itself\r\n            const module = Registry._getModule(modulePath);\r\n\r\n            // Check if the module even exists\r\n            if (module) {\r\n                // If it does, get its config\r\n                const config = module.getConfig();\r\n\r\n                // Check if the config contains a location\r\n                const location = config.settings && config.settings.location;\r\n                if (location) {\r\n                    // Copy any available parts of the location to be used as the default\r\n                    if (location.window)\r\n                        defaultLocation.window = location.window;\r\n                    if (location.section)\r\n                        defaultLocation.section = location.section;\r\n                }\r\n            }\r\n\r\n            // Check if there are UUIDs for this end point\r\n            const patternsData = this.pathPatternUUIDs[modulePath];\r\n            if (patternsData) {\r\n                // Check what patterns match this path\r\n                const patterns = Object.keys(patternsData).filter(pattern =>\r\n                    new RequestPathPattern(pattern).test(requestPath)\r\n                );\r\n\r\n                // Sort the patterns on priority\r\n                patterns.sort((a, b) => a.comparePriority(b));\r\n\r\n                // Go through the patterns in order of priority untill a lcoatin could be found\r\n                while (patterns.length > 0) {\r\n                    const pattern = patterns.pop();\r\n\r\n                    // Check if the data is already loaded\r\n                    let data = GlobalDataHandler._getData(\r\n                        prefix + pattern.toString()\r\n                    );\r\n\r\n                    // If the data isn't yet loaded, load it locally\r\n                    if (!data)\r\n                        data = this.__getFile(this.__getPatternPath(pattern));\r\n\r\n                    // Check if the data contains a location, if so combine it\r\n                    if (data && data.location) {\r\n                        return {...defaultLocation, ...data.location};\r\n                    }\r\n                }\r\n            }\r\n\r\n            // If no data could be found return some default\r\n            return defaultLocation;\r\n        } else {\r\n            return IPC.sendSync(\r\n                \"Settings.getModuleLocation\",\r\n                requestPath.toString(true),\r\n                0\r\n            )[0];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The initial setup method to be called by this file itself, initialises the static fields of the class\r\n     * @return {undefined}\r\n     * @private\r\n     */\r\n    static __setup() {\r\n        if (isMain) {\r\n            // Listen for moduleLocation requests, so they can be executed from the main process\r\n            IPC.on(\"Settings.getModuleLocation\", event => {\r\n                return this._getModuleLocation(event.data);\r\n            });\r\n\r\n            // Listen for settings save events\r\n            IPC.on(\"Settings.save\", async event => {\r\n                // Get the data of the settings that want to be saved\r\n                const ID = event.data.ID;\r\n                const fileName = event.data.fileName;\r\n                const isModuleFile = event.data.isModuleFile;\r\n\r\n                // Retrieve the data to save\r\n                const instance = GlobalDataHandler._getData(ID);\r\n                if (instance) {\r\n                    // Check if this data should be saved as module data\r\n                    if (isModuleFile) {\r\n                        let UUID = this.__getPathPatternUUID(fileName);\r\n\r\n                        // Check if the settings coontain information\r\n                        if (Object.keys(instance).length > 0) {\r\n                            // If there is no UUID yet, store one\r\n                            if (!UUID) {\r\n                                UUID = this.__generateUUID();\r\n                                this.__setPathPatternUUID(fileName, UUID);\r\n\r\n                                // Store the updated patterns\r\n                                this.__storePathPatternUUIDS();\r\n                            }\r\n\r\n                            // Store the data\r\n                            this.__setFile(this.__getUUIDpath(UUID), instance);\r\n                        } else {\r\n                            // Dispose the file if present\r\n                            if (UUID) {\r\n                                // Make sure the UUID is removed from the files\r\n                                this.__setPathPatternUUID(fileName, undefined);\r\n\r\n                                // Delete the file at the current UUID\r\n                                this.__deleteFile(this.__getUUIDpath(UUID));\r\n\r\n                                // Store the updated patterns\r\n                                this.__storePathPatternUUIDS();\r\n                            }\r\n\r\n                            // Notify moduleSettings instances about the deletion\r\n                            // Get the endpoint module to target\r\n                            const module = new RequestPathPattern(\r\n                                fileName\r\n                            ).getModuleID().module;\r\n\r\n                            // Send the removal to all moduleSettings with this module as an endpoint\r\n                            await IPC.send(\r\n                                \"ModuleSettings.removedSettings.\" + module,\r\n                                {pattern: fileName}\r\n                            );\r\n                        }\r\n                    } else {\r\n                        // Save the data in the correct file\r\n                        this.__setFile(this.__getPath(fileName), instance);\r\n                    }\r\n                }\r\n\r\n                // Return false if there was no data to save\r\n                return false;\r\n            });\r\n\r\n            // Listen for settings reload events\r\n            IPC.on(\"Settings.reload\", event => {\r\n                // Get the data of the settings that want to be saved\r\n                const ID = event.data.ID;\r\n                const fileName = event.data.fileName;\r\n\r\n                // Retrieve both the saved and currently loaded data\r\n                const instance = GlobalDataHandler._getData(ID);\r\n                const data = this.__getFile(this.__getPath(fileName));\r\n\r\n                // Check if both are present\r\n                if (instance && data) {\r\n                    // Set undefined fields literally to undefined such that they will be deleted\r\n                    Object.keys(instance).forEach(field => {\r\n                        if (data[field] === undefined) data[field] = undefined;\r\n                    });\r\n\r\n                    // Change all the data\r\n                    GlobalDataHandler._changeField(ID, instance, data, \"\");\r\n                    return data;\r\n                }\r\n\r\n                // If either the current data or saved data is absent, return false\r\n                return false;\r\n            });\r\n\r\n            // Add dedicated retrieve method that checks if data is stored in a file first\r\n            IPC.on(\"Settings.retrieve\", event => {\r\n                // Get the data of the settings that want to be saved\r\n                const ID = event.data.ID;\r\n                const fileName = event.data.fileName;\r\n                const isModuleFile = event.data.isModuleFile;\r\n\r\n                //  Check if global data for these settings is already loaded\r\n                if (!GlobalDataHandler._getData(ID)) {\r\n                    // Check if there is any saved data\r\n                    let data;\r\n                    if (isModuleFile) {\r\n                        // Get the data from a module file\r\n                        const UUID = this.__getPathPatternUUID(fileName);\r\n                        if (UUID)\r\n                            data = this.__getFile(this.__getUUIDpath(UUID));\r\n                    } else {\r\n                        // Get the data from a general settings file\r\n                        data = this.__getFile(this.__getPath(fileName));\r\n                    }\r\n\r\n                    // If it isn't already loaded, try to retrieve it from the file\r\n                    if (data) {\r\n                        // If the file contained data, load this data\r\n                        GlobalDataHandler._setData(ID, data);\r\n                    } else {\r\n                        // If the file contained no data, load the default data\r\n                        GlobalDataHandler._setData(ID, event.data.defaultData);\r\n                    }\r\n                }\r\n\r\n                // Return the stored data for these settings\r\n                return GlobalDataHandler._getData(ID);\r\n            });\r\n\r\n            // Listen for settings creation events (which firstly check whether the settings don't exist already)\r\n            IPC.on(\"ModuleSettings.create\", async event => {\r\n                // Get the pattern to create settings for\r\n                const pattern = event.data.pattern;\r\n\r\n                // Get the end point of the pattern\r\n                const module = new RequestPathPattern(pattern).getModuleID()\r\n                    .module;\r\n\r\n                // Notify all moduleSettings with this endpoint\r\n                await IPC.send(\"ModuleSettings.createdSettings.\" + module, {\r\n                    pattern: pattern,\r\n                });\r\n            });\r\n\r\n            // Listen for available setting instance requests\r\n            IPC.on(\"ModuleSettings.retrieve\", async event => {\r\n                // Get the requestPath to get patterns for\r\n                const requestPath = new RequestPath(event.data.requestPath);\r\n\r\n                // Get the endpoint of the path\r\n                const modulePath = requestPath.getModuleID().module;\r\n\r\n                // Check if there are patterns for this end point\r\n                const patternsData = this.pathPatternUUIDs[modulePath];\r\n                if (!patternsData) return [];\r\n\r\n                // Get the patterns (keys) from the data\r\n                let patterns = Object.keys(patternsData);\r\n\r\n                // Filter out all patterns that don't match this requestPath\r\n                patterns = patterns.filter(pattern =>\r\n                    new RequestPathPattern(pattern).test(requestPath)\r\n                );\r\n\r\n                // Return the patterns\r\n                return patterns;\r\n            });\r\n\r\n            // Load initial UUIDs\r\n            this.__loadPathPatternUUIDS();\r\n        }\r\n    }\r\n}\r\nSettingsHandler.__setup();\r\n"]}