{"version":3,"sources":["../../../src/core/communication/extendedJSON.js"],"names":["pathSymbol","parentSymbol","cleanSymbol","serializeSymbol","deserializeSymbol","ExtendedJSON","encode","object","encodeValue","path","Object","type","value","referencePathDirs","split","currentPathDirs","shift","i","unshift","subType","join","__proto__","prototype","Array","key","ret","Module","module","getClass","modulePath","data","undefined","e","console","error","encodedObject","__cleanObject","decode","decodeValue","parent","obj","m","match","Registry","require","default","loadModule","instance","bind","apply","concat","constArgs","val","parse","string","JSON","stringify","prop"],"mappings":"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","file":"extendedJSON.js","sourcesContent":["import Module from \"../registry/module\";\r\nvar pathSymbol = Symbol(\"path\");\r\nvar parentSymbol = Symbol(\"parent\");\r\nvar cleanSymbol = Symbol(\"clean\");\r\nvar serializeSymbol = Symbol(\"serialize\");\r\nvar deserializeSymbol = Symbol(\"deserialize\");\r\n\r\nexport {serializeSymbol, deserializeSymbol};\r\nexport default class ExtendedJSON{\r\n    /**\r\n     * Encode more complicated data into a serializable object\r\n     * @param  {Object} object The data you want to map\r\n     * @return {Object}        The object that represents your data as as serializable string\r\n     */\r\n    static encode(object){\r\n        /**\r\n         * Goes through an object and returns the object in the encoded format\r\n         * @param  {Object} object The object to convert\r\n         * @param  {String} path   The path within the parent object to reach this object so far\r\n         * @return {Object}        The encoded version of the input object\r\n         */\r\n        var encodeValue = function(object, path){\r\n            try{\r\n                if(object instanceof Object){ // Encode an object of data into the extended format\r\n                    // If object is null, return null object in the extended format\r\n                    if(!object)\r\n                        return {\r\n                            type: \"object\",\r\n                            value: null\r\n                        };\r\n\r\n                    // If object has already been encoded, return a path instead (handles recursive structures)\r\n                    if(object[pathSymbol]!=null){\r\n                        // Get the current path and the reference path in array form\r\n                        var referencePathDirs = object[pathSymbol].split(\"/\");\r\n                        var currentPathDirs = path.split(\"/\");\r\n\r\n                        // Remove all the common nodes\r\n                        while(referencePathDirs[0]==currentPathDirs[0]){\r\n                        \treferencePathDirs.shift();\r\n                            currentPathDirs.shift();\r\n                        }\r\n\r\n                        // Make the path go back to last common node\r\n                        for(var i in currentPathDirs)\r\n                        \treferencePathDirs.unshift(\"..\");\r\n\r\n                        // Return the referencePath as a string\r\n                        return {\r\n                            type: \"object\",\r\n                            subType: \"path\",\r\n                            value: referencePathDirs.join(\"/\")\r\n                        };\r\n                    }\r\n\r\n                    // If object is an array or plain js object, recurse on this object\r\n                    if(object.__proto__==Object.prototype || object.__proto__==Array.prototype){\r\n                        // Indicate that this object is currently being handled, and prevent recusion\r\n                        object[pathSymbol] = path;\r\n\r\n                        // Go through all children and append their values to this value\r\n                        var value = {};\r\n                        for(var key in object)\r\n                            value[key] = encodeValue(object[key], path+\"/\"+key);\r\n\r\n                        // Return either a plain js object type, or an array type\r\n                        var ret = {\r\n                            type: \"object\",\r\n                            value: value\r\n                        };\r\n                        if(object instanceof Array) ret.subType = \"array\";\r\n                        return ret;\r\n                    }\r\n\r\n                    // If object is a module and serializable, serialize it\r\n                    if(object instanceof Module && object[serializeSymbol] && object[deserializeSymbol]){\r\n                        var module = object.getClass().modulePath;\r\n                        var data = object[serializeSymbol]();\r\n                        return {\r\n                            type: \"object\",\r\n                            subType: \"moduleInstance:\"+module,\r\n                            value: data\r\n                        };\r\n                    }\r\n\r\n                    // If object is a module class, return the path of the class\r\n                    if(typeof(object)==\"function\" && object.modulePath)\r\n                        return {\r\n                            type: \"object\",\r\n                            subType: \"module:\"+object.modulePath,\r\n                            value: undefined\r\n                        };\r\n\r\n                    // If none of the previous conditions apply, there is nothing left but ignore this value\r\n                    return {\r\n                        type: \"undefined\",\r\n                        value: undefined\r\n                    };\r\n                }else{ // Encode a primitive value in the extended format\r\n                    var type = typeof(object);\r\n                    return {\r\n                        type:type,\r\n                        value:object\r\n                    };\r\n                }\r\n            }catch(e){\r\n                console.error(e);\r\n                return undefined;\r\n            }\r\n        }\r\n\r\n        // Encode data\r\n        var encodedObject = encodeValue(object, \"\");\r\n\r\n        // Remove data added to the original object during the process\r\n        this.__cleanObject(object, pathSymbol);\r\n\r\n        // Return the encoded data\r\n        return encodedObject;\r\n    }\r\n    /**\r\n     * Decode the more complicated data that was encoded into a serializable object\r\n     * @param  {Object} object The data you want return into its source data\r\n     * @return {Object}        The source data in its format before encoding was applied\r\n     */\r\n    static decode(object){\r\n        /**\r\n         * Goes through an encoded object and returns the object in its original format\r\n         * @param  {Object} value  The value to decode\r\n         * @param  {Object} parent The object that the value will be stored in (used for object reference paths)\r\n         * @return {Object} The resulting value after decoding the input value\r\n         */\r\n        var decodeValue = function(value, parent){\r\n            try{\r\n                if(value.type==\"object\"){ // Decode a value of the type Object\r\n                    // If object is of a special type, decode it\r\n                    if(value.subType){\r\n                        // If object is of type path (internal reference), retrieve the object\r\n                        if(value.subType==\"path\"){\r\n                            var path = value.value.split(\"/\");\r\n                            path.shift(); // The first\r\n\r\n                            // Retrieve th object by going through the path\r\n                            var obj = parent;\r\n                            var key;\r\n                            while((key = path.shift()) && obj){\r\n                                if(key==\"..\") // Step up in the object\r\n                                    obj = obj[parentSymbol];\r\n                                else   // Step down to a child in the object\r\n                                    obj = obj[key];\r\n                            }\r\n\r\n                            // Return the object\r\n                            return obj;\r\n                        }\r\n\r\n                        var m;\r\n                        // If object is a module class, retrieve said class\r\n                        if(m = value.subType.match(/module\\:(.*)/)){\r\n                            // Retrieve the Registry  at runtime, as the registry also uses this module (cross link)\r\n                            var Registry = require(\"../registry/registry\").default;\r\n\r\n                            // Load the module from its path and return it\r\n                            return Registry.loadModule(m[1]);\r\n                        }\r\n\r\n                        // If object is a module instance, retrieve its class, instatiate it, and load the data\r\n                        if(m = value.subType.match(/moduleInstance\\:(.*)/)){\r\n                            // Retrieve the Registry  at runtime, as the registry also uses this module (cross link)\r\n                            var Registry = require(\"../registry/registry\").default;\r\n\r\n                            // Load the module from its path\r\n                            var module = Registry.loadModule(m[1]);\r\n\r\n                            // Instanciate the module with the correct arguments, and call the deserializer\r\n                            var data = value.value;\r\n                            var instance = new (module.bind.apply(module, [module].concat(data.constArgs||[\"crap\"])))();\r\n                            instance[deserializeSymbol](data);\r\n\r\n                            // Return the instance\r\n                            return instance;\r\n                        }\r\n                    }\r\n\r\n                    // Decode null objects\r\n                    if(value.value==null){\r\n                        return null;\r\n                    }\r\n\r\n                    // Decode plain objects and arrays\r\n                    var val = value.subType==\"array\"?[]:{};\r\n                    // Store the parent temporarely for relative path traversal\r\n                    val[parentSymbol] = parent;\r\n                    for(var key in value.value)  // Fill object or array with child values\r\n                        val[key] = decodeValue(value.value[key], val);\r\n\r\n                    // Get rid of the temporary parent data\r\n                    delete val[parentSymbol];\r\n\r\n                    // Return the result\r\n                    return val;\r\n                }else{  // Decode primitive value\r\n                    return value.value;\r\n                }\r\n            }catch(e){\r\n                // If anything goes wrong, just write value undefined\r\n                console.error(e);\r\n                return undefined;\r\n            }\r\n        };\r\n\r\n        // Decode the object and return the result\r\n        return decodeValue(object);\r\n    }\r\n\r\n    /**\r\n     * Use ExtendedJSON to turn a string into an object just like JSON would\r\n     * @param  {String} string The string to translate back into an object\r\n     * @return {Object}        The source object that the string was made from\r\n     */\r\n    static parse(string){\r\n        return this.decode(JSON.parse(string));\r\n    }\r\n    /**\r\n     * Use ExtendedJSON to turn an object into a string just like JSON would\r\n     * @param  {Object} object The source object to turn into a string\r\n     * @return {String}        The string that the object was translated into\r\n     */\r\n    static stringify(object){\r\n        return JSON.stringify(this.encode(object));\r\n    }\r\n\r\n    /**\r\n     * Get the serializeSymbol to use as a function name in your own class, allowing said class to be serialized by ExtendedJSON\r\n     * @type {Symbol}\r\n     */\r\n    static get serializeSymbol(){\r\n        return serializeSymbol;\r\n    }\r\n    /**\r\n     * Get the deserializeSymbol to use as a function name in your own class, allowing said class to be deserialized by ExtendedJSON\r\n     * @type {[type]}\r\n     */\r\n    static get deserializeSymbol(){\r\n        return deserializeSymbol;\r\n    }\r\n\r\n    /**\r\n     * Goes through an object and returns all the pathSymbols from it\r\n     * @param  {Object} object The object to clean up\r\n     * @param  {Symbol|String} prop The property to remove from the object\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    static __cleanObject(object, prop){\r\n        // Only clean the object if it really is an object, if it isn't already cleaned and if there is still something to clean\r\n        if(object instanceof Object && !object[cleanSymbol] && prop in object){\r\n            // Prevent recursion while cleaning the object\r\n            object[cleanSymbol] = true;\r\n\r\n            // Remove the path or parent if it is present\r\n            if(prop in object) delete object[prop];\r\n\r\n            // If no path is present, recurse on its children\r\n            for(var key in object)\r\n                this.__cleanObject(object[key]);\r\n\r\n            // Remove the cleanSymbol which prevent recursion\r\n            delete object[cleanSymbol];\r\n        }\r\n    }\r\n}\r\n"]}