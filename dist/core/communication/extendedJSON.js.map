{"version":3,"sources":["../../../src/core/communication/extendedJSON.js"],"names":["pathSymbol","parentSymbol","cleanSymbol","serializeSymbol","deserializeSymbol","ExtendedJSON","encode","object","encodeValue","path","Object","type","value","referencePathDirs","split","currentPathDirs","shift","i","unshift","subType","join","__proto__","prototype","Array","key","ret","Module","require","default","modulePath","getClass","getPath","configPath","getConfig","data","undefined","e","console","error","encodedObject","__cleanObject","decode","decodeValue","parent","obj","m","match","Registry","config","_loadConfig","module","_loadModule","instance","bind","apply","concat","constArgs","val","parse","string","JSON","stringify","prop"],"mappings":"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","file":"extendedJSON.js","sourcesContent":["const pathSymbol = Symbol(\"path\");\r\nconst parentSymbol = Symbol(\"parent\");\r\nconst cleanSymbol = Symbol(\"clean\");\r\nconst serializeSymbol = Symbol(\"serialize\");\r\nconst deserializeSymbol = Symbol(\"deserialize\");\r\n\r\nexport {serializeSymbol, deserializeSymbol};\r\n\r\n/**\r\n * @classdesc\r\n * An extended version of JSON that is able to also encode the following information:\r\n *  - Module classes\r\n *  - Module class instances (if the class has serialize and deserialize methods)\r\n *  - recursive objects/internal object references\r\n * @class\r\n * @hideconstructor\r\n */\r\nexport default class ExtendedJSON {\r\n    /**\r\n     * Encode more complicated data into a serializable object\r\n     * @param {Object} object -The data you want to map\r\n     * @returns {Object} The object that represents your data as as serializable string\r\n     * @public\r\n     */\r\n    static encode(object) {\r\n        /**\r\n         * Goes through an object and returns the object in the encoded format\r\n         * @param {Object} object - The object to convert\r\n         * @param {string} path - The path within the parent object to reach this object so far\r\n         * @returns {Object} The encoded version of the input object\r\n         * @inner\r\n         * @private\r\n         */\r\n        const encodeValue = function(object, path) {\r\n            try {\r\n                if (object instanceof Object) {\r\n                    // Encode an object of data into the extended format\r\n                    // If object is null, return null object in the extended format\r\n                    if (!object)\r\n                        return {\r\n                            type: \"object\",\r\n                            value: null,\r\n                        };\r\n\r\n                    // If object has already been encoded, return a path instead (handles recursive structures)\r\n                    if (object[pathSymbol] != null) {\r\n                        // Get the current path and the reference path in array form\r\n                        const referencePathDirs = object[pathSymbol].split(\"/\");\r\n                        const currentPathDirs = path.split(\"/\");\r\n\r\n                        // Remove all the common nodes\r\n                        while (referencePathDirs[0] == currentPathDirs[0]) {\r\n                            referencePathDirs.shift();\r\n                            currentPathDirs.shift();\r\n                        }\r\n\r\n                        // Make the path go back to last common node\r\n                        for (let i in currentPathDirs)\r\n                            referencePathDirs.unshift(\"..\");\r\n\r\n                        // Return the referencePath as a string\r\n                        return {\r\n                            type: \"object\",\r\n                            subType: \"path\",\r\n                            value: referencePathDirs.join(\"/\"),\r\n                        };\r\n                    }\r\n\r\n                    // If object is an array or plain js object, recurse on this object\r\n                    if (\r\n                        object.__proto__ == Object.prototype ||\r\n                        object.__proto__ == Array.prototype\r\n                    ) {\r\n                        // Indicate that this object is currently being handled, and prevent recusion\r\n                        object[pathSymbol] = path;\r\n\r\n                        // Go through all children and append their values to this value\r\n                        const value = {};\r\n                        for (let key in object)\r\n                            value[key] = encodeValue(\r\n                                object[key],\r\n                                path + \"/\" + key\r\n                            );\r\n\r\n                        // Return either a plain js object type, or an array type\r\n                        const ret = {\r\n                            type: \"object\",\r\n                            value: value,\r\n                        };\r\n                        if (object instanceof Array) ret.subType = \"array\";\r\n                        return ret;\r\n                    }\r\n\r\n                    // If object is a module and serializable, serialize it\r\n                    const Module = require(\"../registry/module\").default;\r\n                    if (\r\n                        object instanceof Module &&\r\n                        object[serializeSymbol] &&\r\n                        object[deserializeSymbol]\r\n                    ) {\r\n                        // Get relevant information\r\n                        const modulePath = object.getClass().getPath();\r\n                        const configPath = object.getClass().getConfig().path;\r\n                        const data = object[serializeSymbol]();\r\n\r\n                        // Encode the information\r\n                        return {\r\n                            type: \"object\",\r\n                            subType: `moduleInstance:${modulePath};${configPath}`,\r\n                            value: data,\r\n                        };\r\n                    }\r\n\r\n                    // If object is a module class, return the path of the class\r\n                    if (typeof object == \"function\" && object.getPath) {\r\n                        // Get relevant information\r\n                        const modulePath = object.getPath();\r\n                        const configPath = object.getConfig().path;\r\n\r\n                        // Encode the information\r\n                        return {\r\n                            type: \"object\",\r\n                            subType: `module:${modulePath};${configPath}`,\r\n                            value: undefined,\r\n                        };\r\n                    }\r\n\r\n                    // If none of the previous conditions apply, there is nothing left but ignore this value\r\n                    return {\r\n                        type: \"undefined\",\r\n                        value: undefined,\r\n                    };\r\n                } else {\r\n                    // Encode a primitive value in the extended format\r\n                    const type = typeof object;\r\n                    return {\r\n                        type: type,\r\n                        value: object,\r\n                    };\r\n                }\r\n            } catch (e) {\r\n                console.error(e);\r\n                return undefined;\r\n            }\r\n        };\r\n\r\n        // Encode data\r\n        const encodedObject = encodeValue(object, \"\");\r\n\r\n        // Remove data added to the original object during the process\r\n        this.__cleanObject(object, pathSymbol);\r\n\r\n        // Return the encoded data\r\n        return encodedObject;\r\n    }\r\n    /**\r\n     * Decode the more complicated data that was encoded into a serializable object\r\n     * @param  {Object} object - The data you want return into its source data\r\n     * @returns {Object} The source data in its format before encoding was applied\r\n     * @public\r\n     */\r\n    static decode(object) {\r\n        /**\r\n         * Goes through an encoded object and returns the object in its original format\r\n         * @param {Object} value - The value to decode\r\n         * @param {Object} parent - The object that the value will be stored in (used for object reference paths)\r\n         * @returns {Object} The resulting value after decoding the input value\r\n         * @inner\r\n         * @private\r\n         */\r\n        const decodeValue = function(value, parent) {\r\n            try {\r\n                if (value.type == \"object\") {\r\n                    // Decode a value of the type Object\r\n                    // If object is of a special type, decode it\r\n                    if (value.subType) {\r\n                        // If object is of type path (internal reference), retrieve the object\r\n                        if (value.subType == \"path\") {\r\n                            const path = value.value.split(\"/\");\r\n                            path.shift(); // The first\r\n\r\n                            // Retrieve th object by going through the path\r\n                            let obj = parent;\r\n                            let key;\r\n                            while ((key = path.shift()) && obj) {\r\n                                if (key == \"..\")\r\n                                    // Step up in the object\r\n                                    obj = obj[parentSymbol];\r\n                                // Step down to a child in the object\r\n                                else obj = obj[key];\r\n                            }\r\n\r\n                            // Return the object\r\n                            return obj;\r\n                        }\r\n\r\n                        let m;\r\n                        // If object is a module class, retrieve said class\r\n                        if ((m = value.subType.match(/module\\:(.*);(.*)/))) {\r\n                            // Retrieve the Registry at runtime, as the registry also uses this module (cross link)\r\n                            const Registry = require(\"../registry/registry\")\r\n                                .default;\r\n\r\n                            // Load the module config\r\n                            const config = Registry._loadConfig(m[2], m[1]);\r\n\r\n                            // Load the module from its path\r\n                            const module = Registry._loadModule(config);\r\n\r\n                            // Load the module from its path and return it\r\n                            return module;\r\n                        }\r\n\r\n                        // If object is a module instance, retrieve its class, instatiate it, and load the data\r\n                        if (\r\n                            (m = value.subType.match(\r\n                                /moduleInstance\\:(.*);(.*)/\r\n                            ))\r\n                        ) {\r\n                            // Retrieve the Registry  at runtime, as the registry also uses this module (cross link)\r\n                            const Registry = require(\"../registry/registry\")\r\n                                .default;\r\n\r\n                            // Load the module config\r\n                            const config = Registry._loadConfig(m[2], m[1]);\r\n\r\n                            // Load the module from its path\r\n                            const module = Registry._loadModule(config);\r\n\r\n                            // Instanciate the module with the correct arguments, and call the deserializer\r\n                            const data = value.value;\r\n                            const instance = new (module.bind.apply(\r\n                                module,\r\n                                [module].concat(data.constArgs || [\"crap\"])\r\n                            ))();\r\n                            instance[deserializeSymbol](data);\r\n\r\n                            // Return the instance\r\n                            return instance;\r\n                        }\r\n                    }\r\n\r\n                    // Decode null objects\r\n                    if (value.value == null) {\r\n                        return null;\r\n                    }\r\n\r\n                    // Decode plain objects and arrays\r\n                    const val = value.subType == \"array\" ? [] : {};\r\n                    // Store the parent temporarely for relative path traversal\r\n                    val[parentSymbol] = parent;\r\n                    for (let key in value.value) // Fill object or array with child values\r\n                        val[key] = decodeValue(value.value[key], val);\r\n\r\n                    // Get rid of the temporary parent data\r\n                    delete val[parentSymbol];\r\n\r\n                    // Return the result\r\n                    return val;\r\n                } else {\r\n                    // Decode primitive value\r\n                    return value.value;\r\n                }\r\n            } catch (e) {\r\n                // If anything goes wrong, just write value undefined\r\n                console.error(e);\r\n                return undefined;\r\n            }\r\n        };\r\n\r\n        // Decode the object and return the result\r\n        return decodeValue(object);\r\n    }\r\n\r\n    /**\r\n     * Use ExtendedJSON to turn a string into an object just like JSON would\r\n     * @param {String} string - The string to translate back into an object\r\n     * @returns {Object} The source object that the string was made from\r\n     * @public\r\n     */\r\n    static parse(string) {\r\n        return this.decode(JSON.parse(string));\r\n    }\r\n    /**\r\n     * Use ExtendedJSON to turn an object into a string just like JSON would\r\n     * @param {Object} object - The source object to turn into a string\r\n     * @returns {String} The string that the object was translated into\r\n     * @public\r\n     */\r\n    static stringify(object) {\r\n        return JSON.stringify(this.encode(object));\r\n    }\r\n\r\n    /**\r\n     * Get the serializeSymbol to use as a function name in your own class, allowing said class to be serialized by ExtendedJSON\r\n     * @type {Symbol}\r\n     * @public\r\n     */\r\n    static get serializeSymbol() {\r\n        return serializeSymbol;\r\n    }\r\n    /**\r\n     * Get the deserializeSymbol to use as a function name in your own class, allowing said class to be deserialized by ExtendedJSON\r\n     * @type {Symbol}\r\n     * @public\r\n     */\r\n    static get deserializeSymbol() {\r\n        return deserializeSymbol;\r\n    }\r\n\r\n    // Private methods\r\n    /**\r\n     * Goes through an object and returns all the pathSymbols from it\r\n     * @param {Object} object 0 The object to clean up\r\n     * @param {(Symbol|string)} prop - The property to remove from the object\r\n     * @returns {undefined} The method returns no useful information\r\n     * @private\r\n     */\r\n    static __cleanObject(object, prop) {\r\n        // Only clean the object if it really is an object, if it isn't already cleaned and if there is still something to clean\r\n        if (\r\n            object instanceof Object &&\r\n            !object[cleanSymbol] &&\r\n            prop in object\r\n        ) {\r\n            // Prevent recursion while cleaning the object\r\n            object[cleanSymbol] = true;\r\n\r\n            // Remove the path or parent if it is present\r\n            if (prop in object) delete object[prop];\r\n\r\n            // If no path is present, recurse on its children\r\n            for (let key in object) this.__cleanObject(object[key], prop);\r\n\r\n            // Remove the cleanSymbol which prevent recursion\r\n            delete object[cleanSymbol];\r\n        }\r\n    }\r\n}\r\n"]}