{"version":3,"sources":["../../../src/core/communication/channel.js"],"names":["ChannelSender","constructor","ID","subChannelID","senderID","__data","__setupChannelMessageTypeListener","_setupMethods","types","initialised","resolve","IPC","send","reject","finishSetup","messageTypes","globalListeners","subChannelMessageTypes","subChannelListeners","concat","key","__sendMessage","arguments","_getID","_getSubChannelID","once","event","data","destProcessID","sourceID","message","args","ChannelReceiver","listeners","IPClisteners","sender","__emitEvent","requestMessageTypes","__broadCastMessageTypes","on","createSubChannel","deleteSubChannel","subChannel","getID","close","off","listener","call","processes","Channel","createSender","createReceiver"],"mappings":"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","file":"channel.js","sourcesContent":["import IPC from \"./IPC\";\r\n\r\n/**\r\n * A class to send certain messages on a channel\r\n */\r\nclass ChannelSender{\r\n    /**\r\n     * Create a new channel sender, allowing to send messages to the channel\r\n     * @param {String} ID           The unique identifier for the channel\r\n     * @param {String} subChannelID The subChannelID that will be used to access special subchannel methods\r\n     * @param {String} senderID     An ID that the reciever of this channel can respond to (can be left out)\r\n     */\r\n    constructor(ID, subChannelID, senderID){\r\n        this.__data = {\r\n            ID: ID,\r\n            subChannelID: subChannelID,\r\n            senderID: senderID\r\n        };\r\n\r\n        // Listen for the available message types being send\r\n        this.__setupChannelMessageTypeListener();\r\n    }\r\n\r\n    // Protected methods\r\n    /**\r\n     * Either requests methods to be set up according to the available message types,\r\n     * Or sets up the actual methods according to the passed data\r\n     * @param  {Object} types The available message types\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    _setupMethods(types){\r\n        // Check if this call is initiating the setup, or actually setting up the data\r\n        if(!types){ // The call is initiating the setup\r\n            // Check if the channel hasn't been set up already\r\n            if(this.__data.initialised){\r\n                return new Promise.resolve(this);\r\n            }else{\r\n                // Broadcast a request for all message types of this channel\r\n                IPC.send(\"channel.requestMessageTypes:\"+this.__data.ID);\r\n                return new Promise((resolve, reject)=>{\r\n                    this.__data.finishSetup = resolve;\r\n                });\r\n            }\r\n        }else{ // Call is actually setting up the data\r\n            // Gatyher the relevant message types\r\n            let messageTypes = types.globalListeners;\r\n            const subChannelMessageTypes = types.subChannelListeners[this.__data.subChannelID];\r\n            if(subChannelMessageTypes)\r\n                messageTypes = messageTypes.concat(subChannelMessageTypes);\r\n\r\n            // Setup the methods\r\n            for(let key of messageTypes)\r\n                this[key] = function(){\r\n                    return this.__sendMessage(key, Array.from(arguments));\r\n                };\r\n\r\n            // Notify that the channel is ready\r\n            this.__data.initialised = true;\r\n            if(this.__data.finishSetup) this.__data.finishSetup(this);\r\n        }\r\n    }\r\n    /**\r\n     * Get the channel ID\r\n     * @return {String} The channel ID\r\n     */\r\n    _getID(){\r\n        return this.__data.ID;\r\n    }\r\n    /**\r\n     * Get the subchannel ID\r\n     * @return {String} The subchannel ID\r\n     */\r\n    _getSubChannelID(){\r\n        return this.__data.subChannelID;\r\n    }\r\n\r\n    // Private methods\r\n    /**\r\n     * Starts listening for the channel receiver to send its available message types\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    __setupChannelMessageTypeListener(){\r\n        IPC.once(\"channel.sendMessageTypes:\"+this.__data.ID, event=>{\r\n            // Check if all the subchannel methods have already been defined\r\n            if(!this.__data.subChannelID || event.data.subChannelListeners[this.__data.subChannelID]){\r\n                // Store the location to send the messages to\r\n                this.__data.destProcessID = event.sourceID;\r\n\r\n                // Setup the methods of this object\r\n                this._setupMethods(event.data);\r\n            }else{\r\n                // Continue listening for message types if the subchannel hadn't been set up yet\r\n                this.__setupChannelMessageTypeListener();\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Send a message to the channel receiver\r\n     * @param  {[type]} message The message type\r\n     * @param  {[type]} args    The data to send as an argment array\r\n     * @return {Undefined}      The method returns no useful information\r\n     */\r\n    __sendMessage(message, args){\r\n        // Send the message and relevant data to the process/window that contains the channel receiver\r\n        return IPC.send(\"channel.message:\"+this.__data.ID, {\r\n            message: message,\r\n            subChannelID: this.__data.subChannelID,\r\n            senderID: this.__data.senderID,\r\n            data: args\r\n        }, this.__data.destProcessID);\r\n    }\r\n}\r\n\r\n/**\r\n * A class to listen for certain messages sent on a channel\r\n */\r\nclass ChannelReceiver{\r\n    /**\r\n     * Create a new channel reciever, allowing to recieve messages from the channel\r\n     * @param {String} ID           The unique identifier for the channel\r\n     * @param {Object} listeners    An object of functions to act on messages indexed by message type\r\n     */\r\n    constructor(ID, listeners){\r\n        this.ID = ID;\r\n\r\n        // Create objects to store listeners\r\n        this.globalListeners = listeners;\r\n        this.subChannelListeners = {};\r\n\r\n        this.IPClisteners = {\r\n            // Forward IPC messages\r\n            message: event=>{\r\n                let data = event.data;\r\n\r\n                // Extract the data to build the event to emit in this channel\r\n                const sender = data.senderID;\r\n                const subChannelID = data.subChannelID;\r\n                const message = data.message;\r\n                data = data.data;\r\n\r\n                // Emit the event\r\n                return this.__emitEvent(message, {\r\n                    senderID: sender,\r\n                    data: data\r\n                }, subChannelID);\r\n            },\r\n            // Send available message types on request\r\n            requestMessageTypes: event=>{\r\n                this.__broadCastMessageTypes(event.sourceID);\r\n            }\r\n        };\r\n        IPC.on(\"channel.message:\"+ID, this.IPClisteners.message);\r\n        IPC.on(\"channel.requestMessageTypes:\"+ID, this.IPClisteners.requestMessageTypes);\r\n\r\n        // Send available message types to all processes/renderers\r\n        this.__broadCastMessageTypes(\"*\");\r\n    }\r\n    /**\r\n     * Create a subchannel that can overwrite certain listeners on the channel, or add listeners just for the sub channel\r\n     * @param  {String} ID        The ID of the subchannel\r\n     * @param  {Object} listeners An object of functions to act on messages indexed by message type\r\n     * @return {Undefined}        The method returns no useful information\r\n     */\r\n    createSubChannel(ID, listeners){\r\n        this.subChannelListeners[ID] = listeners;\r\n        this.__broadCastMessageTypes(\"*\");\r\n    }\r\n    /**\r\n     * Delete a subchannel\r\n     * @param  {String} ID The subChannel to remove\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    deleteSubChannel(ID){\r\n        delete this.subChannel[ID];\r\n    }\r\n    /**\r\n     * Get the channel ID\r\n     * @return {String} The channel ID\r\n     */\r\n    getID(){\r\n        return this.ID;\r\n    }\r\n\r\n    /**\r\n     * Dispose of all data\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    close(){\r\n        IPC.off(\"channel.message:\"+this.ID, this.IPClisteners.message);\r\n        IPC.off(\"channel.requestMessageTypes:\"+this.ID, this.IPClisteners.requestMessageTypes);\r\n    }\r\n\r\n    // Private methods\r\n    /**\r\n     * Emit an event to the registered listener\r\n     * @param  {String} message         The event type to invoke\r\n     * @param  {Object} event           The event data to pass to the listener\r\n     * @param  {[type]} subChannelID    The subchannel of which to take the listener if available\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    __emitEvent(message, event, subChannelID){\r\n        if(subChannelID){\r\n            // Attempt to find message listeners on this subchannel\r\n            const subChannel = this.subChannelListeners[subChannelID];\r\n            const listener = subChannel && subChannel[message];\r\n\r\n            // If listeners exist, call them and don't invoke any global listeners\r\n            if(listener)\r\n                return listener.call(this, event);\r\n        }\r\n\r\n        // Retrieve listeners\r\n        const listener = this.globalListeners[message];\r\n\r\n        // If listeners exist, call them\r\n        if(listener)\r\n            return listener.call(this, event);\r\n    }\r\n    /**\r\n     * Broadcast all available message types to the specified renderers/processes\r\n     * @param  {String|[String, ...]} [processes=\"*\"] The renderers/processes to send the message types to\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    __broadCastMessageTypes(processes=\"*\"){\r\n        // Create object to broadcast to the requesting renderer/process\r\n        const messageTypes = {\r\n            globalListeners: Object.keys(this.globalListeners),\r\n            subChannelListeners: {\r\n                // Will be filled by the for loop below\r\n            }\r\n        };\r\n\r\n        // Add all the subChannel\r\n        for(let key in this.subChannelListeners)\r\n            messageTypes.subChannelListeners[key] = Object.keys(this.subChannelListeners[key]);\r\n\r\n        // Broadcast the messages\r\n        IPC.send(\"channel.sendMessageTypes:\"+this.ID, messageTypes, processes);\r\n    }\r\n}\r\nexport {ChannelSender, ChannelReceiver};\r\n/**\r\n * The public class to create channel senders and recievers, as the creation of a channel sender is asynchronous\r\n */\r\nexport default class Channel{\r\n    /**\r\n     * Create a new channel sender, allowing to send messages to the channel\r\n     * @param {String} ID           The unique identifier for the channel\r\n     * @param {String} subChannelID The subChannelID that will be used to access special subchannel methods\r\n     * @param {String} senderID     An ID that the reciever of this channel can respond to (can be left out)\r\n     */\r\n    static createSender(ID, subChannelID, senderID){\r\n        return new ChannelSender(ID, subChannelID, senderID)._setupMethods();\r\n    }\r\n    /**\r\n     * Create a new channel reciever, allowing to recieve messages from the channel\r\n     * @param {String} ID           The unique identifier for the channel\r\n     * @param {Object} listeners    An object of functions to act on messages indexed by message type\r\n     */\r\n    static createReceiver(ID, listeners){\r\n        return Promise.resolve(new ChannelReceiver(ID, listeners));\r\n    }\r\n}\r\n"]}