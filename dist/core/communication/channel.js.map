{"version":3,"sources":["../../../src/core/communication/channel.js"],"names":["ChannelSender","constructor","ID","subChannelID","senderID","__setupChannelMessageTypeListener","_setupMethods","types","initialised","resolve","reject","IPC","send","finishSetup","messageTypes","globalListeners","subChannelMessageTypes","subChannelListeners","concat","key","__sendMessage","arguments","_getID","_getSubChannelID","once","event","data","destProcessID","sourceID","message","args","ChannelReciever","listeners","on","sender","__emitEvent","__broadCastMessageTypes","createSubChannel","deleteSubChannel","subChannel","getID","listener","call","processes","Channel","createSender","createReceiver"],"mappings":"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","file":"channel.js","sourcesContent":["import IPC from \"./IPC\";\r\n\r\n/**\r\n * A class to send certain messages on a channel\r\n */\r\nclass ChannelSender{\r\n    /**\r\n     * Create a new channel sender, allowing to send messages to the channel\r\n     * @param {String} ID           The unique identifier for the channel\r\n     * @param {String} subChannelID The subChannelID that will be used to access special subchannel methods\r\n     * @param {String} senderID     An ID that the reciever of this channel can respond to (can be left out)\r\n     */\r\n    constructor(ID, subChannelID, senderID){\r\n        this.ID = ID;\r\n        this.subChannelID = subChannelID;\r\n        this.senderID = senderID;\r\n\r\n        // Listen for the available message types being send\r\n        this.__setupChannelMessageTypeListener();\r\n    }\r\n\r\n    // Protected methods\r\n    /**\r\n     * Either requests methods to be set up according to the available message types,\r\n     * Or sets up the actual methods according to the passed data\r\n     * @param  {Object} types The available message types\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    _setupMethods(types){\r\n        // Check if this call is initiating the setup, or actually setting up the data\r\n        if(!types){ // The call is initiating the setup\r\n            // Check if the channel hasn't been set up already\r\n            if(this.initialised){\r\n                return new Promise((resolve, reject)=>{\r\n                    resolve(this);\r\n                });\r\n            }else{\r\n                // Broadcast a request for all message types of this channel\r\n                IPC.send(\"channel.requestMessageTypes:\"+this.ID);\r\n                return new Promise((resolve, reject)=>{\r\n                    this.finishSetup = resolve;\r\n                });\r\n            }\r\n        }else{ // Call is actually setting up the data\r\n            // Gatyher the relevant message types\r\n            var messageTypes = types.globalListeners;\r\n            var subChannelMessageTypes = types.subChannelListeners[this.subChannelID];\r\n            if(subChannelMessageTypes)\r\n                messageTypes = messageTypes.concat(subChannelMessageTypes);\r\n\r\n            // Setup the methods\r\n            for(let key of messageTypes)\r\n                this[key] = function(){\r\n                    this.__sendMessage(key, Array.from(arguments));\r\n                };\r\n\r\n            // Notify that the channel is ready\r\n            this.initialised = true;\r\n            if(this.finishSetup) this.finishSetup(this);\r\n        }\r\n    }\r\n    /**\r\n     * Get the channel ID\r\n     * @return {String} The channel ID\r\n     */\r\n    _getID(){\r\n        return this.ID;\r\n    }\r\n    /**\r\n     * Get the subchannel ID\r\n     * @return {String} The subchannel ID\r\n     */\r\n    _getSubChannelID(){\r\n        return this.subChannelID;\r\n    }\r\n\r\n    // Private methods\r\n    /**\r\n     * Starts listening for the channel receiver to send its available message types\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    __setupChannelMessageTypeListener(){\r\n        IPC.once(\"channel.sendMessageTypes:\"+this.ID, event=>{\r\n            // Check if all the subchannel methods have already been defined\r\n            if(!this.subChannelID || event.data.subChannelListeners[this.subChannelID]){\r\n                // Store the location to send the messages to\r\n                this.destProcessID = event.sourceID;\r\n\r\n                // Setup the methods of this object\r\n                this._setupMethods(event.data);\r\n            }else{\r\n                // Continue listening for message types if the subchannel hadn't been set up yet\r\n                this.__setupChannelMessageTypeListener();\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Send a message to the channel receiver\r\n     * @param  {[type]} message The message type\r\n     * @param  {[type]} args    The data to send as an argment array\r\n     * @return {Undefined}      The method returns no useful information\r\n     */\r\n    __sendMessage(message, args){\r\n        // Send the message and relevant data to the process/window that contains the channel receiver\r\n        IPC.send(\"channel.message:\"+this.ID, {\r\n            message: message,\r\n            subChannelID: this.subChannelID,\r\n            senderID: this.senderID,\r\n            data: args\r\n        }, this.destProcessID);\r\n    }\r\n}\r\n\r\n/**\r\n * A class to listen for certain messages sent on a channel\r\n */\r\nclass ChannelReciever{\r\n    /**\r\n     * Create a new channel reciever, allowing to recieve messages from the channel\r\n     * @param {String} ID           The unique identifier for the channel\r\n     * @param {Object} listeners    An object of functions to act on messages indexed by message type\r\n     */\r\n    constructor(ID, listeners){\r\n        this.ID = ID;\r\n\r\n        // Create objects to store listeners\r\n        this.globalListeners = listeners;\r\n        this.subChannelListeners = {};\r\n\r\n        // Forward IPC messages\r\n        IPC.on(\"channel.message:\"+ID, event=>{\r\n            var data = event.data;\r\n\r\n            // Extract the data to build the event to emit in this channel\r\n            var sender = data.senderID;\r\n            var subChannelID = data.subChannelID;\r\n            var message = data.message;\r\n            data = data.data;\r\n\r\n            // Emit the event\r\n            this.__emitEvent(message, {\r\n                senderID: sender,\r\n                data: data\r\n            }, subChannelID);\r\n        });\r\n\r\n        // Send available message types on request\r\n        IPC.on(\"channel.requestMessageTypes:\"+ID, event=>{\r\n            this.__broadCastMessageTypes(event.sourceID);\r\n        });\r\n\r\n        // Send available message types to all processes/renderers\r\n        this.__broadCastMessageTypes(\"*\");\r\n    }\r\n    /**\r\n     * Create a subchannel that can overwrite certain listeners on the channel, or add listeners just for the sub channel\r\n     * @param  {String} ID        The ID of the subchannel\r\n     * @param  {Object} listeners An object of functions to act on messages indexed by message type\r\n     * @return {Undefined}        The method returns no useful information\r\n     */\r\n    createSubChannel(ID, listeners){\r\n        this.subChannelListeners[ID] = listeners;\r\n        this.__broadCastMessageTypes(\"*\");\r\n    }\r\n    /**\r\n     * Delete a subchannel\r\n     * @param  {String} ID The subChannel to remove\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    deleteSubChannel(ID){\r\n        delete this.subChannel[ID];\r\n    }\r\n    /**\r\n     * Get the channel ID\r\n     * @return {String} The channel ID\r\n     */\r\n    getID(){\r\n        return this.ID;\r\n    }\r\n\r\n    // Private methods\r\n    /**\r\n     * Emit an event to the registered listener\r\n     * @param  {String} message         The event type to invoke\r\n     * @param  {Object} event           The event data to pass to the listener\r\n     * @param  {[type]} subChannelID    The subchannel of which to take the listener if available\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    __emitEvent(message, event, subChannelID){\r\n        if(subChannelID){\r\n            // Attempt to find message listeners on this subchannel\r\n            var subChannel = this.subChannelListeners[subChannelID];\r\n            var listener = subChannel && subChannel[message];\r\n\r\n            // If listeners exist, call them and don't invoke any global listeners\r\n            if(listener){\r\n                listener.call(this, event);\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Retrieve listeners\r\n        var listener = this.globalListeners[message];\r\n\r\n        // If listeners exist, call them\r\n        if(listener)\r\n            listener.call(this, event);\r\n    }\r\n    /**\r\n     * Broadcast all available message types to the specified renderers/processes\r\n     * @param  {String|[String, ...]} [processes=\"*\"] The renderers/processes to send the message types to\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    __broadCastMessageTypes(processes=\"*\"){\r\n        // Create object to broadcast to the requesting renderer/process\r\n        var messageTypes = {\r\n            globalListeners: Object.keys(this.globalListeners),\r\n            subChannelListeners: {\r\n                // Will be filled by the for loop below\r\n            }\r\n        };\r\n\r\n        // Add all the subChannel\r\n        for(var key in this.subChannelListeners)\r\n            messageTypes.subChannelListeners[key] = Object.keys(this.subChannelListeners[key]);\r\n\r\n        // Broadcast the messages\r\n        IPC.send(\"channel.sendMessageTypes:\"+this.ID, messageTypes, processes);\r\n    }\r\n}\r\n\r\n/**\r\n * The public class to create channel senders and recievers, as the creation of a channel sender is asynchronous\r\n */\r\nexport default class Channel{\r\n    /**\r\n     * Create a new channel sender, allowing to send messages to the channel\r\n     * @param {String} ID           The unique identifier for the channel\r\n     * @param {String} subChannelID The subChannelID that will be used to access special subchannel methods\r\n     * @param {String} senderID     An ID that the reciever of this channel can respond to (can be left out)\r\n     */\r\n    static createSender(ID, subChannelID, senderID){\r\n        return new ChannelSender(ID, subChannelID, senderID)._setupMethods();\r\n    }\r\n    /**\r\n     * Create a new channel reciever, allowing to recieve messages from the channel\r\n     * @param {String} ID           The unique identifier for the channel\r\n     * @param {Object} listeners    An object of functions to act on messages indexed by message type\r\n     */\r\n    static createReceiver(ID, listeners){\r\n        return new ChannelReciever(ID, listeners);\r\n    }\r\n}\r\n"]}