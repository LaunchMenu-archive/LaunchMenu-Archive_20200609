{"version":3,"sources":["../../../src/core/communication/IPC.js"],"names":["IPC","send","type","data","dest","source","encodedData","ExtendedJSON","encode","_isRenderer","forwardData","sourceID","ID","ipcRenderer","windows","_getWindows","i","push","Array","forEach","id","__emitEvent","window","Number","webContents","on","handler","listeners","index","indexOf","once","orHandler","event","off","call","splice","getID","_registerWindow","_deregisterWindow","listener","__setup","require","remote","getCurrentWindow","arg","decode","ipcMain"],"mappings":"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","file":"IPC.js","sourcesContent":["import {ipcMain, ipcRenderer} from \"electron\";\r\n// import ExtendedJSON from \"./extendedJSON\";\r\nimport ExtendedJSON from \"../communication/extendedJSON\";\r\n/**\r\n * A class that allows for communication between different processes and renderers\r\n */\r\nclass IPC{\r\n    /**\r\n     * Send data to another window or the main script\r\n     * @param  {String} type The event type to send (preferbly prefixed with some module ID)\r\n     * @param  {Object} data The data to send\r\n     * @param  {String|[String, ...]} [dest=\"*\"] The window ID(s) to send this data to\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    static send(type, data, dest=\"*\", source=0){\r\n        var encodedData = ExtendedJSON.encode(data);\r\n        if(this._isRenderer()){ // If the call is made from a renderer\r\n            // Send the data to the main process such that it can spread it to the appropriate windows\r\n            var forwardData = {dest:dest, type:type, sourceID:this.ID, data:encodedData};\r\n            ipcRenderer.send(\"IPC.forward\", forwardData);\r\n        }else{\r\n            // Send the data to the appropriate windows\r\n            var windows = this._getWindows();\r\n\r\n            // Format the destination\r\n            if(dest==\"*\"){\r\n                // If we want to target all windows (and the main thread), create a list of all destinations\r\n                dest = [];\r\n                for(var i in windows)\r\n                    dest.push(i);\r\n            }else if(!(dest instanceof Array))\r\n                // If only a single destination is provided, still make sure it is an array\r\n                dest = [dest];\r\n\r\n            // Go through all destionations and send the data\r\n            dest.forEach(id =>{\r\n                if(id==0){ // Target the main process\r\n                    // Emit the event if the main window is a destination of the event\r\n                    this.__emitEvent(type, {sourceID:source, data:data});\r\n                }else{ // Target a window\r\n                    var window = windows[Number(id)];\r\n                    if(window)\r\n                        window.webContents.send(\"IPC.recieve\", {type:type, sourceID:source, data:encodedData});\r\n                }\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Listen for data being send by the main process or renderers\r\n     * @param  {String} type The type of event to listen for\r\n     * @param  {Function(event)} handler The function to handle the event occuring\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    static on(type, handler){\r\n        if(!this.listeners[type]) this.listeners[type] = [];\r\n        var listeners = this.listeners[type];\r\n        var index = listeners.indexOf(handler);\r\n        if(index==-1) listeners.push(handler);\r\n    }\r\n    /**\r\n     * Listen for data being send by the main process or renderers, but only listen for it once\r\n     * @param  {String} type The type of event to listen for\r\n     * @param  {Function(event)} handler The function to handle the event when occuring\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    static once(type, handler){\r\n        var orHandler = handler;\r\n        handler = event=>{\r\n            this.off(type, handler);\r\n            orHandler.call(this, event);\r\n        };\r\n        this.on(type, handler);\r\n    }\r\n    /**\r\n     * Stop listening for data being send by the main process or renderers\r\n     * @param  {String} type The type of event that is being listened for\r\n     * @param  {Function(event)} handler The function that handles the event when occuring\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    static off(type, handler){\r\n        var listeners = this.listeners[type];\r\n        if(listeners){\r\n            var index = listeners.indexOf(handler);\r\n            if(index!=-1) listeners.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the identifier of this process or renderer which other processes or renderers can use to communicate\r\n     * @return {Number} The numeric identifier\r\n     */\r\n    static getID(){\r\n        return this.ID;\r\n    }\r\n\r\n    // Protected methods\r\n    /**\r\n     * Get all the windows that are registered and can be communicated with (only works in the main process)\r\n     * @return {[BrowserWindow]} The actual windows\r\n     */\r\n    static _getWindows(){\r\n        return this.windows;\r\n    }\r\n    /**\r\n     * Register a window such that it can start communicating with other processes and windows\r\n     * @param  {BrowserWindow} window The window to register\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    static _registerWindow(window){\r\n        this.windows[window.id] = window;\r\n    }\r\n    /**\r\n     * Deregister a window for when it is destroyed, such that it is no longer listed as a valid window\r\n     * @param  {BrowserWindow} window The window to deregister\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    static _deregisterWindow(window){\r\n        var index = this.windows.indexOf(window);\r\n        if(index!=-1) delete this.windows[index];\r\n    }\r\n    /**\r\n     * A method to check whether this is the main process or a renderer\r\n     * @return {Boolean} The boolean indicating whether this is a renderer\r\n     */\r\n    static _isRenderer(){\r\n        return !!ipcRenderer;\r\n    }\r\n\r\n    // Private methods\r\n    /**\r\n     * Emit an event to all the registered listeners\r\n     * @param  {String} type  The event type to invoke\r\n     * @param  {Object} event The event data to pass to the listeners\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    static __emitEvent(type, event){\r\n        var listeners = this.listeners[type];\r\n        if(listeners)\r\n            listeners.forEach(listener=>{\r\n                listener.call(this, event);\r\n            });\r\n    }\r\n    /**\r\n     * The initial setup method to be called by this file itself, initialises the static fields of the class\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    static __setup(){\r\n        this.windows = [this];\r\n        this.listeners = {};\r\n\r\n        if(this._isRenderer()){\r\n            this.ID = require('electron').remote.getCurrentWindow().id; // Starts from 1\r\n\r\n            // Emit the event to all listeners whenever it is recieved\r\n            ipcRenderer.on(\"IPC.recieve\", (event, arg)=>{\r\n                this.__emitEvent(arg.type, {sourceID:arg.sourceID, data:ExtendedJSON.decode(arg.data)});\r\n            });\r\n        }else{ // Means it runs in a renderer\r\n            this.ID = 0;\r\n\r\n            // Forward the call made by a renderer, and passing the sourceID to track the origin\r\n            ipcMain.on(\"IPC.forward\", (event, arg)=>{\r\n                this.send(arg.type, ExtendedJSON.decode(arg.data), arg.dest, arg.sourceID);\r\n            });\r\n        }\r\n    }\r\n}\r\nIPC.__setup();\r\nexport default IPC;\r\n"]}