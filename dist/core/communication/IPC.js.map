{"version":3,"sources":["../../../src/core/communication/IPC.js"],"names":["IPC","send","type","data","dest","__send","on","handler","listeners","index","indexOf","push","once","orHandler","event","off","call","splice","getID","ID","_getWindows","windows","_registerWindow","window","id","_deregisterWindow","_isRenderer","ipcRenderer","__emitEvent","responses","forEach","listener","response","source","respID","undefined","promise","resolve","res","reject","responseListeners","responseOriginsReceived","encodedData","ExtendedJSON","encode","forwardData","sourceID","responseID","i","Array","length","Number","destCount","__sendResponse","responseOriginCount","webContents","responseData","__recieveResponse","rl","concat","__setup","require","remote","getCurrentWindow","arg","decode","ipcMain"],"mappings":"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","file":"IPC.js","sourcesContent":["import {ipcMain, ipcRenderer} from \"electron\";\r\n// import ExtendedJSON from \"./extendedJSON\";\r\nimport ExtendedJSON from \"../communication/extendedJSON\";\r\n/**\r\n * A class that allows for communication between different processes and renderers\r\n */\r\nclass IPC{\r\n    /**\r\n     * Send data to another window or the main script\r\n     * @param  {String} type                        The event type to send (preferbly prefixed with some module ID)\r\n     * @param  {Object} data                        The data to send\r\n     * @param  {String|[String, ...]} [dest=\"*\"]    The window ID(s) to send this data to\r\n     * @return {Promise} The promise that will get called with all the returned data from the listeners\r\n     */\r\n    static send(type, data, dest=\"*\"){\r\n        return this.__send(type, data, dest);\r\n    }\r\n    /**\r\n     * Listen for data being send by the main process or renderers\r\n     * @param  {String} type                The type of event to listen for\r\n     * @param  {Function(event)} handler    The function to handle the event occuring\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    static on(type, handler){\r\n        if(!this.listeners[type]) this.listeners[type] = [];\r\n        const listeners = this.listeners[type];\r\n        const index = listeners.indexOf(handler);\r\n        if(index==-1) listeners.push(handler);\r\n    }\r\n    /**\r\n     * Listen for data being send by the main process or renderers, but only listen for it once\r\n     * @param  {String} type                The type of event to listen for\r\n     * @param  {Function(event)} handler    The function to handle the event when occuring\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    static once(type, handler){\r\n        const orHandler = handler;\r\n        handler = event=>{\r\n            this.off(type, handler);\r\n            orHandler.call(this, event);\r\n        };\r\n        this.on(type, handler);\r\n    }\r\n    /**\r\n     * Stop listening for data being send by the main process or renderers\r\n     * @param  {String} type                The type of event that is being listened for\r\n     * @param  {Function(event)} handler    The function that handles the event when occuring\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    static off(type, handler){\r\n        const listeners = this.listeners[type];\r\n        if(listeners){\r\n            const index = listeners.indexOf(handler);\r\n            if(index!=-1) listeners.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the identifier of this process or renderer which other processes or renderers can use to communicate\r\n     * @return {Number} The numeric identifier\r\n     */\r\n    static getID(){\r\n        return this.ID;\r\n    }\r\n\r\n    // Protected methods\r\n    /**\r\n     * Get all the windows that are registered and can be communicated with (only works in the main process)\r\n     * @return {[BrowserWindow]} The actual windows\r\n     */\r\n    static _getWindows(){\r\n        return this.windows;\r\n    }\r\n    /**\r\n     * Register a window such that it can start communicating with other processes and windows\r\n     * @param  {BrowserWindow} window The window to register\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    static _registerWindow(window){\r\n        this.windows[window.id] = window;\r\n    }\r\n    /**\r\n     * Deregister a window for when it is destroyed, such that it is no longer listed as a valid window\r\n     * @param  {BrowserWindow} window The window to deregister\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    static _deregisterWindow(window){\r\n        const index = this.windows.indexOf(window);\r\n        if(index!=-1) delete this.windows[index];\r\n    }\r\n    /**\r\n     * A method to check whether this is the main process or a renderer\r\n     * @return {Boolean} The boolean indicating whether this is a renderer\r\n     */\r\n    static _isRenderer(){\r\n        return !!ipcRenderer;\r\n    }\r\n\r\n    // Private methods\r\n    /**\r\n     * Emit an event to all the registered listeners\r\n     * @param  {String} type  The event type to invoke\r\n     * @param  {Object} event The event data to pass to the listeners\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    static __emitEvent(type, event){\r\n        const listeners = this.listeners[type];\r\n        const responses = [];\r\n\r\n        // Emit the event itself\r\n        if(listeners)\r\n            listeners.forEach(listener=>{\r\n                var response = listener.call(this, event);\r\n                responses.push(response);\r\n            });\r\n\r\n        // Return the responses of the event\r\n        return responses;\r\n    }\r\n    /**\r\n     * Send data to another window or the main script\r\n     * @param  {String} type                        The event type to send (preferbly prefixed with some module ID)\r\n     * @param  {Object} data                        The data to send\r\n     * @param  {String|[String, ...]} [dest=\"*\"]    The window ID(s) to send this data to\r\n     * @param  {Number} source                      The process/renderer ID that the event was originally sent from\r\n     * @param  {Number} respID                      The ID of the response listener in the source process/renderer to call\r\n     * @return {Promise} The promise that will get called with all the returned data from the listeners\r\n     */\r\n    static __send(type, data, dest=\"*\", source=0, respID=undefined){\r\n        // Only create a promise if this is not a forwarded event\r\n        let promise;\r\n        if(respID==undefined){\r\n            // Create a promise that can be used to return a response\r\n            let resolve;\r\n            promise = new Promise((res, reject)=>{\r\n                resolve = res;\r\n            });\r\n            // Register the response listener\r\n            respID = this.responseListeners.ID++;\r\n            this.responseListeners[respID] = {\r\n                resolve,                        // The resolve function to call when finished\r\n                responseOriginsReceived: 0,     // The number of processes/renderers that have returned responses\r\n                responses: []                   // The responses that have been recieved so far\r\n            };\r\n        }\r\n\r\n        // Send the data\r\n        const encodedData = ExtendedJSON.encode(data);\r\n        if(this._isRenderer()){ // If the call is made from a renderer\r\n            // Send the data to the main process such that it can spread it to the appropriate windows\r\n            const forwardData = {dest:dest, type:type, sourceID:this.ID, responseID:respID, data:encodedData};\r\n            ipcRenderer.send(\"IPC.forward\", forwardData);\r\n        }else{\r\n            // Send the data to the appropriate windows\r\n            const windows = this._getWindows();\r\n\r\n            // Format the destination\r\n            if(dest==\"*\"){\r\n                // If we want to target all windows (and the main thread), create a list of all destinations\r\n                dest = [];\r\n                for(let i in windows)\r\n                    dest.push(i);\r\n            }else if(!(dest instanceof Array)){\r\n                // If only a single destination is provided, still make sure it is an array\r\n                dest = [dest];\r\n            }else{\r\n                // Remove all invalid window ids\r\n                for(let i=dest.length-1; i>=0; i--){\r\n                    let id = dest[i];\r\n                    if(!this.windows[Number(id)])\r\n                        dest.splice(i, 1);\r\n                }\r\n            }\r\n\r\n            // Go through all destionations and send the data\r\n            const destCount = dest.length;\r\n            dest.forEach(id=>{\r\n                if(id==0){ // Target the main process\r\n                    // Emit the event if the main process is a destination of the event\r\n                    const responses = this.__emitEvent(type, {\r\n                        sourceID: source,\r\n                        data: data\r\n                    });\r\n\r\n                    // Return responses\r\n                    this.__sendResponse(source, {\r\n                        responseID: respID,\r\n                        responseOriginCount: destCount,\r\n                        responses: responses\r\n                    });\r\n\r\n                }else{ // Target a window\r\n                    const window = this.windows[Number(id)];\r\n                    if(window){\r\n                        window.webContents.send(\"IPC.recieve\", {\r\n                            type: type,\r\n                            sourceID: source,\r\n                            data: encodedData,\r\n                            responseID: respID,\r\n                            responseOriginCount: destCount\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        // Return the response promise\r\n        return promise;\r\n    }\r\n    /**\r\n     * Send a response to the source window that emitted the event\r\n     * @param  {Number} sourceID                         The ID of the event source process/renderer\r\n     * @param  {NUmber} responseData.responseID          The ID of the response in said process/renderer\r\n     * @param  {Array}  responseData.responses           The actual array of returned responses\r\n     * @param  {Number} responseData.responseOriginCount The number of processes/renderers that need to return responses\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    static __sendResponse(sourceID, responseData){\r\n        // Check whether this is the main process or a renderer\r\n        if(this._isRenderer()){\r\n            // If this is a renderer, pass the response back to the main process\r\n            responseData.sourceID = sourceID;\r\n            ipcRenderer.send(\"IPC.forwardResponse\", responseData);\r\n        }else{\r\n            // If this is the main process, and the event was sent by the main process, process the data\r\n            if(sourceID==0){\r\n                this.__recieveResponse(responseData.responseID, responseData.responses, responseData.responseOriginCount);\r\n            // If this is the main process and the data was meant for a renderer, forward the data\r\n            }else{\r\n                const window = this.windows[Number(sourceID)];\r\n                if(window){\r\n                    window.webContents.send(\"IPC.recieveResponse\", responseData);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Recieve a response from some process/renderer, and resolve promise when all are recieved\r\n     * @param  {Number} responseID          The ID of the response identifier\r\n     * @param  {Array}  responses           The actual array of returned responses\r\n     * @param  {Number} responseOriginCount The number of processes/renderers that need to return responses\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    static __recieveResponse(responseID, responses, responseOriginCount){\r\n        // Find the attached response listener from the ID\r\n        const rl = this.responseListeners[responseID];\r\n        if(rl){\r\n            // Combine the new responses with the already recieved responses\r\n            rl.responses = rl.responses.concat(responses);\r\n\r\n            // Increase the response count, and if it matches the required response count, resolve the promise\r\n            if(++rl.responseOriginsReceived==responseOriginCount){\r\n                // Delete the listener, and resolve the promise\r\n                delete this.responseListeners[responseID];\r\n                rl.resolve(rl.responses);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * The initial setup method to be called by this file itself, initialises the static fields of the class\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    static __setup(){\r\n        this.windows = [this];           // The available windows to forward the events to\r\n        this.listeners = {};             // The event listeners in this process/renderer\r\n        this.responseListeners = {ID:0}; // The response listeners in this process/renderer\r\n\r\n        // Check whether this is the main process or a renderer\r\n        if(this._isRenderer()){\r\n            this.ID = require('electron').remote.getCurrentWindow().id; // (Starts from 1)\r\n\r\n            // Emit the event to all listeners whenever it is recieved\r\n            ipcRenderer.on(\"IPC.recieve\", (event, arg)=>{\r\n                // Emit the event when recieved\r\n                const responses = this.__emitEvent(arg.type, {\r\n                    sourceID: arg.sourceID,\r\n                    data: ExtendedJSON.decode(arg.data)\r\n                });\r\n\r\n                // Return responses\r\n                this.__sendResponse(arg.sourceID, {\r\n                    responseID: arg.responseID,\r\n                    responseOriginCount: arg.responseOriginCount,\r\n                    responses: responses\r\n                });\r\n            });\r\n\r\n            // Call the response listener whenever the response returned\r\n            ipcRenderer.on(\"IPC.recieveResponse\", (event, arg)=>{\r\n                this.__recieveResponse(arg.responseID, arg.responses, arg.responseOriginCount);\r\n            });\r\n        }else{  // Is the main thread\r\n            this.ID = 0;\r\n\r\n            // Forward the call made by a renderer, and passing the sourceID to track the origin\r\n            ipcMain.on(\"IPC.forward\", (event, arg)=>{\r\n                this.__send(arg.type, ExtendedJSON.decode(arg.data), arg.dest, arg.sourceID, arg.responseID);\r\n            });\r\n\r\n            // Return any responses to the source process/renderer when recieved\r\n            ipcMain.on(\"IPC.forwardResponse\", (event, arg)=>{\r\n                this.__sendResponse(arg.sourceID, arg);\r\n            });\r\n        }\r\n    }\r\n}\r\nIPC.__setup();\r\nexport default IPC;\r\n"]}