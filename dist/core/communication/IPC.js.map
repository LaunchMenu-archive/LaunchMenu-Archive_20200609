{"version":3,"sources":["../../../src/core/communication/IPC.js"],"names":["IPC","send","type","data","dest","__send","sendSync","__sendSync","on","handler","listeners","index","indexOf","push","once","handleMiddleware","event","off","apply","arguments","splice","getID","ID","_getWindows","windows","_registerWindow","window","windowID","_deregisterWindow","__emitEvent","sync","responses","promises","forEach","listener","response","call","all","then","promiseResponses","concat","source","respID","undefined","promise","resolve","res","reject","responseListeners","responseOriginsReceived","encodedData","ExtendedJSON","encode","isMain","Array","i","length","id","Number","destCount","getResponses","sourceID","__sendResponse","responseID","responseOriginCount","webContents","ipcRenderer","decode","responseData","__recieveResponse","rl","__setup","ipcMain","arg","returnValue"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;;AACA;;;;AACA;;;;;;AAEA;;;;;;AAMA;;;;;AAKe,MAAMA,GAAN,CAAU;AACrB;;;;;;;;;AASA,WAAOC,IAAP,CAAYC,IAAZ,EAAkBC,IAAlB,EAAwBC,OAAO,GAA/B,EAAoC;AAChC;AACA,eAAO,KAAKC,MAAL,CAAYH,IAAZ,EAAkBC,IAAlB,EAAwBC,IAAxB,CAAP;AACH;;AAED;;;;;;;AAOA,WAAOE,QAAP,CAAgBJ,IAAhB,EAAsBC,IAAtB,EAA4B;AACxB;AACA,eAAO,KAAKI,UAAL,CAAgBL,IAAhB,EAAsBC,IAAtB,CAAP;AACH;;AAED;AACA;;;;;;;AAOA,WAAOK,EAAP,CAAUN,IAAV,EAAgBO,OAAhB,EAAyB;AACrB;AACA,YAAI,CAAC,KAAKC,SAAL,CAAeR,IAAf,CAAL,EAA2B,KAAKQ,SAAL,CAAeR,IAAf,IAAuB,EAAvB;;AAE3B;AACA,cAAMQ,YAAY,KAAKA,SAAL,CAAeR,IAAf,CAAlB;;AAEA;AACA,cAAMS,QAAQD,UAAUE,OAAV,CAAkBH,OAAlB,CAAd;AACA,YAAIE,SAAS,CAAC,CAAd,EAAiBD,UAAUG,IAAV,CAAeJ,OAAf;AACpB;;AAED;;;;;;;AAOA,WAAOK,IAAP,CAAYZ,IAAZ,EAAkBO,OAAlB,EAA2B;AACvB;AACA,cAAMM,mBAAmB,UAASC,KAAT,EAAgB;AACrC;AACA,iBAAKC,GAAL,CAASf,IAAT,EAAea,gBAAf;;AAEA;AACAN,oBAAQS,KAAR,CAAc,IAAd,EAAoBC,SAApB;AACH,SAND;;AAQA;AACA,eAAO,KAAKX,EAAL,CAAQN,IAAR,EAAca,gBAAd,CAAP;AACH;;AAED;;;;;;;AAOA,WAAOE,GAAP,CAAWf,IAAX,EAAiBO,OAAjB,EAA0B;AACtB;AACA,cAAMC,YAAY,KAAKA,SAAL,CAAeR,IAAf,CAAlB;AACA,YAAIQ,SAAJ,EAAe;AACX;AACA,kBAAMC,QAAQD,UAAUE,OAAV,CAAkBH,OAAlB,CAAd;AACA,gBAAIE,SAAS,CAAC,CAAd,EAAiBD,UAAUU,MAAV,CAAiBT,KAAjB,EAAwB,CAAxB;AACpB;AACJ;;AAED;;;;;AAKA,WAAOU,KAAP,GAAe;AACX,eAAO,KAAKC,EAAZ;AACH;;AAED;;;;;AAKA,WAAOC,WAAP,GAAqB;AACjB,eAAO,KAAKC,OAAZ;AACH;;AAED;;;;;;;AAOA,WAAOC,eAAP,CAAuBC,MAAvB,EAA+BC,QAA/B,EAAyC;AACrC,aAAKH,OAAL,CAAaG,QAAb,IAAyBD,MAAzB;AACH;;AAED;;;;;;AAMA,WAAOE,iBAAP,CAAyBD,QAAzB,EAAmC;AAC/B,eAAO,KAAKH,OAAL,CAAaG,QAAb,CAAP;AACH;;AAED;;;;;;;;;AASA,WAAOE,WAAP,CAAmB3B,IAAnB,EAAyBc,KAAzB,EAAgCc,IAAhC,EAAsC;AAClC;AACA,cAAMpB,YAAY,KAAKA,SAAL,CAAeR,IAAf,CAAlB;;AAEA;AACA,cAAM6B,YAAY,EAAlB;AACA,cAAMC,WAAW,EAAjB;;AAEA;AACA,YAAItB,SAAJ,EACIA,UAAUuB,OAAV,CAAkBC,YAAY;AAC1B;AACA,kBAAMC,WAAWD,SAASE,IAAT,CAAc,IAAd,EAAoBpB,KAApB,CAAjB;;AAEA;AACA,gBAAImB,qCAAJ,EAAiC;AAC7BH,yBAASnB,IAAT,CAAcsB,QAAd;AACH,aAFD,MAEO;AACHJ,0BAAUlB,IAAV,CAAesB,QAAf;AACH;AACJ,SAVD;;AAYJ;AACA,YAAIL,IAAJ,EAAU,OAAOC,SAAP;;AAEV;AACA,eAAO,kBAAQM,GAAR,CAAYL,QAAZ,EAAsBM,IAAtB,CAA2BC,oBAAoB;AAClD,mBAAOR,UAAUS,MAAV,CAAiBD,gBAAjB,CAAP;AACH,SAFM,CAAP;AAGH;;AAED;;;;;;;;;;;AAWA,WAAOlC,MAAP,CAAcH,IAAd,EAAoBC,IAApB,EAA0BC,OAAO,GAAjC,EAAsCqC,SAAS,CAA/C,EAAkDC,SAASC,SAA3D,EAAsE;AAClE;AACA,YAAIC,OAAJ;AACA,YAAIF,UAAUC,SAAd,EAAyB;AACrB;AACA,gBAAIE,OAAJ;AACAD,sBAAU,sBAAY,CAACE,GAAD,EAAMC,MAAN,KAAiB;AACnCF,0BAAUC,GAAV;AACH,aAFS,CAAV;AAGA;AACAJ,qBAAS,KAAKM,iBAAL,CAAuB1B,EAAvB,EAAT;AACA,iBAAK0B,iBAAL,CAAuBN,MAAvB,IAAiC;AAC7BG,uBAD6B,EACpB;AACTI,yCAAyB,CAFI,EAED;AAC5BlB,2BAAW,EAHkB,CAGd;AAHc,aAAjC;AAKH;;AAED;AACA,cAAMmB,cAAcC,uBAAaC,MAAb,CAAoBjD,IAApB,CAApB;AACA,YAAIkD,gBAAJ,EAAY;AACR;AACA;AACA,kBAAM7B,UAAU,KAAKD,WAAL,EAAhB;;AAEA;AACA,gBAAInB,QAAQ,GAAZ,EAAiB;AACb;AACAA,uBAAO,oBAAYoB,OAAZ,CAAP;AACH,aAHD,MAGO,IAAI,EAAEpB,gBAAgBkD,KAAlB,CAAJ,EAA8B;AACjC;AACAlD,uBAAO,CAACA,IAAD,CAAP;AACH,aAHM,MAGA;AACH;AACA,qBAAK,IAAImD,IAAInD,KAAKoD,MAAL,GAAc,CAA3B,EAA8BD,KAAK,CAAnC,EAAsCA,GAAtC,EAA2C;AACvC,wBAAIE,KAAKrD,KAAKmD,CAAL,CAAT;AACA,wBAAI,CAAC/B,QAAQkC,OAAOD,EAAP,CAAR,CAAL,EAA0BrD,KAAKgB,MAAL,CAAYmC,CAAZ,EAAe,CAAf;AAC7B;AACJ;;AAED;AACA,kBAAMI,YAAYvD,KAAKoD,MAAvB;AACApD,iBAAK6B,OAAL,CAAawB,MAAM;AACf,oBAAIA,MAAM,CAAV,EAAa;AACT;AACA;AACA,0BAAMG,eAAe,KAAK/B,WAAL,CAAiB3B,IAAjB,EAAuB;AACxC2D,kCAAUpB,MAD8B;AAExCtC,8BAAMA;AAFkC,qBAAvB,CAArB;;AAKA;AACAyD,iCAAatB,IAAb,CAAkBP,aAAa;AAC3B,6BAAK+B,cAAL,CAAoBrB,MAApB,EAA4B;AACxBsB,wCAAYrB,MADY;AAExBsB,iDAAqBL,SAFG;AAGxB5B,uCAAWA;AAHa,yBAA5B;AAKH,qBAND;AAOH,iBAhBD,MAgBO;AACH;AACA,0BAAML,SAASF,QAAQkC,OAAOD,EAAP,CAAR,CAAf;AACA,wBAAI/B,MAAJ,EAAY;AACR;AACAA,+BAAOuC,WAAP,CAAmBhE,IAAnB,CAAwB,aAAxB,EAAuC;AACnCC,kCAAMA,IAD6B;AAEnC2D,sCAAUpB,MAFyB;AAGnCtC,kCAAM+C,WAH6B;AAInCa,wCAAYrB,MAJuB;AAKnCsB,iDAAqBL;AALc,yBAAvC;AAOH;AACJ;AACJ,aA/BD;AAgCH,SAtDD,MAsDO;AACH;AACAO,kCAAYjE,IAAZ,CAAiB,aAAjB,EAAgC;AAC5BG,sBAAMA,IADsB;AAE5BF,sBAAMA,IAFsB;AAG5B2D,0BAAU,KAAKvC,EAHa;AAI5ByC,4BAAYrB,MAJgB;AAK5BvC,sBAAM+C;AALsB,aAAhC;AAOH;;AAED;AACA,eAAON,OAAP;AACH;;AAED;;;;;;;;AAQA,WAAOrC,UAAP,CAAkBL,IAAlB,EAAwBC,IAAxB,EAA8B0D,QAA9B,EAAwC;AACpC,YAAIR,gBAAJ,EAAY;AACR;AACA,mBAAO,KAAKxB,WAAL,CACH3B,IADG,EAEH;AACI2D,0BAAUA,QADd;AAEI1D,sBAAMA;AAFV,aAFG,EAMH,IANG,CAAP;AAQH,SAVD,MAUO;AACH;AACA,kBAAMgC,WAAW+B,sBAAY5D,QAAZ,CAAqB,cAArB,EAAqC;AAClDJ,sBAAMA,IAD4C;AAElDC,sBAAMgD,uBAAaC,MAAb,CAAoBjD,IAApB;AAF4C,aAArC,CAAjB;AAIA,mBAAOgD,uBAAagB,MAAb,CAAoBhC,QAApB,CAAP;AACH;AACJ;;AAED;;;;;;;;;;AAUA,WAAO2B,cAAP,CAAsBD,QAAtB,EAAgCO,YAAhC,EAA8C;AAC1C;AACA,YAAIf,gBAAJ,EAAY;AACR;AACA,gBAAIQ,YAAY,CAAhB,EAAmB;AACf,qBAAKQ,iBAAL,CACID,aAAaL,UADjB,EAEIK,aAAarC,SAFjB,EAGIqC,aAAaJ,mBAHjB;;AAMA;AACH,aARD,MAQO;AACH,sBAAMtC,SAAS,KAAKF,OAAL,CAAakC,OAAOG,QAAP,CAAb,CAAf;AACA,oBAAInC,MAAJ,EAAY;AACRA,2BAAOuC,WAAP,CAAmBhE,IAAnB,CAAwB,qBAAxB,EAA+C;AAC3C8D,oCAAYK,aAAaL,UADkB;AAE3CC,6CAAqBI,aAAaJ,mBAFS;AAG3CjC,mCAAWoB,uBAAaC,MAAb,CAAoBgB,aAAarC,SAAjC;AAHgC,qBAA/C;AAKH;AACJ;AACJ,SApBD,MAoBO;AACH;AACAmC,kCAAYjE,IAAZ,CAAiB,qBAAjB,EAAwC;AACpC4D,0BAAUA,QAD0B;AAEpCE,4BAAYK,aAAaL,UAFW;AAGpCC,qCAAqBI,aAAaJ,mBAHE;AAIpCjC,2BAAWoB,uBAAaC,MAAb,CAAoBgB,aAAarC,SAAjC;AAJyB,aAAxC;AAMH;AACJ;;AAED;;;;;;;;AAQA,WAAOsC,iBAAP,CAAyBN,UAAzB,EAAqChC,SAArC,EAAgDiC,mBAAhD,EAAqE;AACjE;AACA,cAAMM,KAAK,KAAKtB,iBAAL,CAAuBe,UAAvB,CAAX;AACA,YAAIO,EAAJ,EAAQ;AACJ;AACAA,eAAGvC,SAAH,GAAeuC,GAAGvC,SAAH,CAAaS,MAAb,CAAoBT,SAApB,CAAf;;AAEA;AACA,gBAAI,EAAEuC,GAAGrB,uBAAL,IAAgCe,mBAApC,EAAyD;AACrD;AACA,uBAAO,KAAKhB,iBAAL,CAAuBe,UAAvB,CAAP;AACAO,mBAAGzB,OAAH,CAAWyB,GAAGvC,SAAd;AACH;AACJ;AACJ;;AAED;;;;;AAKA,WAAOwC,OAAP,GAAiB;AACb,aAAK/C,OAAL,GAAe,EAAC,GAAG,IAAJ,EAAf,CADa,CACa;AAC1B,aAAKd,SAAL,GAAiB,EAAjB,CAFa,CAEQ;AACrB,aAAKsC,iBAAL,GAAyB,EAAC1B,IAAI,CAAL,EAAzB,CAHa,CAGqB;;AAElC;AACA,YAAI+B,gBAAJ,EAAY;AACR,iBAAK/B,EAAL,GAAU,CAAV;;AAEA;AACAkD,8BAAQhE,EAAR,CAAW,aAAX,EAA0B,CAACQ,KAAD,EAAQyD,GAAR,KAAgB;AACtC,qBAAKpE,MAAL,CACIoE,IAAIvE,IADR,EAEIiD,uBAAagB,MAAb,CAAoBM,IAAItE,IAAxB,CAFJ,EAGIsE,IAAIrE,IAHR,EAIIqE,IAAIZ,QAJR,EAKIY,IAAIV,UALR;AAOH,aARD;;AAUA;AACAS,8BAAQhE,EAAR,CAAW,qBAAX,EAAkC,CAACQ,KAAD,EAAQyD,GAAR,KAAgB;AAC9CA,oBAAI1C,SAAJ,GAAgBoB,uBAAagB,MAAb,CAAoBM,IAAI1C,SAAxB,CAAhB,CAD8C,CACM;AACpD,qBAAK+B,cAAL,CAAoBW,IAAIZ,QAAxB,EAAkCY,GAAlC;AACH,aAHD;;AAKA;AACAD,8BAAQhE,EAAR,CAAW,cAAX,EAA2B,CAACQ,KAAD,EAAQyD,GAAR,KAAgB;AACvC;AACA,sBAAMtC,WAAW,KAAK5B,UAAL,CACbkE,IAAIvE,IADS,EAEbiD,uBAAagB,MAAb,CAAoBM,IAAItE,IAAxB,CAFa,EAGbsE,IAAIZ,QAHS,CAAjB;;AAMA;AACA7C,sBAAM0D,WAAN,GAAoBvB,uBAAaC,MAAb,CAAoBjB,QAApB,CAApB;AACH,aAVD;AAWH,SAhCD,MAgCO;AACH;AACA;;AAEA;AACA+B,kCAAY1D,EAAZ,CAAe,aAAf,EAA8B,CAACQ,KAAD,EAAQyD,GAAR,KAAgB;AAC1C;AACA,sBAAMb,eAAe,KAAK/B,WAAL,CAAiB4C,IAAIvE,IAArB,EAA2B;AAC5C2D,8BAAUY,IAAIZ,QAD8B;AAE5C1D,0BAAMgD,uBAAagB,MAAb,CAAoBM,IAAItE,IAAxB;AAFsC,iBAA3B,CAArB;;AAKA;AACAyD,6BAAatB,IAAb,CAAkBP,aAAa;AAC3B,yBAAK+B,cAAL,CAAoBW,IAAIZ,QAAxB,EAAkC;AAC9BE,oCAAYU,IAAIV,UADc;AAE9BC,6CAAqBS,IAAIT,mBAFK;AAG9BjC,mCAAWA;AAHmB,qBAAlC;AAKH,iBAND;AAOH,aAfD;;AAiBA;AACAmC,kCAAY1D,EAAZ,CAAe,qBAAf,EAAsC,CAACQ,KAAD,EAAQyD,GAAR,KAAgB;AAClD,qBAAKJ,iBAAL,CACII,IAAIV,UADR,EAEIZ,uBAAagB,MAAb,CAAoBM,IAAI1C,SAAxB,CAFJ,EAGI0C,IAAIT,mBAHR;AAKH,aAND;AAOH;AACJ;AAlboB;kBAAJhE,G;AAobrBA,IAAIuE,OAAJ","file":"IPC.js","sourcesContent":["import {ipcMain, ipcRenderer} from \"electron\";\r\nimport isMain from \"../isMain\";\r\nimport ExtendedJSON from \"../communication/extendedJSON\";\r\n\r\n/**\r\n * @typedef {object} IPC~IPCevent\r\n * @property {number} sourceID - The ID of the process/window that original sent the event\r\n * @property {*} data - The data that was sent with the event\r\n */\r\n\r\n/**\r\n * @classdesc A static class that allows for communication between different processes and windows\r\n * @class\r\n * @hideconstructor\r\n */\r\nexport default class IPC {\r\n    /**\r\n     * Send data to another window or the main script\r\n     * @param  {string} type - The event type to send (preferably prefixed with some class ID)\r\n     * @param  {Object} data - The data to send\r\n     * @param  {(string|string[])} [dest=\"*\"] - The process/window ID(s) to send this data to\r\n     * @returns {Promise<Object[]>} An array of all the data that listeners for the event have returned\r\n     * @async\r\n     * @public\r\n     */\r\n    static send(type, data, dest = \"*\") {\r\n        // Forward the event to the private send method (which can take additional arguments)\r\n        return this.__send(type, data, dest);\r\n    }\r\n\r\n    /**\r\n     * Send data synchronously to the main script\r\n     * @param  {string} type - The event type to send (preferably prefixed with some class ID)\r\n     * @param  {*} data - The data to send\r\n     * @returns {Object[]} An array of all the data that listeners for the event have returned\r\n     * @public\r\n     */\r\n    static sendSync(type, data) {\r\n        // Forward the event to the private sendSync method (which can take additional arguments)\r\n        return this.__sendSync(type, data);\r\n    }\r\n\r\n    // TODO: add proper handler definition once VScode fixes @callback\r\n    /**\r\n     * Listens for data being sent by a process/window\r\n     * @param  {string} type - The type of event to listen for\r\n     * @param  {function} handler - The function to handle the event occuring\r\n     * @returns {undefined}\r\n     * @public\r\n     */\r\n    static on(type, handler) {\r\n        // If there are no listeners for this type yet, create an array for them\r\n        if (!this.listeners[type]) this.listeners[type] = [];\r\n\r\n        // Get the array of listeners for this type\r\n        const listeners = this.listeners[type];\r\n\r\n        // Check if this listener is already present, if not, add it\r\n        const index = listeners.indexOf(handler);\r\n        if (index == -1) listeners.push(handler);\r\n    }\r\n\r\n    /**\r\n     * Listens for data being sent by a process/window, but only listen for it once\r\n     * @param  {string} type - The type of event to listen for\r\n     * @param  {function} handler - The function to handle the event occuring\r\n     * @returns {undefined}\r\n     * @public\r\n     */\r\n    static once(type, handler) {\r\n        // Create a handler middleware that will automaticall remove itself\r\n        const handleMiddleware = function(event) {\r\n            // As soon as an event is received, remove yourself\r\n            this.off(type, handleMiddleware);\r\n\r\n            // Call the handler itself with the same data\r\n            handler.apply(this, arguments);\r\n        };\r\n\r\n        // Add the handler middleware event listener\r\n        return this.on(type, handleMiddleware);\r\n    }\r\n\r\n    /**\r\n     * Stops listening for data being sent by a process/window\r\n     * @param  {String} type - The type of event that is being listened for\r\n     * @param  {Function(event)} - The function that handles the event when occuring\r\n     * @return {undefined}\r\n     * @public\r\n     */\r\n    static off(type, handler) {\r\n        // Get the listeners for this type, and check if even existent\r\n        const listeners = this.listeners[type];\r\n        if (listeners) {\r\n            // Get the index at which this handler is stored, and remove that index if present\r\n            const index = listeners.indexOf(handler);\r\n            if (index != -1) listeners.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the identifier of this process or window which other processes or windows can use to communicate\r\n     * @return {number} The numeric identifier\r\n     * @public\r\n     */\r\n    static getID() {\r\n        return this.ID;\r\n    }\r\n\r\n    /**\r\n     * Get all the windows that are registered and can be communicated with (only works in the main process)\r\n     * @return {BrowserWindow[]} The actual windows\r\n     * @protected\r\n     */\r\n    static _getWindows() {\r\n        return this.windows;\r\n    }\r\n\r\n    /**\r\n     * Register a window such that it can start communicating with other processes and windows\r\n     * @param  {BrowserWindow} window - The window to register\r\n     * @param  {number} windowID - The ID to register the window under\r\n     * @return {undefined}\r\n     * @protected\r\n     */\r\n    static _registerWindow(window, windowID) {\r\n        this.windows[windowID] = window;\r\n    }\r\n\r\n    /**\r\n     * Deregister a window for when it is destroyed, such that it is no longer listed as a valid window\r\n     * @param  {number} windowID - The ID the window is registered under\r\n     * @return {undefined}\r\n     * @protected\r\n     */\r\n    static _deregisterWindow(windowID) {\r\n        delete this.windows[windowID];\r\n    }\r\n\r\n    /**\r\n     * Emit an event to all the registered listeners in this process/window\r\n     * @param  {string} type  - The event type to invoke\r\n     * @param  {IPC~IPCevent} event - The event data to pass to the listeners\r\n     * @param  {boolean} [sync] - Whether to act synchronously and only allow sync returns\r\n     * @return {Promise<Object[]>} An array of all the data that listeners for the event have returned\r\n     * @async\r\n     * @private\r\n     */\r\n    static __emitEvent(type, event, sync) {\r\n        // Retrieve the listeners to send this event to\r\n        const listeners = this.listeners[type];\r\n\r\n        // Track the returned respones as well as promises\r\n        const responses = [];\r\n        const promises = [];\r\n\r\n        // Emit the event itself\r\n        if (listeners)\r\n            listeners.forEach(listener => {\r\n                // Call the listener and store what it returns\r\n                const response = listener.call(this, event);\r\n\r\n                // If it returns a promise, add it to the promises, otherwise add it to the responses\r\n                if (response instanceof Promise) {\r\n                    promises.push(response);\r\n                } else {\r\n                    responses.push(response);\r\n                }\r\n            });\r\n\r\n        // Return the responses of the event and ignore the promises if synchronous\r\n        if (sync) return responses;\r\n\r\n        // If not synchronous, wait for all promises to resolve, and add their results to the reponses\r\n        return Promise.all(promises).then(promiseResponses => {\r\n            return responses.concat(promiseResponses);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Send data to other processes/windows\r\n     * @param  {string} type - The event type to send (preferbly prefixed with some module ID)\r\n     * @param  {*} data - The data to send\r\n     * @param  {(string|string[])} [dest=\"*\"] - The process/window ID(s) to send this data to\r\n     * @param  {number} source - The process/window ID that the event was originally sent from\r\n     * @param  {number} respID - The ID of the response listener in the source process/window to call\r\n     * @return {Promise<Object[]>} An array of all the data that listeners for the event have returned\r\n     * @async\r\n     * @private\r\n     */\r\n    static __send(type, data, dest = \"*\", source = 0, respID = undefined) {\r\n        // Only create a promise if this is not a forwarded event\r\n        let promise;\r\n        if (respID == undefined) {\r\n            // Create a promise that can be used to return a response\r\n            let resolve;\r\n            promise = new Promise((res, reject) => {\r\n                resolve = res;\r\n            });\r\n            // Register the response listener\r\n            respID = this.responseListeners.ID++;\r\n            this.responseListeners[respID] = {\r\n                resolve, // The resolve function to call when finished\r\n                responseOriginsReceived: 0, // The number of processes/windows that have returned responses\r\n                responses: [], // The responses that have been recieved so far\r\n            };\r\n        }\r\n\r\n        // Send the data\r\n        const encodedData = ExtendedJSON.encode(data);\r\n        if (isMain) {\r\n            // If the call is made from the main process\r\n            // Send the data to the appropriate windows\r\n            const windows = this._getWindows();\r\n\r\n            // Format the destination\r\n            if (dest == \"*\") {\r\n                // If we want to target all windows (and the main thread), create a list of all destinations\r\n                dest = Object.keys(windows);\r\n            } else if (!(dest instanceof Array)) {\r\n                // If only a single destination is provided, still make sure it is an array\r\n                dest = [dest];\r\n            } else {\r\n                // Remove all invalid window ids\r\n                for (let i = dest.length - 1; i >= 0; i--) {\r\n                    let id = dest[i];\r\n                    if (!windows[Number(id)]) dest.splice(i, 1);\r\n                }\r\n            }\r\n\r\n            // Go through all destionations and send the data\r\n            const destCount = dest.length;\r\n            dest.forEach(id => {\r\n                if (id == 0) {\r\n                    // Target the main process\r\n                    // Emit the event if the main process is a destination of the event\r\n                    const getResponses = this.__emitEvent(type, {\r\n                        sourceID: source,\r\n                        data: data,\r\n                    });\r\n\r\n                    // Return responses\r\n                    getResponses.then(responses => {\r\n                        this.__sendResponse(source, {\r\n                            responseID: respID,\r\n                            responseOriginCount: destCount,\r\n                            responses: responses,\r\n                        });\r\n                    });\r\n                } else {\r\n                    // Target a window\r\n                    const window = windows[Number(id)];\r\n                    if (window) {\r\n                        // Tell a window that it received the event defined below, so it can emit it and send back its response data to main\r\n                        window.webContents.send(\"IPC.recieve\", {\r\n                            type: type,\r\n                            sourceID: source,\r\n                            data: encodedData,\r\n                            responseID: respID,\r\n                            responseOriginCount: destCount,\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n        } else {\r\n            // Send the event to the main process such that it can spread it to the appropriate windows\r\n            ipcRenderer.send(\"IPC.forward\", {\r\n                dest: dest,\r\n                type: type,\r\n                sourceID: this.ID,\r\n                responseID: respID,\r\n                data: encodedData,\r\n            });\r\n        }\r\n\r\n        // Return the response promise\r\n        return promise;\r\n    }\r\n\r\n    /**\r\n     * Send data synchronously to the main script\r\n     * @param  {string} type - The event type to send (preferably prefixed with some class ID)\r\n     * @param  {*} data - The data to send\r\n     * @param  {number} source - The process/window ID that the event was originally sent from\r\n     * @return {Object[]} An array of all the data that listeners for the event have returned\r\n     * @private\r\n     */\r\n    static __sendSync(type, data, sourceID) {\r\n        if (isMain) {\r\n            // If the call is made from the main process, just emit the event and return the responses\r\n            return this.__emitEvent(\r\n                type,\r\n                {\r\n                    sourceID: sourceID,\r\n                    data: data,\r\n                },\r\n                true\r\n            );\r\n        } else {\r\n            // Otherwise send the event to the main process and return the retrieved data from there\r\n            const response = ipcRenderer.sendSync(\"IPC.syncCall\", {\r\n                type: type,\r\n                data: ExtendedJSON.encode(data),\r\n            });\r\n            return ExtendedJSON.decode(response);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send a response to the source window that emitted the event\r\n     * @param  {string} sourceID - The ID of the event source process/window\r\n     * @param  {object} responseData - The response data\r\n     * @param  {number} responseData.responseID - The ID of the response in said process/window\r\n     * @param  {Object[]}  responseData.responses - The actual array of returned responses\r\n     * @param  {number} responseData.responseOriginCount - The number of processes/windows that need to return responses\r\n     * @return {undefined}\r\n     * @private\r\n     */\r\n    static __sendResponse(sourceID, responseData) {\r\n        // Check whether this is the main process or a window\r\n        if (isMain) {\r\n            // If this is the main process, and the event was sent by the main process, process the data\r\n            if (sourceID == 0) {\r\n                this.__recieveResponse(\r\n                    responseData.responseID,\r\n                    responseData.responses,\r\n                    responseData.responseOriginCount\r\n                );\r\n\r\n                // If this is the main process and the data was meant for anotherw process/window, forward the data\r\n            } else {\r\n                const window = this.windows[Number(sourceID)];\r\n                if (window) {\r\n                    window.webContents.send(\"IPC.recieveResponse\", {\r\n                        responseID: responseData.responseID,\r\n                        responseOriginCount: responseData.responseOriginCount,\r\n                        responses: ExtendedJSON.encode(responseData.responses),\r\n                    });\r\n                }\r\n            }\r\n        } else {\r\n            // If this is a process/window, pass the response back to the main process\r\n            ipcRenderer.send(\"IPC.forwardResponse\", {\r\n                sourceID: sourceID,\r\n                responseID: responseData.responseID,\r\n                responseOriginCount: responseData.responseOriginCount,\r\n                responses: ExtendedJSON.encode(responseData.responses),\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Recieve a response from some process/window, and resolve promise when all are recieved\r\n     * @param  {number} responseID - The ID of the response identifier\r\n     * @param  {Object[]}  responses - The actual array of returned responses\r\n     * @param  {number} responseOriginCount - The number of processes/windows that need to return responses\r\n     * @return {undefined}\r\n     * @private\r\n     */\r\n    static __recieveResponse(responseID, responses, responseOriginCount) {\r\n        // Find the attached response listener from the ID\r\n        const rl = this.responseListeners[responseID];\r\n        if (rl) {\r\n            // Combine the new responses with the already recieved responses\r\n            rl.responses = rl.responses.concat(responses);\r\n\r\n            // Increase the response count, and if it matches the required response count, resolve the promise\r\n            if (++rl.responseOriginsReceived == responseOriginCount) {\r\n                // Delete the listener, and resolve the promise\r\n                delete this.responseListeners[responseID];\r\n                rl.resolve(rl.responses);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The initial setup method to be called by this file itself, initialises the static fields of the class\r\n     * @return {undefined}\r\n     * @private\r\n     */\r\n    static __setup() {\r\n        this.windows = {0: this}; // The available windows to forward the events to\r\n        this.listeners = {}; // The event listeners in this process/window\r\n        this.responseListeners = {ID: 0}; // The response listeners in this process/window\r\n\r\n        // Check whether this is the main process or a window\r\n        if (isMain) {\r\n            this.ID = 0;\r\n\r\n            // Forward the call made by a window, and passing the sourceID to track the origin\r\n            ipcMain.on(\"IPC.forward\", (event, arg) => {\r\n                this.__send(\r\n                    arg.type,\r\n                    ExtendedJSON.decode(arg.data),\r\n                    arg.dest,\r\n                    arg.sourceID,\r\n                    arg.responseID\r\n                );\r\n            });\r\n\r\n            // Return any responses to the source process/window when recieved\r\n            ipcMain.on(\"IPC.forwardResponse\", (event, arg) => {\r\n                arg.responses = ExtendedJSON.decode(arg.responses); // __sendResponse expects non encodedData\r\n                this.__sendResponse(arg.sourceID, arg);\r\n            });\r\n\r\n            // Listen for synchonous IPC calls\r\n            ipcMain.on(\"IPC.syncCall\", (event, arg) => {\r\n                // Send the event synchrnously to all listeners, and retrieve their responses\r\n                const response = this.__sendSync(\r\n                    arg.type,\r\n                    ExtendedJSON.decode(arg.data),\r\n                    arg.sourceID\r\n                );\r\n\r\n                // Set their responses as the return datan\r\n                event.returnValue = ExtendedJSON.encode(response);\r\n            });\r\n        } else {\r\n            // Is a window thread\r\n            // this.ID gets set in windowHandler once finished loading\r\n\r\n            // Emit the IPC event to all listeners whenever it is recieved\r\n            ipcRenderer.on(\"IPC.recieve\", (event, arg) => {\r\n                // Emit the event when recieved\r\n                const getResponses = this.__emitEvent(arg.type, {\r\n                    sourceID: arg.sourceID,\r\n                    data: ExtendedJSON.decode(arg.data),\r\n                });\r\n\r\n                // Return responses\r\n                getResponses.then(responses => {\r\n                    this.__sendResponse(arg.sourceID, {\r\n                        responseID: arg.responseID,\r\n                        responseOriginCount: arg.responseOriginCount,\r\n                        responses: responses,\r\n                    });\r\n                });\r\n            });\r\n\r\n            // Call the response listener whenever the response returned\r\n            ipcRenderer.on(\"IPC.recieveResponse\", (event, arg) => {\r\n                this.__recieveResponse(\r\n                    arg.responseID,\r\n                    ExtendedJSON.decode(arg.responses),\r\n                    arg.responseOriginCount\r\n                );\r\n            });\r\n        }\r\n    }\r\n}\r\nIPC.__setup();\r\n"]}