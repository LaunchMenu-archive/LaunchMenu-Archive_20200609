{"version":3,"sources":["../../../src/core/communication/IPC.js"],"names":["IPC","send","type","data","dest","__send","sendSync","__sendSync","on","handler","listeners","index","indexOf","push","once","orHandler","event","off","call","splice","getID","ID","_getWindows","windows","_registerWindow","window","windowID","_deregisterWindow","__emitEvent","sync","responses","promises","forEach","listener","response","all","then","promiseResponses","concat","source","respID","undefined","promise","resolve","res","reject","responseListeners","responseOriginsReceived","encodedData","ExtendedJSON","encode","isMain","Array","i","length","id","Number","destCount","getResponses","sourceID","__sendResponse","responseID","responseOriginCount","webContents","forwardData","ipcRenderer","decode","responseData","__recieveResponse","rl","__setup","ipcMain","arg","returnValue"],"mappings":"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","file":"IPC.js","sourcesContent":["import {ipcMain, ipcRenderer} from \"electron\";\r\nimport isMain from \"../isMain\";\r\nimport ExtendedJSON from \"../communication/extendedJSON\";\r\n/**\r\n * A class that allows for communication between different processes and renderers\r\n */\r\nclass IPC{\r\n    /**\r\n     * Send data to another window or the main script\r\n     * @param  {String} type                        The event type to send (preferably prefixed with some class ID)\r\n     * @param  {Object} data                        The data to send\r\n     * @param  {String|[String, ...]} [dest=\"*\"]    The window ID(s) to send this data to\r\n     * @return {Promise} The promise that will get called with all the returned data from the listeners\r\n     */\r\n    static send(type, data, dest=\"*\"){\r\n        return this.__send(type, data, dest);\r\n    }\r\n    /**\r\n     * Send data synchronously to the main script\r\n     * @param  {String} type                        The event type to send (preferably prefixed with some class ID)\r\n     * @param  {Object} data                        The data to send\r\n     * @return {Promise} The promise that will get called with all the returned data from the listeners\r\n     */\r\n    static sendSync(type, data){\r\n        return this.__sendSync(type, data);\r\n    }\r\n    /**\r\n     * Listen for data being send by the main process or renderers\r\n     * @param  {String} type                The type of event to listen for\r\n     * @param  {Function(event)} handler    The function to handle the event occuring\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    static on(type, handler){\r\n        if(!this.listeners[type]) this.listeners[type] = [];\r\n        const listeners = this.listeners[type];\r\n        const index = listeners.indexOf(handler);\r\n        if(index==-1) listeners.push(handler);\r\n    }\r\n    /**\r\n     * Listen for data being send by the main process or renderers, but only listen for it once\r\n     * @param  {String} type                The type of event to listen for\r\n     * @param  {Function(event)} handler    The function to handle the event when occuring\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    static once(type, handler){\r\n        const orHandler = handler;\r\n        handler = event=>{\r\n            this.off(type, handler);\r\n            orHandler.call(this, event);\r\n        };\r\n        this.on(type, handler);\r\n    }\r\n    /**\r\n     * Stop listening for data being send by the main process or renderers\r\n     * @param  {String} type                The type of event that is being listened for\r\n     * @param  {Function(event)} handler    The function that handles the event when occuring\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    static off(type, handler){\r\n        const listeners = this.listeners[type];\r\n        if(listeners){\r\n            const index = listeners.indexOf(handler);\r\n            if(index!=-1) listeners.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the identifier of this process or renderer which other processes or renderers can use to communicate\r\n     * @return {Number} The numeric identifier\r\n     */\r\n    static getID(){\r\n        return this.ID;\r\n    }\r\n\r\n    // Protected methods\r\n    /**\r\n     * Get all the windows that are registered and can be communicated with (only works in the main process)\r\n     * @return {[BrowserWindow]} The actual windows\r\n     */\r\n    static _getWindows(){\r\n        return this.windows;\r\n    }\r\n    /**\r\n     * Register a window such that it can start communicating with other processes and windows\r\n     * @param  {BrowserWindow} window The window to register\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    static _registerWindow(window, windowID){\r\n        this.windows[windowID] = window;\r\n    }\r\n    /**\r\n     * Deregister a window for when it is destroyed, such that it is no longer listed as a valid window\r\n     * @param  {windowID} windowID The ID of the window to deregister\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    static _deregisterWindow(windowID){\r\n        delete this.windows[windowID];\r\n    }\r\n\r\n    // Private methods\r\n    /**\r\n     * Emit an event to all the registered listeners\r\n     * @param  {String} type  The event type to invoke\r\n     * @param  {Object} event The event data to pass to the listeners\r\n     * @param  {Boolean} sync Whether to act synchronously and only allow sync returns\r\n     * @return {Promise} The method returns a promise that will resolve in all the returned values from listeners\r\n     */\r\n    static __emitEvent(type, event, sync){\r\n        const listeners = this.listeners[type];\r\n        const responses = [];\r\n        const promises = [];\r\n\r\n        // Emit the event itself\r\n        if(listeners)\r\n            listeners.forEach(listener=>{\r\n                const response = listener.call(this, event);\r\n                if(response instanceof Promise){\r\n                    promises.push(response);\r\n                }else{\r\n                    responses.push(response);\r\n                }\r\n            });\r\n\r\n        // Return the responses of the event\r\n        if(sync) return responses\r\n\r\n        return Promise.all(promises).then(promiseResponses=>{\r\n            return responses.concat(promiseResponses);\r\n        });\r\n    }\r\n    /**\r\n     * Send data to another window or the main script\r\n     * @param  {String} type                        The event type to send (preferbly prefixed with some module ID)\r\n     * @param  {Object} data                        The data to send\r\n     * @param  {String|[String, ...]} [dest=\"*\"]    The window ID(s) to send this data to\r\n     * @param  {Number} source                      The process/renderer ID that the event was originally sent from\r\n     * @param  {Number} respID                      The ID of the response listener in the source process/renderer to call\r\n     * @return {Promise} The promise that will get called with all the returned data from the listeners\r\n     */\r\n    static __send(type, data, dest=\"*\", source=0, respID=undefined){\r\n        // Only create a promise if this is not a forwarded event\r\n        let promise;\r\n        if(respID==undefined){\r\n            // Create a promise that can be used to return a response\r\n            let resolve;\r\n            promise = new Promise((res, reject)=>{\r\n                resolve = res;\r\n            });\r\n            // Register the response listener\r\n            respID = this.responseListeners.ID++;\r\n            this.responseListeners[respID] = {\r\n                resolve,                        // The resolve function to call when finished\r\n                responseOriginsReceived: 0,     // The number of processes/renderers that have returned responses\r\n                responses: []                   // The responses that have been recieved so far\r\n            };\r\n        }\r\n\r\n        // Send the data\r\n        const encodedData = ExtendedJSON.encode(data);\r\n        if(isMain){ // If the call is made from the main process\r\n            // Send the data to the appropriate windows\r\n            const windows = this._getWindows();\r\n\r\n            // Format the destination\r\n            if(dest==\"*\"){\r\n                // If we want to target all windows (and the main thread), create a list of all destinations\r\n                dest = Object.keys(windows);\r\n            }else if(!(dest instanceof Array)){\r\n                // If only a single destination is provided, still make sure it is an array\r\n                dest = [dest];\r\n            }else{\r\n                // Remove all invalid window ids\r\n                for(let i=dest.length-1; i>=0; i--){\r\n                    let id = dest[i];\r\n                    if(!windows[Number(id)])\r\n                        dest.splice(i, 1);\r\n                }\r\n            }\r\n\r\n            // Go through all destionations and send the data\r\n            const destCount = dest.length;\r\n            dest.forEach(id=>{\r\n                if(id==0){ // Target the main process\r\n                    // Emit the event if the main process is a destination of the event\r\n                    const getResponses = this.__emitEvent(type, {\r\n                        sourceID: source,\r\n                        data: data\r\n                    });\r\n\r\n                    // Return responses\r\n                    getResponses.then(responses => {\r\n                        this.__sendResponse(source, {\r\n                            responseID: respID,\r\n                            responseOriginCount: destCount,\r\n                            responses: responses\r\n                        });\r\n                    });\r\n                }else{ // Target a window\r\n                    const window = windows[Number(id)];\r\n                    if(window){\r\n                        window.webContents.send(\"IPC.recieve\", {\r\n                            type: type,\r\n                            sourceID: source,\r\n                            data: encodedData,\r\n                            responseID: respID,\r\n                            responseOriginCount: destCount\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n        }else{\r\n            // Send the data to the main process such that it can spread it to the appropriate windows\r\n            const forwardData = {dest:dest, type:type, sourceID:this.ID, responseID:respID, data:encodedData};\r\n            ipcRenderer.send(\"IPC.forward\", forwardData);\r\n        }\r\n\r\n        // Return the response promise\r\n        return promise;\r\n    }\r\n    /**\r\n     * Send data synchronously to the main script\r\n     * @param  {String} type                        The event type to send (preferably prefixed with some class ID)\r\n     * @param  {Object} data                        The data to send\r\n     * @param  {Number} source                      The process/renderer ID that the event was originally sent from\r\n     * @return {Promise} The promise that will get called with all the returned data from the listeners\r\n     */\r\n    static __sendSync(type, data, sourceID){\r\n        if(isMain){ // If the call is made from the main process\r\n            return this.__emitEvent(type, {\r\n                sourceID: sourceID,\r\n                data: data\r\n            }, true);\r\n        }else{\r\n            // Send event to the main process and return the data\r\n            const response = ipcRenderer.sendSync(\"IPC.syncCall\", {type:type, data:ExtendedJSON.encode(data)});\r\n            return ExtendedJSON.decode(response);\r\n        }\r\n    }\r\n    /**\r\n     * Send a response to the source window that emitted the event\r\n     * @param  {Number} sourceID                         The ID of the event source process/renderer\r\n     * @param  {NUmber} responseData.responseID          The ID of the response in said process/renderer\r\n     * @param  {Array}  responseData.responses           The actual array of returned responses\r\n     * @param  {Number} responseData.responseOriginCount The number of processes/renderers that need to return responses\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    static __sendResponse(sourceID, responseData){\r\n        // Check whether this is the main process or a renderer\r\n        if(isMain){\r\n            // If this is the main process, and the event was sent by the main process, process the data\r\n            if(sourceID==0){\r\n                this.__recieveResponse(responseData.responseID, responseData.responses, responseData.responseOriginCount);\r\n\r\n            // If this is the main process and the data was meant for a renderer, forward the data\r\n            }else{\r\n                const window = this.windows[Number(sourceID)];\r\n                if(window){\r\n                    window.webContents.send(\"IPC.recieveResponse\", {\r\n                        responseID: responseData.responseID,\r\n                        responseOriginCount: responseData.responseOriginCount,\r\n                        responses: ExtendedJSON.encode(responseData.responses)\r\n                    });\r\n                }\r\n            }\r\n        }else{\r\n            // If this is a renderer, pass the response back to the main process\r\n            ipcRenderer.send(\"IPC.forwardResponse\", {\r\n                sourceID: sourceID,\r\n                responseID: responseData.responseID,\r\n                responseOriginCount: responseData.responseOriginCount,\r\n                responses: ExtendedJSON.encode(responseData.responses)\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Recieve a response from some process/renderer, and resolve promise when all are recieved\r\n     * @param  {Number} responseID          The ID of the response identifier\r\n     * @param  {Array}  responses           The actual array of returned responses\r\n     * @param  {Number} responseOriginCount The number of processes/renderers that need to return responses\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    static __recieveResponse(responseID, responses, responseOriginCount){\r\n        // Find the attached response listener from the ID\r\n        const rl = this.responseListeners[responseID];\r\n        if(rl){\r\n            // Combine the new responses with the already recieved responses\r\n            rl.responses = rl.responses.concat(responses);\r\n\r\n            // Increase the response count, and if it matches the required response count, resolve the promise\r\n            if(++rl.responseOriginsReceived==responseOriginCount){\r\n                // Delete the listener, and resolve the promise\r\n                delete this.responseListeners[responseID];\r\n                rl.resolve(rl.responses);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * The initial setup method to be called by this file itself, initialises the static fields of the class\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    static __setup(){\r\n        this.windows = {0:this};         // The available windows to forward the events to\r\n        this.listeners = {};             // The event listeners in this process/renderer\r\n        this.responseListeners = {ID:0}; // The response listeners in this process/renderer\r\n\r\n        // Check whether this is the main process or a renderer\r\n        if(isMain){\r\n            this.ID = 0;\r\n\r\n            // Forward the call made by a renderer, and passing the sourceID to track the origin\r\n            ipcMain.on(\"IPC.forward\", (event, arg)=>{\r\n                this.__send(arg.type, ExtendedJSON.decode(arg.data), arg.dest, arg.sourceID, arg.responseID);\r\n            });\r\n\r\n            // Return any responses to the source process/renderer when recieved\r\n            ipcMain.on(\"IPC.forwardResponse\", (event, arg)=>{\r\n                arg.responses = ExtendedJSON.decode(arg.responses); // __sendResponse expects non encodedData\r\n                this.__sendResponse(arg.sourceID, arg);\r\n            });\r\n\r\n            // Listen for synchonous IPC calls\r\n            ipcMain.on(\"IPC.syncCall\", (event, arg)=>{\r\n                const response = this.__sendSync(arg.type, ExtendedJSON.decode(arg.data), arg.sourceID);\r\n                event.returnValue = ExtendedJSON.encode(response);\r\n            });\r\n        }else{  // Is a renderer thread\r\n            // this.ID gets set in windowHandler once finished loading\r\n\r\n            // Emit the IPC event to all listeners whenever it is recieved\r\n            ipcRenderer.on(\"IPC.recieve\", (event, arg)=>{\r\n                // Emit the event when recieved\r\n                const getResponses = this.__emitEvent(arg.type, {\r\n                    sourceID: arg.sourceID,\r\n                    data: ExtendedJSON.decode(arg.data)\r\n                });\r\n\r\n                // Return responses\r\n                getResponses.then(responses=>{\r\n                    this.__sendResponse(arg.sourceID, {\r\n                        responseID: arg.responseID,\r\n                        responseOriginCount: arg.responseOriginCount,\r\n                        responses: responses\r\n                    });\r\n                });\r\n            });\r\n\r\n            // Call the response listener whenever the response returned\r\n            ipcRenderer.on(\"IPC.recieveResponse\", (event, arg)=>{\r\n                this.__recieveResponse(arg.responseID, ExtendedJSON.decode(arg.responses), arg.responseOriginCount);\r\n            });\r\n        }\r\n    }\r\n}\r\nIPC.__setup();\r\nexport default IPC;\r\n"]}