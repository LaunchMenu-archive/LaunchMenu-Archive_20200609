{"version":3,"sources":["../../../src/core/communication/IPC.js"],"names":["IPC","send","type","data","dest","__send","sendSync","__sendSync","on","handler","listeners","index","indexOf","push","once","orHandler","event","off","call","splice","getID","ID","_getWindows","windows","_registerWindow","window","id","_deregisterWindow","__emitEvent","responses","forEach","listener","response","source","respID","undefined","promise","resolve","res","reject","responseListeners","responseOriginsReceived","encodedData","ExtendedJSON","encode","isMain","i","Array","length","Number","destCount","sourceID","__sendResponse","responseID","responseOriginCount","webContents","forwardData","ipcRenderer","decode","responseData","__recieveResponse","rl","concat","__setup","ipcMain","arg","returnValue","require","remote","getCurrentWindow"],"mappings":"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","file":"IPC.js","sourcesContent":["import {ipcMain, ipcRenderer} from \"electron\";\r\nimport isMain from \"../isMain\";\r\nimport ExtendedJSON from \"../communication/extendedJSON\";\r\n/**\r\n * A class that allows for communication between different processes and renderers\r\n */\r\nclass IPC{\r\n    /**\r\n     * Send data to another window or the main script\r\n     * @param  {String} type                        The event type to send (preferably prefixed with some class ID)\r\n     * @param  {Object} data                        The data to send\r\n     * @param  {String|[String, ...]} [dest=\"*\"]    The window ID(s) to send this data to\r\n     * @return {Promise} The promise that will get called with all the returned data from the listeners\r\n     */\r\n    static send(type, data, dest=\"*\"){\r\n        return this.__send(type, data, dest);\r\n    }\r\n    /**\r\n     * Send data synchronously to the main script\r\n     * @param  {String} type                        The event type to send (preferably prefixed with some class ID)\r\n     * @param  {Object} data                        The data to send\r\n     * @return {Promise} The promise that will get called with all the returned data from the listeners\r\n     */\r\n    static sendSync(type, data){\r\n        return this.__sendSync(type, data);\r\n    }\r\n    /**\r\n     * Listen for data being send by the main process or renderers\r\n     * @param  {String} type                The type of event to listen for\r\n     * @param  {Function(event)} handler    The function to handle the event occuring\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    static on(type, handler){\r\n        if(!this.listeners[type]) this.listeners[type] = [];\r\n        const listeners = this.listeners[type];\r\n        const index = listeners.indexOf(handler);\r\n        if(index==-1) listeners.push(handler);\r\n    }\r\n    /**\r\n     * Listen for data being send by the main process or renderers, but only listen for it once\r\n     * @param  {String} type                The type of event to listen for\r\n     * @param  {Function(event)} handler    The function to handle the event when occuring\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    static once(type, handler){\r\n        const orHandler = handler;\r\n        handler = event=>{\r\n            this.off(type, handler);\r\n            orHandler.call(this, event);\r\n        };\r\n        this.on(type, handler);\r\n    }\r\n    /**\r\n     * Stop listening for data being send by the main process or renderers\r\n     * @param  {String} type                The type of event that is being listened for\r\n     * @param  {Function(event)} handler    The function that handles the event when occuring\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    static off(type, handler){\r\n        const listeners = this.listeners[type];\r\n        if(listeners){\r\n            const index = listeners.indexOf(handler);\r\n            if(index!=-1) listeners.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the identifier of this process or renderer which other processes or renderers can use to communicate\r\n     * @return {Number} The numeric identifier\r\n     */\r\n    static getID(){\r\n        return this.ID;\r\n    }\r\n\r\n    // Protected methods\r\n    /**\r\n     * Get all the windows that are registered and can be communicated with (only works in the main process)\r\n     * @return {[BrowserWindow]} The actual windows\r\n     */\r\n    static _getWindows(){\r\n        return this.windows;\r\n    }\r\n    /**\r\n     * Register a window such that it can start communicating with other processes and windows\r\n     * @param  {BrowserWindow} window The window to register\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    static _registerWindow(window){\r\n        this.windows[window.id] = window;\r\n    }\r\n    /**\r\n     * Deregister a window for when it is destroyed, such that it is no longer listed as a valid window\r\n     * @param  {BrowserWindow} window The window to deregister\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    static _deregisterWindow(window){\r\n        const index = this.windows.indexOf(window);\r\n        if(index!=-1) delete this.windows[index];\r\n    }\r\n\r\n    // Private methods\r\n    /**\r\n     * Emit an event to all the registered listeners\r\n     * @param  {String} type  The event type to invoke\r\n     * @param  {Object} event The event data to pass to the listeners\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    static __emitEvent(type, event){\r\n        const listeners = this.listeners[type];\r\n        const responses = [];\r\n\r\n        // Emit the event itself\r\n        if(listeners)\r\n            listeners.forEach(listener=>{\r\n                var response = listener.call(this, event);\r\n                responses.push(response);\r\n            });\r\n\r\n        // Return the responses of the event\r\n        return responses;\r\n    }\r\n    /**\r\n     * Send data to another window or the main script\r\n     * @param  {String} type                        The event type to send (preferbly prefixed with some module ID)\r\n     * @param  {Object} data                        The data to send\r\n     * @param  {String|[String, ...]} [dest=\"*\"]    The window ID(s) to send this data to\r\n     * @param  {Number} source                      The process/renderer ID that the event was originally sent from\r\n     * @param  {Number} respID                      The ID of the response listener in the source process/renderer to call\r\n     * @return {Promise} The promise that will get called with all the returned data from the listeners\r\n     */\r\n    static __send(type, data, dest=\"*\", source=0, respID=undefined){\r\n        // Only create a promise if this is not a forwarded event\r\n        let promise;\r\n        if(respID==undefined){\r\n            // Create a promise that can be used to return a response\r\n            let resolve;\r\n            promise = new Promise((res, reject)=>{\r\n                resolve = res;\r\n            });\r\n            // Register the response listener\r\n            respID = this.responseListeners.ID++;\r\n            this.responseListeners[respID] = {\r\n                resolve,                        // The resolve function to call when finished\r\n                responseOriginsReceived: 0,     // The number of processes/renderers that have returned responses\r\n                responses: []                   // The responses that have been recieved so far\r\n            };\r\n        }\r\n\r\n        // Send the data\r\n        const encodedData = ExtendedJSON.encode(data);\r\n        if(isMain){ // If the call is made from the main process\r\n            // Send the data to the appropriate windows\r\n            const windows = this._getWindows();\r\n\r\n            // Format the destination\r\n            if(dest==\"*\"){\r\n                // If we want to target all windows (and the main thread), create a list of all destinations\r\n                dest = [];\r\n                for(let i in windows)\r\n                dest.push(i);\r\n            }else if(!(dest instanceof Array)){\r\n                // If only a single destination is provided, still make sure it is an array\r\n                dest = [dest];\r\n            }else{\r\n                // Remove all invalid window ids\r\n                for(let i=dest.length-1; i>=0; i--){\r\n                    let id = dest[i];\r\n                    if(!this.windows[Number(id)])\r\n                    dest.splice(i, 1);\r\n                }\r\n            }\r\n\r\n            // Go through all destionations and send the data\r\n            const destCount = dest.length;\r\n            dest.forEach(id=>{\r\n                if(id==0){ // Target the main process\r\n                    // Emit the event if the main process is a destination of the event\r\n                    const responses = this.__emitEvent(type, {\r\n                        sourceID: source,\r\n                        data: data\r\n                    });\r\n\r\n                    // Return responses\r\n                    this.__sendResponse(source, {\r\n                        responseID: respID,\r\n                        responseOriginCount: destCount,\r\n                        responses: responses\r\n                    });\r\n\r\n                }else{ // Target a window\r\n                    const window = this.windows[Number(id)];\r\n                    if(window){\r\n                        window.webContents.send(\"IPC.recieve\", {\r\n                            type: type,\r\n                            sourceID: source,\r\n                            data: encodedData,\r\n                            responseID: respID,\r\n                            responseOriginCount: destCount\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n        }else{\r\n            // Send the data to the main process such that it can spread it to the appropriate windows\r\n            const forwardData = {dest:dest, type:type, sourceID:this.ID, responseID:respID, data:encodedData};\r\n            ipcRenderer.send(\"IPC.forward\", forwardData);\r\n        }\r\n\r\n        // Return the response promise\r\n        return promise;\r\n    }\r\n    /**\r\n     * Send data synchronously to the main script\r\n     * @param  {String} type                        The event type to send (preferably prefixed with some class ID)\r\n     * @param  {Object} data                        The data to send\r\n     * @param  {Number} source                      The process/renderer ID that the event was originally sent from\r\n     * @return {Promise} The promise that will get called with all the returned data from the listeners\r\n     */\r\n    static __sendSync(type, data, sourceID){\r\n        if(isMain){ // If the call is made from the main process\r\n            return this.__emitEvent(type, {\r\n                sourceID: sourceID,\r\n                data: data\r\n            });\r\n        }else{\r\n            // Send event to the main process and return the data\r\n            const response = ipcRenderer.sendSync(\"IPC.syncCall\", {type:type, data:ExtendedJSON.encode(data)});\r\n            return ExtendedJSON.decode(response);\r\n        }\r\n    }\r\n    /**\r\n     * Send a response to the source window that emitted the event\r\n     * @param  {Number} sourceID                         The ID of the event source process/renderer\r\n     * @param  {NUmber} responseData.responseID          The ID of the response in said process/renderer\r\n     * @param  {Array}  responseData.responses           The actual array of returned responses\r\n     * @param  {Number} responseData.responseOriginCount The number of processes/renderers that need to return responses\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    static __sendResponse(sourceID, responseData){\r\n        // Check whether this is the main process or a renderer\r\n        if(isMain){\r\n            // If this is the main process, and the event was sent by the main process, process the data\r\n            if(sourceID==0){\r\n                this.__recieveResponse(responseData.responseID, responseData.responses, responseData.responseOriginCount);\r\n\r\n            // If this is the main process and the data was meant for a renderer, forward the data\r\n            }else{\r\n                const window = this.windows[Number(sourceID)];\r\n                if(window){\r\n                    window.webContents.send(\"IPC.recieveResponse\", {\r\n                        responseID: responseData.responseID,\r\n                        responseOriginCount: responseData.responseOriginCount,\r\n                        responses: ExtendedJSON.encode(responseData.responses)\r\n                    });\r\n                }\r\n            }\r\n        }else{\r\n            // If this is a renderer, pass the response back to the main process\r\n            ipcRenderer.send(\"IPC.forwardResponse\", {\r\n                sourceID: sourceID,\r\n                responseID: responseData.responseID,\r\n                responseOriginCount: responseData.responseOriginCount,\r\n                responses: ExtendedJSON.encode(responseData.responses)\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Recieve a response from some process/renderer, and resolve promise when all are recieved\r\n     * @param  {Number} responseID          The ID of the response identifier\r\n     * @param  {Array}  responses           The actual array of returned responses\r\n     * @param  {Number} responseOriginCount The number of processes/renderers that need to return responses\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    static __recieveResponse(responseID, responses, responseOriginCount){\r\n        // Find the attached response listener from the ID\r\n        const rl = this.responseListeners[responseID];\r\n        if(rl){\r\n            // Combine the new responses with the already recieved responses\r\n            rl.responses = rl.responses.concat(responses);\r\n\r\n            // Increase the response count, and if it matches the required response count, resolve the promise\r\n            if(++rl.responseOriginsReceived==responseOriginCount){\r\n                // Delete the listener, and resolve the promise\r\n                delete this.responseListeners[responseID];\r\n                rl.resolve(rl.responses);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * The initial setup method to be called by this file itself, initialises the static fields of the class\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    static __setup(){\r\n        this.windows = [this];           // The available windows to forward the events to\r\n        this.listeners = {};             // The event listeners in this process/renderer\r\n        this.responseListeners = {ID:0}; // The response listeners in this process/renderer\r\n\r\n        // Check whether this is the main process or a renderer\r\n        if(isMain){\r\n            this.ID = 0;\r\n\r\n            // Forward the call made by a renderer, and passing the sourceID to track the origin\r\n            ipcMain.on(\"IPC.forward\", (event, arg)=>{\r\n                this.__send(arg.type, ExtendedJSON.decode(arg.data), arg.dest, arg.sourceID, arg.responseID);\r\n            });\r\n\r\n            // Return any responses to the source process/renderer when recieved\r\n            ipcMain.on(\"IPC.forwardResponse\", (event, arg)=>{\r\n                this.__sendResponse(arg.sourceID, arg);\r\n            });\r\n\r\n            // Listen for synchonous IPC calls\r\n            ipcMain.on(\"IPC.syncCall\", (event, arg)=>{\r\n                const response = this.__sendSync(arg.type, ExtendedJSON.decode(arg.data), arg.sourceID);\r\n                event.returnValue = ExtendedJSON.encode(response);\r\n            });\r\n        }else{  // Is a renderer thread\r\n            this.ID = require('electron').remote.getCurrentWindow().id; // (Starts from 1)\r\n\r\n            // Emit the event to all listeners whenever it is recieved\r\n            ipcRenderer.on(\"IPC.recieve\", (event, arg)=>{\r\n                // Emit the event when recieved\r\n                const responses = this.__emitEvent(arg.type, {\r\n                    sourceID: arg.sourceID,\r\n                    data: ExtendedJSON.decode(arg.data)\r\n                });\r\n\r\n                // Return responses\r\n                this.__sendResponse(arg.sourceID, {\r\n                    responseID: arg.responseID,\r\n                    responseOriginCount: arg.responseOriginCount,\r\n                    responses: responses\r\n                });\r\n            });\r\n\r\n            // Call the response listener whenever the response returned\r\n            ipcRenderer.on(\"IPC.recieveResponse\", (event, arg)=>{\r\n                this.__recieveResponse(arg.responseID, ExtendedJSON.decode(arg.responses), arg.responseOriginCount);\r\n            });\r\n        }\r\n    }\r\n}\r\nIPC.__setup();\r\nexport default IPC;\r\n"]}