{"version":3,"sources":["../../../src/core/communication/IPC.js"],"names":["IPC","send","type","data","dest","__send","sendSync","__sendSync","on","handler","listeners","index","indexOf","push","once","orHandler","event","off","call","splice","getID","ID","_getWindows","windows","_registerWindow","window","windowID","_deregisterWindow","__emitEvent","sync","responses","promises","forEach","listener","response","all","then","promiseResponses","concat","source","respID","undefined","promise","resolve","res","reject","responseListeners","responseOriginsReceived","encodedData","ExtendedJSON","encode","isMain","Array","i","length","id","Number","destCount","getResponses","sourceID","__sendResponse","responseID","responseOriginCount","webContents","forwardData","ipcRenderer","decode","responseData","__recieveResponse","rl","__setup","ipcMain","arg","returnValue"],"mappings":"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","file":"IPC.js","sourcesContent":["import {ipcMain, ipcRenderer} from \"electron\";\r\nimport isMain from \"../isMain\";\r\nimport ExtendedJSON from \"../communication/extendedJSON\";\r\n\r\n/**\r\n * @typedef {object} IPC~IPCevent\r\n * @property {number} sourceID - The ID of the process/window that original sent the event\r\n * @property {*} data - The data that was sent with the event\r\n */\r\n\r\n/**\r\n * @classdesc A static class that allows for communication between different processes and windows\r\n * @class\r\n * @hideconstructor\r\n */\r\nexport default class IPC {\r\n    /**\r\n     * Send data to another window or the main script\r\n     * @param  {string} type - The event type to send (preferably prefixed with some class ID)\r\n     * @param  {Object} data - The data to send\r\n     * @param  {(string|string[])} [dest=\"*\"] - The process/window ID(s) to send this data to\r\n     * @returns {Promise<Object[]>} An array of all the data that listeners for the event have returned\r\n     * @async\r\n     * @public\r\n     */\r\n    static send(type, data, dest = \"*\") {\r\n        return this.__send(type, data, dest);\r\n    }\r\n\r\n    /**\r\n     * Send data synchronously to the main script\r\n     * @param  {string} type - The event type to send (preferably prefixed with some class ID)\r\n     * @param  {*} data - The data to send\r\n     * @returns {Object[]} An array of all the data that listeners for the event have returned\r\n     * @public\r\n     */\r\n    static sendSync(type, data) {\r\n        return this.__sendSync(type, data);\r\n    }\r\n\r\n    // TODO: add proper handler definition once VScode fixes @callback\r\n    /**\r\n     * Listens for data being sent by a process/window\r\n     * @param  {string} type - The type of event to listen for\r\n     * @param  {function} handler - The function to handle the event occuring\r\n     * @returns {undefined}\r\n     * @public\r\n     */\r\n    static on(type, handler) {\r\n        if (!this.listeners[type]) this.listeners[type] = [];\r\n        const listeners = this.listeners[type];\r\n        const index = listeners.indexOf(handler);\r\n        if (index == -1) listeners.push(handler);\r\n    }\r\n\r\n    /**\r\n     * Listens for data being sent by a process/window, but only listen for it once\r\n     * @param  {string} type - The type of event to listen for\r\n     * @param  {function} handler - The function to handle the event occuring\r\n     * @returns {undefined}\r\n     * @public\r\n     */\r\n    static once(type, handler) {\r\n        const orHandler = handler;\r\n        handler = event => {\r\n            this.off(type, handler);\r\n            orHandler.call(this, event);\r\n        };\r\n        this.on(type, handler);\r\n    }\r\n\r\n    /**\r\n     * Stops listening for data being sent by a process/window\r\n     * @param  {String} type - The type of event that is being listened for\r\n     * @param  {Function(event)} - The function that handles the event when occuring\r\n     * @return {undefined}\r\n     * @public\r\n     */\r\n    static off(type, handler) {\r\n        const listeners = this.listeners[type];\r\n        if (listeners) {\r\n            const index = listeners.indexOf(handler);\r\n            if (index != -1) listeners.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the identifier of this process or renderer which other processes or renderers can use to communicate\r\n     * @return {number} The numeric identifier\r\n     * @public\r\n     */\r\n    static getID() {\r\n        return this.ID;\r\n    }\r\n\r\n    /**\r\n     * Get all the windows that are registered and can be communicated with (only works in the main process)\r\n     * @return {BrowserWindow[]} The actual windows\r\n     * @protected\r\n     */\r\n    static _getWindows() {\r\n        return this.windows;\r\n    }\r\n\r\n    /**\r\n     * Register a window such that it can start communicating with other processes and windows\r\n     * @param  {BrowserWindow} window - The window to register\r\n     * @param  {number} windowID - The ID to register the window under\r\n     * @return {undefined}\r\n     * @protected\r\n     */\r\n    static _registerWindow(window, windowID) {\r\n        this.windows[windowID] = window;\r\n    }\r\n\r\n    /**\r\n     * Deregister a window for when it is destroyed, such that it is no longer listed as a valid window\r\n     * @param  {number} windowID - The ID the window is registered under\r\n     * @return {undefined}\r\n     * @protected\r\n     */\r\n    static _deregisterWindow(windowID) {\r\n        delete this.windows[windowID];\r\n    }\r\n\r\n    /**\r\n     * Emit an event to all the registered listeners in this process/window\r\n     * @param  {string} type  - The event type to invoke\r\n     * @param  {IPC~IPCevent} event - The event data to pass to the listeners\r\n     * @param  {boolean} sync - Whether to act synchronously and only allow sync returns\r\n     * @return {Promise<Object[]>} An array of all the data that listeners for the event have returned\r\n     * @async\r\n     * @private\r\n     */\r\n    static __emitEvent(type, event, sync) {\r\n        const listeners = this.listeners[type];\r\n        const responses = [];\r\n        const promises = [];\r\n\r\n        // Emit the event itself\r\n        if (listeners)\r\n            listeners.forEach(listener => {\r\n                const response = listener.call(this, event);\r\n                if (response instanceof Promise) {\r\n                    promises.push(response);\r\n                } else {\r\n                    responses.push(response);\r\n                }\r\n            });\r\n\r\n        // Return the responses of the event\r\n        if (sync) return responses;\r\n\r\n        return Promise.all(promises).then(promiseResponses => {\r\n            return responses.concat(promiseResponses);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Send data to other processes/windows\r\n     * @param  {string} type - The event type to send (preferbly prefixed with some module ID)\r\n     * @param  {*} data - The data to send\r\n     * @param  {(string|string[])} [dest=\"*\"] - The process/window ID(s) to send this data to\r\n     * @param  {number} source - The process/window ID that the event was originally sent from\r\n     * @param  {number} respID - The ID of the response listener in the source process/window to call\r\n     * @return {Promise<Object[]>} An array of all the data that listeners for the event have returned\r\n     * @async\r\n     * @private\r\n     */\r\n    static __send(type, data, dest = \"*\", source = 0, respID = undefined) {\r\n        // Only create a promise if this is not a forwarded event\r\n        let promise;\r\n        if (respID == undefined) {\r\n            // Create a promise that can be used to return a response\r\n            let resolve;\r\n            promise = new Promise((res, reject) => {\r\n                resolve = res;\r\n            });\r\n            // Register the response listener\r\n            respID = this.responseListeners.ID++;\r\n            this.responseListeners[respID] = {\r\n                resolve, // The resolve function to call when finished\r\n                responseOriginsReceived: 0, // The number of processes/renderers that have returned responses\r\n                responses: [], // The responses that have been recieved so far\r\n            };\r\n        }\r\n\r\n        // Send the data\r\n        const encodedData = ExtendedJSON.encode(data);\r\n        if (isMain) {\r\n            // If the call is made from the main process\r\n            // Send the data to the appropriate windows\r\n            const windows = this._getWindows();\r\n\r\n            // Format the destination\r\n            if (dest == \"*\") {\r\n                // If we want to target all windows (and the main thread), create a list of all destinations\r\n                dest = Object.keys(windows);\r\n            } else if (!(dest instanceof Array)) {\r\n                // If only a single destination is provided, still make sure it is an array\r\n                dest = [dest];\r\n            } else {\r\n                // Remove all invalid window ids\r\n                for (let i = dest.length - 1; i >= 0; i--) {\r\n                    let id = dest[i];\r\n                    if (!windows[Number(id)]) dest.splice(i, 1);\r\n                }\r\n            }\r\n\r\n            // Go through all destionations and send the data\r\n            const destCount = dest.length;\r\n            dest.forEach(id => {\r\n                if (id == 0) {\r\n                    // Target the main process\r\n                    // Emit the event if the main process is a destination of the event\r\n                    const getResponses = this.__emitEvent(type, {\r\n                        sourceID: source,\r\n                        data: data,\r\n                    });\r\n\r\n                    // Return responses\r\n                    getResponses.then(responses => {\r\n                        this.__sendResponse(source, {\r\n                            responseID: respID,\r\n                            responseOriginCount: destCount,\r\n                            responses: responses,\r\n                        });\r\n                    });\r\n                } else {\r\n                    // Target a window\r\n                    const window = windows[Number(id)];\r\n                    if (window) {\r\n                        window.webContents.send(\"IPC.recieve\", {\r\n                            type: type,\r\n                            sourceID: source,\r\n                            data: encodedData,\r\n                            responseID: respID,\r\n                            responseOriginCount: destCount,\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n        } else {\r\n            // Send the data to the main process such that it can spread it to the appropriate windows\r\n            const forwardData = {\r\n                dest: dest,\r\n                type: type,\r\n                sourceID: this.ID,\r\n                responseID: respID,\r\n                data: encodedData,\r\n            };\r\n            ipcRenderer.send(\"IPC.forward\", forwardData);\r\n        }\r\n\r\n        // Return the response promise\r\n        return promise;\r\n    }\r\n\r\n    /**\r\n     * Send data synchronously to the main script\r\n     * @param  {string} type - The event type to send (preferably prefixed with some class ID)\r\n     * @param  {*} data - The data to send\r\n     * @param  {number} source - The process/window ID that the event was originally sent from\r\n     * @return {Object[]} An array of all the data that listeners for the event have returned\r\n     * @private\r\n     */\r\n    static __sendSync(type, data, sourceID) {\r\n        if (isMain) {\r\n            // If the call is made from the main process\r\n            return this.__emitEvent(\r\n                type,\r\n                {\r\n                    sourceID: sourceID,\r\n                    data: data,\r\n                },\r\n                true\r\n            );\r\n        } else {\r\n            // Send event to the main process and return the data\r\n            const response = ipcRenderer.sendSync(\"IPC.syncCall\", {\r\n                type: type,\r\n                data: ExtendedJSON.encode(data),\r\n            });\r\n            return ExtendedJSON.decode(response);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send a response to the source window that emitted the event\r\n     * @param  {string} sourceID - The ID of the event source process/window\r\n     * @param  {object} responseData - The response data\r\n     * @param  {number} responseData.responseID - The ID of the response in said process/window\r\n     * @param  {Object[]}  responseData.responses - The actual array of returned responses\r\n     * @param  {number} responseData.responseOriginCount - The number of processes/windows that need to return responses\r\n     * @return {undefined}\r\n     * @private\r\n     */\r\n    static __sendResponse(sourceID, responseData) {\r\n        // Check whether this is the main process or a renderer\r\n        if (isMain) {\r\n            // If this is the main process, and the event was sent by the main process, process the data\r\n            if (sourceID == 0) {\r\n                this.__recieveResponse(\r\n                    responseData.responseID,\r\n                    responseData.responses,\r\n                    responseData.responseOriginCount\r\n                );\r\n\r\n                // If this is the main process and the data was meant for a renderer, forward the data\r\n            } else {\r\n                const window = this.windows[Number(sourceID)];\r\n                if (window) {\r\n                    window.webContents.send(\"IPC.recieveResponse\", {\r\n                        responseID: responseData.responseID,\r\n                        responseOriginCount: responseData.responseOriginCount,\r\n                        responses: ExtendedJSON.encode(responseData.responses),\r\n                    });\r\n                }\r\n            }\r\n        } else {\r\n            // If this is a renderer, pass the response back to the main process\r\n            ipcRenderer.send(\"IPC.forwardResponse\", {\r\n                sourceID: sourceID,\r\n                responseID: responseData.responseID,\r\n                responseOriginCount: responseData.responseOriginCount,\r\n                responses: ExtendedJSON.encode(responseData.responses),\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Recieve a response from some process/renderer, and resolve promise when all are recieved\r\n     * @param  {number} responseID - The ID of the response identifier\r\n     * @param  {Object[]}  responses - The actual array of returned responses\r\n     * @param  {number} responseOriginCount - The number of processes/renderers that need to return responses\r\n     * @return {undefined}\r\n     * @private\r\n     */\r\n    static __recieveResponse(responseID, responses, responseOriginCount) {\r\n        // Find the attached response listener from the ID\r\n        const rl = this.responseListeners[responseID];\r\n        if (rl) {\r\n            // Combine the new responses with the already recieved responses\r\n            rl.responses = rl.responses.concat(responses);\r\n\r\n            // Increase the response count, and if it matches the required response count, resolve the promise\r\n            if (++rl.responseOriginsReceived == responseOriginCount) {\r\n                // Delete the listener, and resolve the promise\r\n                delete this.responseListeners[responseID];\r\n                rl.resolve(rl.responses);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The initial setup method to be called by this file itself, initialises the static fields of the class\r\n     * @return {undefined}\r\n     * @private\r\n     */\r\n    static __setup() {\r\n        this.windows = {0: this}; // The available windows to forward the events to\r\n        this.listeners = {}; // The event listeners in this process/renderer\r\n        this.responseListeners = {ID: 0}; // The response listeners in this process/renderer\r\n\r\n        // Check whether this is the main process or a renderer\r\n        if (isMain) {\r\n            this.ID = 0;\r\n\r\n            // Forward the call made by a renderer, and passing the sourceID to track the origin\r\n            ipcMain.on(\"IPC.forward\", (event, arg) => {\r\n                this.__send(\r\n                    arg.type,\r\n                    ExtendedJSON.decode(arg.data),\r\n                    arg.dest,\r\n                    arg.sourceID,\r\n                    arg.responseID\r\n                );\r\n            });\r\n\r\n            // Return any responses to the source process/renderer when recieved\r\n            ipcMain.on(\"IPC.forwardResponse\", (event, arg) => {\r\n                arg.responses = ExtendedJSON.decode(arg.responses); // __sendResponse expects non encodedData\r\n                this.__sendResponse(arg.sourceID, arg);\r\n            });\r\n\r\n            // Listen for synchonous IPC calls\r\n            ipcMain.on(\"IPC.syncCall\", (event, arg) => {\r\n                const response = this.__sendSync(\r\n                    arg.type,\r\n                    ExtendedJSON.decode(arg.data),\r\n                    arg.sourceID\r\n                );\r\n                event.returnValue = ExtendedJSON.encode(response);\r\n            });\r\n        } else {\r\n            // Is a renderer thread\r\n            // this.ID gets set in windowHandler once finished loading\r\n\r\n            // Emit the IPC event to all listeners whenever it is recieved\r\n            ipcRenderer.on(\"IPC.recieve\", (event, arg) => {\r\n                // Emit the event when recieved\r\n                const getResponses = this.__emitEvent(arg.type, {\r\n                    sourceID: arg.sourceID,\r\n                    data: ExtendedJSON.decode(arg.data),\r\n                });\r\n\r\n                // Return responses\r\n                getResponses.then(responses => {\r\n                    this.__sendResponse(arg.sourceID, {\r\n                        responseID: arg.responseID,\r\n                        responseOriginCount: arg.responseOriginCount,\r\n                        responses: responses,\r\n                    });\r\n                });\r\n            });\r\n\r\n            // Call the response listener whenever the response returned\r\n            ipcRenderer.on(\"IPC.recieveResponse\", (event, arg) => {\r\n                this.__recieveResponse(\r\n                    arg.responseID,\r\n                    ExtendedJSON.decode(arg.responses),\r\n                    arg.responseOriginCount\r\n                );\r\n            });\r\n        }\r\n    }\r\n}\r\nIPC.__setup();\r\n"]}