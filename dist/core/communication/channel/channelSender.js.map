{"version":3,"sources":["../../../../src/core/communication/channel/channelSender.js"],"names":["ChannelSender","constructor","ID","subChannelID","senderID","__data","module","Registry","_getModuleInstance","channelReceiver","core","__setupChannelMessageTypeListener","_setupMethods","types","initialised","resolve","IPC","send","reject","finishSetup","messageTypes","globalListeners","subChannelMessageTypes","subChannelListeners","concat","key","__sendMessage","arguments","_getID","_getSubChannelID","once","event","containsSubchannel","data","destProcessID","sourceID","message","args","response","_emitEvent","responses"],"mappings":"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","file":"channelSender.js","sourcesContent":["import IPC from \"../IPC\";\r\nimport Registry from \"../../registry/registry\";\r\n\r\nexport default class ChannelSender {\r\n    /**\r\n     * Create a new channel sender, allowing to send messages to the channel\r\n     * @param {string} ID - The unique identifier for the channel\r\n     * @param {string} subChannelID - The subChannelID that will be used to access special subchannel methods\r\n     * @param {string} senderID - An ID that the reciever of this channel can respond to (can be left out)\r\n     * @constructs ChannelSender\r\n     * @hideconstructor\r\n     */\r\n    constructor(ID, subChannelID, senderID) {\r\n        // Store data in a seperate object such that it isn't confused with channel methods\r\n        this.__data = {\r\n            ID: ID,\r\n            subChannelID: subChannelID,\r\n            senderID: senderID,\r\n        };\r\n\r\n        // Check if there is a module in the window with this channel ID\r\n        const module = Registry._getModuleInstance(ID);\r\n        if (module) {\r\n            // If there is a module, make direct connection for faster communication\r\n            this.__data.channelReceiver = module.core.channelReceiver;\r\n        }\r\n\r\n        // Listen for the available message types being send\r\n        this.__setupChannelMessageTypeListener();\r\n    }\r\n\r\n    /**\r\n     * Either requests methods to be set up according to the available message types,\r\n     * Or sets up the actual methods according to the passed data\r\n     * @param  {Object} [types] - The available message types to set\r\n     * @returns {undefined}\r\n     * @protected\r\n     * @async\r\n     */\r\n    _setupMethods(types) {\r\n        // Check if this call is initiating the setup, or actually setting up the data\r\n        if (!types) {\r\n            // The call is initiating the setup\r\n            // Check if the channel hasn't been set up already\r\n            if (this.__data.initialised) {\r\n                return new Promise.resolve(this);\r\n            } else {\r\n                // Broadcast a request for all message types of this channel\r\n                IPC.send(\"channel.requestMessageTypes:\" + this.__data.ID);\r\n\r\n                // Returned a promise that will be resolved once this method is called with the methods provided as an argument (will happen automatically)\r\n                return new Promise((resolve, reject) => {\r\n                    this.__data.finishSetup = resolve;\r\n                });\r\n            }\r\n        } else {\r\n            // Call is actually setting up the data\r\n            // Gather the relevant message types\r\n            let messageTypes = types.globalListeners;\r\n            const subChannelMessageTypes =\r\n                types.subChannelListeners[this.__data.subChannelID];\r\n            if (subChannelMessageTypes)\r\n                messageTypes = messageTypes.concat(subChannelMessageTypes);\r\n\r\n            // Setup the methods\r\n            for (let key of messageTypes)\r\n                this[key] = function() {\r\n                    return this.__sendMessage(key, Array.from(arguments));\r\n                };\r\n\r\n            // Notify that the channel is ready\r\n            this.__data.initialised = true;\r\n            if (this.__data.finishSetup) this.__data.finishSetup(this);\r\n        }\r\n    }\r\n    /**\r\n     * Get the channel ID\r\n     * @returns {string} The channel ID\r\n     * @protected\r\n     */\r\n    _getID() {\r\n        return this.__data.ID;\r\n    }\r\n    /**\r\n     * Get the subchannel ID\r\n     * @returns {string} The subchannel ID\r\n     * @protected\r\n     */\r\n    _getSubChannelID() {\r\n        return this.__data.subChannelID;\r\n    }\r\n\r\n    /**\r\n     * Starts listening for the channel receiver to send its available message types\r\n     * @returns {undefined}\r\n     * @private\r\n     */\r\n    __setupChannelMessageTypeListener() {\r\n        IPC.once(\"channel.sendMessageTypes:\" + this.__data.ID, event => {\r\n            // Check if all the subchannel methods have already been defined\r\n            const containsSubchannel =\r\n                !this.__data.subChannelID ||\r\n                event.data.subChannelListeners[this.__data.subChannelID];\r\n            if (containsSubchannel) {\r\n                // Store the location to send the messages to\r\n                this.__data.destProcessID = event.sourceID;\r\n\r\n                // Setup the methods of this object\r\n                this._setupMethods(event.data);\r\n            } else {\r\n                // Continue listening for message types if the subchannel hadn't been set up yet\r\n                this.__setupChannelMessageTypeListener();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Send a message to the channel receiver\r\n     * @param  {string} message - The message type\r\n     * @param  {Object[]} args - The data to send as an argument array\r\n     * @returns {undefined}\r\n     * @async\r\n     * @private\r\n     */\r\n    async __sendMessage(message, args) {\r\n        // Check whether to make an IPC call or direct message to a module\r\n        if (this.__data.channelReceiver) {\r\n            // Emit an event on the channel sender directly\r\n            let response = this.__data.channelReceiver._emitEvent(\r\n                message,\r\n                {\r\n                    senderID: this.__data.senderID,\r\n                    data: args,\r\n                },\r\n                this.__data.subChannelID\r\n            );\r\n\r\n            // Normalize the response to a promise\r\n            if (!(response instanceof Promise))\r\n                response = Promise.resolve(response);\r\n\r\n            // Return the result\r\n            return response;\r\n        } else {\r\n            // Send the message and relevant data to the process/window that contains the channel receiver\r\n            const responses = await IPC.send(\r\n                \"channel.message:\" + this.__data.ID,\r\n                {\r\n                    message: message,\r\n                    subChannelID: this.__data.subChannelID,\r\n                    senderID: this.__data.senderID,\r\n                    data: args,\r\n                },\r\n                this.__data.destProcessID\r\n            );\r\n\r\n            // We should only get a response from a single receiver, so return that\r\n            return responses[0];\r\n        }\r\n    }\r\n}\r\n"]}