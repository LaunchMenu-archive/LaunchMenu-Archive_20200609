{"version":3,"sources":["../../../../src/core/communication/channel/channelSender.js"],"names":["ChannelSender","constructor","ID","subChannelID","senderID","toString","getPath","__data","disabled","messageBuffer","__checkForReceiver","__setupChannelMessageTypeListener","__setupReceiverChangeListeners","module","Registry","_getModuleInstance","channelReceiver","core","_setupMethods","types","initialised","resolve","IPC","send","reject","finishSetup","messageTypes","globalListeners","subChannelMessageTypes","subChannelListeners","concat","key","__sendMessage","arguments","_getID","_getSubChannelID","_getChannelIdentifier","message","args","resolver","promise","push","response","_emitEvent","data","responses","destProcessID","__sendMessagesFromBuffer","forEach","item","result","once","event","containsSubchannel","sourceID","IPClisteners","processChange","receiverDisabled","on","dispose","off"],"mappings":"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","file":"channelSender.js","sourcesContent":["import IPC from \"../IPC\";\r\nimport Registry from \"../../registry/registry\";\r\n\r\nexport default class ChannelSender {\r\n    /**\r\n     * Create a new channel sender, allowing to send messages to the channel\r\n     * @param {(string|RequestPath)} ID - The unique identifier for the channel\r\n     * @param {string} subChannelID - The subChannelID that will be used to access special subchannel methods\r\n     * @param {(string|Module|RequestPath)} [senderID] - An ID that the reciever of this channel can respond to (can be left out)\r\n     * @constructs ChannelSender\r\n     * @hideconstructor\r\n     */\r\n    constructor(ID, subChannelID, senderID) {\r\n        // Normalize the ID\r\n        ID = ID.toString(true);\r\n\r\n        // Normalize the senderID\r\n        if (senderID) {\r\n            if (senderID.getPath) senderID = senderID.getPath();\r\n            senderID = senderID.toString(true);\r\n        }\r\n\r\n        // Store data in a seperate object such that it isn't confused with channel methods\r\n        this.__data = {\r\n            ID: ID,\r\n            subChannelID: subChannelID,\r\n            senderID: senderID,\r\n            disabled: false,\r\n            messageBuffer: [],\r\n        };\r\n\r\n        // Check if we can assign the receiver directly to improve efficiency\r\n        this.__checkForReceiver();\r\n\r\n        // Listen for the available message types being send\r\n        this.__setupChannelMessageTypeListener();\r\n\r\n        // Listen for state changes of the receiver\r\n        this.__setupReceiverChangeListeners();\r\n    }\r\n\r\n    /**\r\n     * Checks if there is a receiver for this channel in the window, and assigns it if there is\r\n     * @returns {undefined}\r\n     * @private\r\n     */\r\n    __checkForReceiver() {\r\n        // Check if there is a module in the window with this channel ID\r\n        const module = Registry._getModuleInstance(this.__data.ID);\r\n        if (module) {\r\n            // If there is a module, make direct connection for faster communication\r\n            this.__data.channelReceiver = module.core.channelReceiver;\r\n        } else {\r\n            // Otherwise delete any potentiually previously assigned receiver\r\n            delete this.__data.channelReceiver;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Either requests methods to be set up according to the available message types,\r\n     * Or sets up the actual methods according to the passed data\r\n     * @param  {Object} [types] - The available message types to set\r\n     * @returns {undefined}\r\n     * @protected\r\n     * @async\r\n     */\r\n    _setupMethods(types) {\r\n        // Check if this call is initiating the setup, or actually setting up the data\r\n        if (!types) {\r\n            // The call is initiating the setup\r\n            // Check if the channel hasn't been set up already\r\n            if (this.__data.initialised) {\r\n                return new Promise.resolve(this);\r\n            } else {\r\n                // Broadcast a request for all message types of this channel\r\n                IPC.send(\"channel.requestMessageTypes:\" + this.__data.ID);\r\n\r\n                // Returned a promise that will be resolved once this method is called with the methods provided as an argument (will happen automatically)\r\n                return new Promise((resolve, reject) => {\r\n                    this.__data.finishSetup = resolve;\r\n                });\r\n            }\r\n        } else {\r\n            // Call is actually setting up the data\r\n            // Gather the relevant message types\r\n            let messageTypes = types.globalListeners;\r\n            const subChannelMessageTypes =\r\n                types.subChannelListeners[this.__data.subChannelID];\r\n            if (subChannelMessageTypes)\r\n                messageTypes = messageTypes.concat(subChannelMessageTypes);\r\n\r\n            // Setup the methods\r\n            for (let key of messageTypes)\r\n                this[key] = function() {\r\n                    return this.__sendMessage(key, Array.from(arguments));\r\n                };\r\n\r\n            // Notify that the channel is ready\r\n            this.__data.initialised = true;\r\n            if (this.__data.finishSetup) this.__data.finishSetup(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the channel ID\r\n     * @returns {string} The channel ID\r\n     * @protected\r\n     */\r\n    _getID() {\r\n        return this.__data.ID;\r\n    }\r\n    /**\r\n     * Get the subchannel ID\r\n     * @returns {string} The subchannel ID\r\n     * @protected\r\n     */\r\n    _getSubChannelID() {\r\n        return this.__data.subChannelID;\r\n    }\r\n\r\n    /**\r\n     * Returns the identifier of the channelSender, including sub channel and senderID\r\n     * @returns {ChannelHander~ChannelIdentifier} The channel identifier\r\n     * @protected\r\n     */\r\n    _getChannelIdentifier() {\r\n        return {\r\n            ID: this.__data.ID,\r\n            subChannelID: this.__data.subChannelID,\r\n            senderID: this.__data.senderID,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Send a message to the channel receiver\r\n     * @param  {string} message - The message type\r\n     * @param  {Object[]} args - The data to send as an argument array\r\n     * @returns {undefined}\r\n     * @async\r\n     * @private\r\n     */\r\n    async __sendMessage(message, args) {\r\n        // Check if the receiver is not temprorarly disabled\r\n        if (this.__data.disabled) {\r\n            // Create a promise, and store the resolver\r\n            let resolver;\r\n            const promise = new Promise(resolve => {\r\n                resolver = resolve;\r\n            });\r\n\r\n            // Store the message and attach the resolver\r\n            this.__data.messageBuffer.push({\r\n                message: message,\r\n                args: args,\r\n                resolve: resolver,\r\n            });\r\n\r\n            // Return the promise\r\n            return promise;\r\n        }\r\n\r\n        // Check whether to make an IPC call or direct message to a module\r\n        if (this.__data.channelReceiver) {\r\n            // Emit an event on the channel sender directly\r\n            let response = this.__data.channelReceiver._emitEvent(\r\n                message,\r\n                {\r\n                    senderID: this.__data.senderID,\r\n                    data: args,\r\n                },\r\n                this.__data.subChannelID\r\n            );\r\n\r\n            // Normalize the response to a promise\r\n            if (!(response instanceof Promise))\r\n                response = Promise.resolve(response);\r\n\r\n            // Return the result\r\n            return response;\r\n        } else {\r\n            // Send the message and relevant data to the process/window that contains the channel receiver\r\n            const responses = await IPC.send(\r\n                \"channel.message:\" + this.__data.ID,\r\n                {\r\n                    message: message,\r\n                    subChannelID: this.__data.subChannelID,\r\n                    senderID: this.__data.senderID,\r\n                    data: args,\r\n                },\r\n                this.__data.destProcessID\r\n            );\r\n\r\n            // We should only get a response from a single receiver, so return that\r\n            return responses[0];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Empties the messageBuffer\r\n     * @returns {undefined}\r\n     * @private\r\n     */\r\n    __sendMessagesFromBuffer() {\r\n        // Get the message buffer\r\n        const messageBuffer = this.__data.messageBuffer;\r\n\r\n        // Clear the stored buffer\r\n        this.__data.messageBuffer = [];\r\n\r\n        // Go through all messages in the buffer and send them\r\n        messageBuffer.forEach(item => {\r\n            // Send the message and store the result\r\n            const result = this.__sendMessage(item.message, item.args);\r\n\r\n            // Resolve the promise using the result\r\n            item.resolve(result);\r\n        });\r\n    }\r\n\r\n    // IPC listener methods\r\n    /**\r\n     * Starts listening for the channel receiver to send its available message types\r\n     * @returns {undefined}\r\n     * @private\r\n     */\r\n    __setupChannelMessageTypeListener() {\r\n        IPC.once(\"channel.sendMessageTypes:\" + this.__data.ID, event => {\r\n            // Check if all the subchannel methods have already been defined\r\n            const containsSubchannel =\r\n                !this.__data.subChannelID ||\r\n                event.data.subChannelListeners[this.__data.subChannelID];\r\n            if (containsSubchannel) {\r\n                // Store the location to send the messages to\r\n                this.__data.destProcessID = event.sourceID;\r\n\r\n                // Setup the methods of this object\r\n                this._setupMethods(event.data);\r\n            } else {\r\n                // Continue listening for message types if the subchannel hadn't been set up yet\r\n                this.__setupChannelMessageTypeListener();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Starts listening for moving of the channel receiver\r\n     * @returns {undefined}\r\n     * @private\r\n     */\r\n    __setupReceiverChangeListeners() {\r\n        // Define and store the listeners\r\n        this.__data.IPClisteners = {\r\n            // Check when the receiver is moved to another process\r\n            processChange: event => {\r\n                // Get the process that the channel moved to\r\n                const ID = event.data;\r\n\r\n                // Set the new destionation process ID\r\n                this.__data.destProcessID = ID;\r\n\r\n                // Check if we can assign the receiver directly to improve efficiency\r\n                this.__checkForReceiver();\r\n            },\r\n\r\n            // Check for when the receiver temporarely can't receive messages\r\n            receiverDisabled: event => {\r\n                // Check whether we switched to enabled or disabled\r\n                const disabled = event.data;\r\n\r\n                // Store the new state\r\n                this.__data.disabled = disabled;\r\n\r\n                // If we switched to enabled again, send all messages\r\n                if (!disabled) {\r\n                    this.__sendMessagesFromBuffer();\r\n                }\r\n            },\r\n        };\r\n\r\n        // Set up the message listeners\r\n        IPC.on(\r\n            \"channel.sendProcessChange:\" + this.__data.ID,\r\n            this.__data.IPClisteners.processChange\r\n        );\r\n        IPC.on(\r\n            \"channel.sendDisabled:\" + this.__data.ID,\r\n            this.__data.IPClisteners.receiverDisabled\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Disposes of all data\r\n     * @returns {undefined}\r\n     * @public\r\n     */\r\n    dispose() {\r\n        // Clear the IPC listeners\r\n        IPC.off(\r\n            \"channel.sendProcessChange:\" + this.__data.ID,\r\n            this.__data.IPClisteners.processChange\r\n        );\r\n        IPC.off(\r\n            \"channel.sendDisabled:\" + this.__data.ID,\r\n            this.__data.IPClisteners.receiverDisabled\r\n        );\r\n    }\r\n}\r\n"]}