{"version":3,"sources":["../../../../src/core/communication/channel/channelSender.js"],"names":["ChannelSender","constructor","ID","subChannelID","senderID","__data","__setupChannelMessageTypeListener","_setupMethods","types","initialised","resolve","IPC","send","reject","finishSetup","messageTypes","globalListeners","subChannelMessageTypes","subChannelListeners","concat","key","__sendMessage","arguments","_getID","_getSubChannelID","once","event","containsSubchannel","data","destProcessID","sourceID","message","args"],"mappings":";;;;;;;;;;;;;;;;AAAA;;;;;;AAEe,MAAMA,aAAN,CAAoB;AAC/B;;;;;;;;AAQAC,gBAAYC,EAAZ,EAAgBC,YAAhB,EAA8BC,QAA9B,EAAwC;AACpC;AACA,aAAKC,MAAL,GAAc;AACVH,gBAAIA,EADM;AAEVC,0BAAcA,YAFJ;AAGVC,sBAAUA;AAHA,SAAd;;AAMA;AACA,aAAKE,iCAAL;AACH;;AAED;;;;;;;;AAQAC,kBAAcC,KAAd,EAAqB;AACjB;AACA,YAAI,CAACA,KAAL,EAAY;AACR;AACA;AACA,gBAAI,KAAKH,MAAL,CAAYI,WAAhB,EAA6B;AACzB,uBAAO,sBAAYC,OAAZ,CAAoB,IAApB,CAAP;AACH,aAFD,MAEO;AACH;AACAC,8BAAIC,IAAJ,CAAS,iCAAiC,KAAKP,MAAL,CAAYH,EAAtD;AACA,uBAAO,sBAAY,CAACQ,OAAD,EAAUG,MAAV,KAAqB;AACpC,yBAAKR,MAAL,CAAYS,WAAZ,GAA0BJ,OAA1B;AACH,iBAFM,CAAP;AAGH;AACJ,SAZD,MAYO;AACH;AACA;AACA,gBAAIK,eAAeP,MAAMQ,eAAzB;AACA,kBAAMC,yBACFT,MAAMU,mBAAN,CAA0B,KAAKb,MAAL,CAAYF,YAAtC,CADJ;AAEA,gBAAIc,sBAAJ,EACIF,eAAeA,aAAaI,MAAb,CAAoBF,sBAApB,CAAf;;AAEJ;AACA,iBAAK,IAAIG,GAAT,IAAgBL,YAAhB,EACI,KAAKK,GAAL,IAAY,YAAW;AACnB,uBAAO,KAAKC,aAAL,CAAmBD,GAAnB,EAAwB,oBAAWE,SAAX,CAAxB,CAAP;AACH,aAFD;;AAIJ;AACA,iBAAKjB,MAAL,CAAYI,WAAZ,GAA0B,IAA1B;AACA,gBAAI,KAAKJ,MAAL,CAAYS,WAAhB,EAA6B,KAAKT,MAAL,CAAYS,WAAZ,CAAwB,IAAxB;AAChC;AACJ;AACD;;;;;AAKAS,aAAS;AACL,eAAO,KAAKlB,MAAL,CAAYH,EAAnB;AACH;AACD;;;;;AAKAsB,uBAAmB;AACf,eAAO,KAAKnB,MAAL,CAAYF,YAAnB;AACH;;AAED;;;;;AAKAG,wCAAoC;AAChCK,sBAAIc,IAAJ,CAAS,8BAA8B,KAAKpB,MAAL,CAAYH,EAAnD,EAAuDwB,SAAS;AAC5D;AACA,kBAAMC,qBACF,CAAC,KAAKtB,MAAL,CAAYF,YAAb,IACAuB,MAAME,IAAN,CAAWV,mBAAX,CAA+B,KAAKb,MAAL,CAAYF,YAA3C,CAFJ;AAGA,gBAAIwB,kBAAJ,EAAwB;AACpB;AACA,qBAAKtB,MAAL,CAAYwB,aAAZ,GAA4BH,MAAMI,QAAlC;;AAEA;AACA,qBAAKvB,aAAL,CAAmBmB,MAAME,IAAzB;AACH,aAND,MAMO;AACH;AACA,qBAAKtB,iCAAL;AACH;AACJ,SAfD;AAgBH;AACD;;;;;;;AAOAe,kBAAcU,OAAd,EAAuBC,IAAvB,EAA6B;AACzB;AACA,eAAOrB,cAAIC,IAAJ,CACH,qBAAqB,KAAKP,MAAL,CAAYH,EAD9B,EAEH;AACI6B,qBAASA,OADb;AAEI5B,0BAAc,KAAKE,MAAL,CAAYF,YAF9B;AAGIC,sBAAU,KAAKC,MAAL,CAAYD,QAH1B;AAIIwB,kBAAMI;AAJV,SAFG,EAQH,KAAK3B,MAAL,CAAYwB,aART,CAAP;AAUH;AA1H8B;kBAAd7B,a","file":"channelSender.js","sourcesContent":["import IPC from \"../IPC\";\r\n\r\nexport default class ChannelSender {\r\n    /**\r\n     * Create a new channel sender, allowing to send messages to the channel\r\n     * @param {string} ID - The unique identifier for the channel\r\n     * @param {string} subChannelID - The subChannelID that will be used to access special subchannel methods\r\n     * @param {string} senderID - An ID that the reciever of this channel can respond to (can be left out)\r\n     * @constructs ChannelSender\r\n     * @hideconstructor\r\n     */\r\n    constructor(ID, subChannelID, senderID) {\r\n        // Store data in a seperate object such that it isn't confused with channel methods\r\n        this.__data = {\r\n            ID: ID,\r\n            subChannelID: subChannelID,\r\n            senderID: senderID,\r\n        };\r\n\r\n        // Listen for the available message types being send\r\n        this.__setupChannelMessageTypeListener();\r\n    }\r\n\r\n    /**\r\n     * Either requests methods to be set up according to the available message types,\r\n     * Or sets up the actual methods according to the passed data\r\n     * @param  {Object} [types] - The available message types to set\r\n     * @returns {undefined}\r\n     * @protected\r\n     * @async\r\n     */\r\n    _setupMethods(types) {\r\n        // Check if this call is initiating the setup, or actually setting up the data\r\n        if (!types) {\r\n            // The call is initiating the setup\r\n            // Check if the channel hasn't been set up already\r\n            if (this.__data.initialised) {\r\n                return new Promise.resolve(this);\r\n            } else {\r\n                // Broadcast a request for all message types of this channel\r\n                IPC.send(\"channel.requestMessageTypes:\" + this.__data.ID);\r\n                return new Promise((resolve, reject) => {\r\n                    this.__data.finishSetup = resolve;\r\n                });\r\n            }\r\n        } else {\r\n            // Call is actually setting up the data\r\n            // Gather the relevant message types\r\n            let messageTypes = types.globalListeners;\r\n            const subChannelMessageTypes =\r\n                types.subChannelListeners[this.__data.subChannelID];\r\n            if (subChannelMessageTypes)\r\n                messageTypes = messageTypes.concat(subChannelMessageTypes);\r\n\r\n            // Setup the methods\r\n            for (let key of messageTypes)\r\n                this[key] = function() {\r\n                    return this.__sendMessage(key, Array.from(arguments));\r\n                };\r\n\r\n            // Notify that the channel is ready\r\n            this.__data.initialised = true;\r\n            if (this.__data.finishSetup) this.__data.finishSetup(this);\r\n        }\r\n    }\r\n    /**\r\n     * Get the channel ID\r\n     * @returns {string} The channel ID\r\n     * @protected\r\n     */\r\n    _getID() {\r\n        return this.__data.ID;\r\n    }\r\n    /**\r\n     * Get the subchannel ID\r\n     * @returns {string} The subchannel ID\r\n     * @protected\r\n     */\r\n    _getSubChannelID() {\r\n        return this.__data.subChannelID;\r\n    }\r\n\r\n    /**\r\n     * Starts listening for the channel receiver to send its available message types\r\n     * @returns {undefined}\r\n     * @private\r\n     */\r\n    __setupChannelMessageTypeListener() {\r\n        IPC.once(\"channel.sendMessageTypes:\" + this.__data.ID, event => {\r\n            // Check if all the subchannel methods have already been defined\r\n            const containsSubchannel =\r\n                !this.__data.subChannelID ||\r\n                event.data.subChannelListeners[this.__data.subChannelID];\r\n            if (containsSubchannel) {\r\n                // Store the location to send the messages to\r\n                this.__data.destProcessID = event.sourceID;\r\n\r\n                // Setup the methods of this object\r\n                this._setupMethods(event.data);\r\n            } else {\r\n                // Continue listening for message types if the subchannel hadn't been set up yet\r\n                this.__setupChannelMessageTypeListener();\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Send a message to the channel receiver\r\n     * @param  {string} message - The message type\r\n     * @param  {Object[]} args - The data to send as an argument array\r\n     * @returns {undefined}\r\n     * @private\r\n     */\r\n    __sendMessage(message, args) {\r\n        // Send the message and relevant data to the process/window that contains the channel receiver\r\n        return IPC.send(\r\n            \"channel.message:\" + this.__data.ID,\r\n            {\r\n                message: message,\r\n                subChannelID: this.__data.subChannelID,\r\n                senderID: this.__data.senderID,\r\n                data: args,\r\n            },\r\n            this.__data.destProcessID\r\n        );\r\n    }\r\n}\r\n"]}