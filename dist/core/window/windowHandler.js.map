{"version":3,"sources":["../../../src/core/window/windowHandler.js"],"names":["windowSettings","settingsPromise","settingsLoaded","SettingsHandler","_create","windows","then","settings","WindowHandler","__open","windowID","Error","isMain","IPC","sendSync","ID","openedWindows","openingWindows","get","change","width","height","sections","x","y","module","window","BrowserWindow","loadURL","Url","format","pathname","Path","join","__dirname","protocol","slashes","openDevTools","resolve","reject","webContents","on","waitForAssignment","event","args","ipcMain","removeListener","send","_registerWindow","_close","_deregisterWindow","hide","setTimeout","close","openModuleInstance","moduleData","request","modulePath","location","sectionID","section","requestPath","ChannelHandler","createSender","undefined","source","apply","arguments","__setup","data","sourceID","ModuleClass","Registry","_loadModule","onInit","getPath","toString","e","console","error","ipcRenderer","once","log"],"mappings":"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","file":"windowHandler.js","sourcesContent":["import {app, BrowserWindow, ipcMain, ipcRenderer} from \"electron\";\r\nimport Url from \"url\";\r\nimport Path from \"path\";\r\nimport SettingsHandler from \"../communication/data/settings/settingsHandler\";\r\nimport ChannelHandler from \"../communication/channel/channelHandler\";\r\nimport IPC from \"../communication/IPC\";\r\nimport Registry from \"../registry/registry\";\r\nimport isMain from \"../isMain\";\r\n\r\nlet windowSettings;\r\nlet settingsPromise;\r\nfunction settingsLoaded() {\r\n    // Create a promise if not present yet\r\n    if (!settingsPromise)\r\n        // create a settings object to store window data\r\n        settingsPromise = SettingsHandler._create(\"windowCore\", {\r\n            windows: {},\r\n        }).then(settings => {\r\n            // Store these settings when retrieved\r\n            windowSettings = settings;\r\n        });\r\n\r\n    // return the settings initialisation promise\r\n    return settingsPromise;\r\n}\r\n\r\n/**\r\n * @classdesc A static class that allows for the creation and destruction of windows\r\n * @class\r\n * @hideconstructor\r\n */\r\nexport default class WindowHandler {\r\n    /**\r\n     * Opens a window according to the saved settings of that window\r\n     * @param {number} windowID - The ID of the window to open\r\n     * @returns {Promise} Resolves once the window fully opened and loaded\r\n     * @async\r\n     * @private\r\n     */\r\n    static async __open(windowID) {\r\n        // Check if we are trying to open a window with a valid ID\r\n        if (windowID < 1) {\r\n            throw Error(\"Window IDs must start from 1\");\r\n        }\r\n\r\n        // Check if this code is ran in the main process\r\n        if (!isMain) {\r\n            // If it is not ran in the main process, forward the call to the main process\r\n            return IPC.sendSync(\"WindowHandler.open\", {\r\n                ID: windowID,\r\n            });\r\n        } else {\r\n            // If the window is already opened return\r\n            if (this.openedWindows[windowID]) return;\r\n\r\n            // If the window is already opening, return its promise\r\n            if (this.openingWindows[windowID])\r\n                return this.openingWindows[windowID];\r\n\r\n            // Create a new opening promise indicating that the window is currently opening, but only after the settings have loaded\r\n            return (this.openingWindows[windowID] = settingsLoaded().then(\r\n                async () => {\r\n                    // Get the settings for this particular window\r\n                    let settings = windowSettings.get(`windows.${windowID}`);\r\n\r\n                    // Set default data if these settings are absent\r\n                    if (!settings) {\r\n                        await windowSettings.change({\r\n                            windows: {\r\n                                [windowID]: {\r\n                                    width: 800,\r\n                                    height: 600,\r\n                                    sections: {\r\n                                        0: {\r\n                                            width: 100,\r\n                                            height: 100,\r\n                                            x: 0,\r\n                                            y: 0,\r\n                                            module: \"none\",\r\n                                        },\r\n                                    },\r\n                                },\r\n                            },\r\n                        });\r\n                        settings = windowSettings.get(`windows.${windowID}`);\r\n                    }\r\n\r\n                    // Create a browser window according to these settings\r\n                    const window = new BrowserWindow({\r\n                        width: settings.width,\r\n                        height: settings.height,\r\n                    });\r\n\r\n                    // Load the window index path into this window\r\n                    window.loadURL(\r\n                        Url.format({\r\n                            pathname: Path.join(__dirname, \"windowIndex.html\"),\r\n                            protocol: \"file:\",\r\n                            slashes: true,\r\n                        })\r\n                    );\r\n\r\n                    // Open dev tools for debugging TODO: add some option to disable/enable this\r\n                    window.openDevTools();\r\n\r\n                    // Wait for the window to finish loading\r\n                    await new Promise((resolve, reject) => {\r\n                        window.webContents.on(\"did-finish-load\", () => {\r\n                            resolve();\r\n                        });\r\n                    });\r\n\r\n                    // Assign an ID to the window (LM IPC uses this, so we need to use lower level IPC until compeleted)\r\n                    await new Promise((resolve, reject) => {\r\n                        // A listener that resolves the promise when a IPC assignment event is received, in which case the listener is also removed\r\n                        const waitForAssignment = (event, args) => {\r\n                            if (args.ID == windowID) {\r\n                                ipcMain.removeListener(\r\n                                    \"WindowHandler.assignedID\",\r\n                                    waitForAssignment\r\n                                );\r\n                                resolve();\r\n                            }\r\n                        };\r\n\r\n                        // Enable the listener\r\n                        ipcMain.on(\r\n                            \"WindowHandler.assignedID\",\r\n                            waitForAssignment\r\n                        );\r\n\r\n                        // Send the ID assignment to complete initialisation\r\n                        window.webContents.send(\"WindowHandler.assignID\", {\r\n                            ID: windowID,\r\n                        });\r\n                    });\r\n\r\n                    // Register the newly created window in IPC so the higher level IPC class can send message to it\r\n                    IPC._registerWindow(window, windowID);\r\n\r\n                    // Finish the window initialisation\r\n                    await IPC.send(\"WindowHandler.initialise\", {}, windowID);\r\n\r\n                    // Store the opened window and delete the opening promise\r\n                    this.openedWindows[windowID] = window;\r\n                    delete this.openingWindows[windowID];\r\n                }\r\n            ));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Close a window (Doesn't properly dispose the modules loaded inside it)\r\n     * @param {number} [windowID] - The ID of the window to close\r\n     * @returns {Promise} Resolves once the window has fulyl closed\r\n     * @async\r\n     * @protected\r\n     */\r\n    static async _close(windowID) {\r\n        // If no windowID is provided, use the ID of the window this code is running in\r\n        if (!windowID) windowID = this.ID;\r\n\r\n        // Check if we are trying to open a window with a valid ID\r\n        if (windowID < 1) {\r\n            throw Error(\"Window IDs must start from 0\");\r\n        } else {\r\n            // Check if this code is ran in the main process\r\n            if (!isMain) {\r\n                // If it is not ran in the main process, forward the call to the main process\r\n                return IPC.send(\"WindowHandler.close\", {\r\n                    ID: windowID,\r\n                });\r\n            } else {\r\n                // If the window is not opened, throw an error\r\n                if (!this.openedWindows[windowID])\r\n                    throw Error(\"Window must be opened in order to close\");\r\n\r\n                // Get the window in order to close it\r\n                const window = this.openedWindows[windowID];\r\n\r\n                // Indicate that the window is no longer opened\r\n                this.openedWindows[windowID] = null;\r\n\r\n                // Tell IPC that this window no longer exists\r\n                IPC._deregisterWindow(windowID);\r\n\r\n                // Close the actual window\r\n                // Give stuff some time to properly finish\r\n                // TODO: do more research as to why it crashes on immediate close\r\n                window.hide();\r\n                setTimeout(() => {\r\n                    window.close();\r\n                }, 10);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Opens a module in the proper window, will automatically open the window if it isn't already\r\n     * @param {object} moduleData - The settings data for the module to open\r\n     * @param {Registry~Request} request - The request that caused this module to be opened\r\n     * @param {strubg} modulePath - The path to the class of the module to be instantiated\r\n     * @returns {Promise<ChannelSender>} A channel to the module that has been created\r\n     * @async\r\n     * @public\r\n     */\r\n    static async openModuleInstance(moduleData, request, modulePath) {\r\n        // Retrieve the infoormation for where to instanciate the module\r\n        const windowID = moduleData.location.window;\r\n        const sectionID = moduleData.location.section;\r\n\r\n        // Open the window that the module should be instanciated in\r\n        await this.__open(windowID);\r\n\r\n        // Send a request to main to create the instance, and return its unique request path\r\n        const requestPath = (await IPC.send(\r\n            \"WindowHandler.openModule\",\r\n            {\r\n                request: request,\r\n                modulePath: modulePath,\r\n                moduleData: moduleData,\r\n            },\r\n            windowID\r\n        ))[0];\r\n\r\n        // Check if a request path is returned, if it wasn't, it could be that the window was just closing\r\n        if (requestPath) {\r\n            // Create a channel sender to this module instance and return it\r\n            return ChannelHandler.createSender(\r\n                requestPath,\r\n                undefined,\r\n                request.source\r\n            );\r\n        } else {\r\n            // Try again\r\n            await openModuleInstance.apply(this, arguments);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The initial setup method to be called by this file itself, initialises the static fields of the class\r\n     * @return {undefined}\r\n     * @private\r\n     */\r\n    static __setup() {\r\n        if (isMain) {\r\n            // Set the own process/window ID to be 0\r\n            this.ID = 0;\r\n\r\n            // Forward a window open request to the __open method\r\n            IPC.on(\"WindowHandler.open\", event => {\r\n                const data = event.data;\r\n                const ID = data.ID;\r\n                return this.__open(ID);\r\n            });\r\n\r\n            // Forward a window clsoe request to the __close method\r\n            IPC.on(\"WindowHandler.close\", event => {\r\n                const data = event.data;\r\n                const ID = data.ID;\r\n                this._close(ID != null ? ID : event.sourceID);\r\n            });\r\n\r\n            // Keep track of what windows are currently opened and what windows are currently openeing\r\n            this.openedWindows = {};\r\n            this.openingWindows = {};\r\n        } else {\r\n            // Open a module when a request is received\r\n            IPC.on(\"WindowHandler.openModule\", async event => {\r\n                const data = event.data;\r\n                try {\r\n                    // Load the module class from the passed module path\r\n                    const ModuleClass = Registry._loadModule(data.modulePath);\r\n\r\n                    // Instanciate the module from the class\r\n                    const module = new ModuleClass(data.request);\r\n\r\n                    // Wait for the module to finish initialising\r\n                    await module.onInit();\r\n\r\n                    // Return the the unique path to the module\r\n                    return module.getPath().toString(true);\r\n                } catch (e) {\r\n                    // TODO: properply handle the error when something goes wrong\r\n                    console.error(\r\n                        `Something went wrong while trying to instantiate ${\r\n                            data.modulePath\r\n                        }`,\r\n                        e\r\n                    );\r\n                    return false;\r\n                }\r\n            });\r\n\r\n            // Use low level IPC to assign the correct window ID\r\n            ipcRenderer.once(\"WindowHandler.assignID\", async (event, args) => {\r\n                const windowID = args.ID;\r\n                window.ID = IPC.ID = this.ID = windowID;\r\n\r\n                // Notify the main process that the ID was assigned\r\n                ipcRenderer.send(\"WindowHandler.assignedID\", {ID: windowID});\r\n            });\r\n\r\n            // Use higher level IPC to finish the initiialisation\r\n            IPC.once(\"WindowHandler.initialise\", async event => {\r\n                const windowID = this.ID;\r\n\r\n                // Load the window settings\r\n                const windowSettings = await SettingsHandler._create(\r\n                    \"windowCore\"\r\n                );\r\n                const settings = windowSettings.get(`windows.${windowID}`);\r\n                window.settings = settings;\r\n\r\n                // TODO: setup GUI sections and load the modules\r\n                console.log(settings);\r\n            });\r\n        }\r\n    }\r\n}\r\nWindowHandler.__setup();\r\n"]}