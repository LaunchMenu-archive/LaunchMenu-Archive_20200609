{"version":3,"sources":["../../../src/core/window/windowHandler.js"],"names":["windowSettings","settingsPromise","settingsLoaded","SettingsHandler","_create","windows","then","settings","WindowHandler","__open","windowID","Error","isMain","IPC","sendSync","ID","openedWindows","openingWindows","get","change","width","height","sections","x","y","module","window","BrowserWindow","loadURL","Url","format","pathname","Path","join","__dirname","protocol","slashes","openDevTools","resolve","reject","webContents","on","waitForAssignment","event","args","ipcMain","removeListener","send","_registerWindow","_close","_deregisterWindow","hide","setTimeout","close","openModuleInstance","moduleData","request","modulePath","location","sectionID","section","destinationWindowID","_destinationWindowID","_destinationSectionID","sourceRequestPath","RequestPath","source","requestPath","Registry","getModuleChannel","undefined","apply","arguments","__setup","data","sourceID","ModuleClass","_loadModule","onInit","path","getPath","toString","core","elementCreator","embedGUI","dockingContainer","$openModule","e","console","error","ipcRenderer","once","windowChannelReceiver","ChannelHandler","createReceiver","createSubChannel","requestHandle","type","ReactDOM","render","__data","document","getElementById","log"],"mappings":"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","file":"windowHandler.js","sourcesContent":["import {app, BrowserWindow, ipcMain, ipcRenderer} from \"electron\";\r\nimport Url from \"url\";\r\nimport Path from \"path\";\r\nimport ReactDOM from \"react-dom\";\r\n\r\nimport SettingsHandler from \"../communication/data/settings/settingsHandler\";\r\nimport ChannelHandler from \"../communication/channel/channelHandler\";\r\nimport IPC from \"../communication/IPC\";\r\nimport Registry from \"../registry/registry\";\r\nimport isMain from \"../isMain\";\r\nimport RequestPath from \"../registry/requestPath\";\r\n\r\n/**\r\n    GUI module instanciation abstract algorithm:\r\n        -If the window in which the module should appear hasn't finished opening\r\n                and the request doesn't come from the same window, open the window:\r\n            -Set up the registry\r\n            -Set up the docking system:\r\n                -Use the registry and module instanciation system to get GUI components,\r\n                        No infinite recursion will occur because the request came from the same window\r\n        -Open the module instance\r\n        -If the module has GUI, set it up:\r\n            -If the request is an embed request: attach GUI to the returned channel\r\n            -Else: Open the module's GUI in the window by sending it to the docking system\r\n */\r\n\r\nlet windowSettings;\r\nlet settingsPromise;\r\nfunction settingsLoaded() {\r\n    // Create a promise if not present yet\r\n    if (!settingsPromise)\r\n        // create a settings object to store window data\r\n        settingsPromise = SettingsHandler._create(\"windowCore\", {\r\n            windows: {},\r\n        }).then(settings => {\r\n            // Store these settings when retrieved\r\n            windowSettings = settings;\r\n        });\r\n\r\n    // return the settings initialisation promise\r\n    return settingsPromise;\r\n}\r\n\r\n/**\r\n * @classdesc A static class that allows for the creation and destruction of windows\r\n * @class\r\n * @hideconstructor\r\n */\r\nexport default class WindowHandler {\r\n    /**\r\n     * Opens a window according to the saved settings of that window\r\n     * @param {number} windowID - The ID of the window to open\r\n     * @returns {Promise} Resolves once the window fully opened and loaded\r\n     * @async\r\n     * @private\r\n     */\r\n    static async __open(windowID) {\r\n        // Check if we are trying to open a window with a valid ID\r\n        if (windowID < 1) {\r\n            throw Error(\"Window IDs must start from 1\");\r\n        }\r\n\r\n        // Check if this code is ran in the main process\r\n        if (!isMain) {\r\n            // If it is not ran in the main process, forward the call to the main process\r\n            return IPC.sendSync(\"WindowHandler.open\", {\r\n                ID: windowID,\r\n            });\r\n        } else {\r\n            // If the window is already opened return\r\n            if (this.openedWindows[windowID]) return;\r\n\r\n            // If the window is already opening, return its promise\r\n            if (this.openingWindows[windowID])\r\n                return this.openingWindows[windowID];\r\n\r\n            // Create a new opening promise indicating that the window is currently opening, but only after the settings have loaded\r\n            return (this.openingWindows[windowID] = settingsLoaded().then(\r\n                async () => {\r\n                    // Get the settings for this particular window\r\n                    let settings = windowSettings.get(`windows.${windowID}`);\r\n\r\n                    // Set default data if these settings are absent\r\n                    if (!settings) {\r\n                        await windowSettings.change({\r\n                            windows: {\r\n                                [windowID]: {\r\n                                    width: 800,\r\n                                    height: 600,\r\n                                    sections: {\r\n                                        0: {\r\n                                            width: 100,\r\n                                            height: 100,\r\n                                            x: 0,\r\n                                            y: 0,\r\n                                            module: \"none\",\r\n                                        },\r\n                                    },\r\n                                },\r\n                            },\r\n                        });\r\n                        settings = windowSettings.get(`windows.${windowID}`);\r\n                    }\r\n\r\n                    // Create a browser window according to these settings\r\n                    const window = new BrowserWindow({\r\n                        width: settings.width,\r\n                        height: settings.height,\r\n                    });\r\n\r\n                    // Load the window index path into this window\r\n                    window.loadURL(\r\n                        Url.format({\r\n                            pathname: Path.join(__dirname, \"windowIndex.html\"),\r\n                            protocol: \"file:\",\r\n                            slashes: true,\r\n                        })\r\n                    );\r\n\r\n                    // Open dev tools for debugging TODO: add some option to disable/enable this\r\n                    window.openDevTools();\r\n\r\n                    // Wait for the window to finish loading\r\n                    await new Promise((resolve, reject) => {\r\n                        window.webContents.on(\"did-finish-load\", () => {\r\n                            resolve();\r\n                        });\r\n                    });\r\n\r\n                    // Assign an ID to the window (LM IPC uses this, so we need to use lower level IPC until compeleted)\r\n                    await new Promise((resolve, reject) => {\r\n                        // A listener that resolves the promise when a IPC assignment event is received, in which case the listener is also removed\r\n                        const waitForAssignment = (event, args) => {\r\n                            if (args.ID == windowID) {\r\n                                ipcMain.removeListener(\r\n                                    \"WindowHandler.assignedID\",\r\n                                    waitForAssignment\r\n                                );\r\n                                resolve();\r\n                            }\r\n                        };\r\n\r\n                        // Enable the listener\r\n                        ipcMain.on(\r\n                            \"WindowHandler.assignedID\",\r\n                            waitForAssignment\r\n                        );\r\n\r\n                        // Send the ID assignment to complete initialisation\r\n                        window.webContents.send(\"WindowHandler.assignID\", {\r\n                            ID: windowID,\r\n                        });\r\n                    });\r\n\r\n                    // Register the newly created window in IPC so the higher level IPC class can send message to it\r\n                    IPC._registerWindow(window, windowID);\r\n\r\n                    // Finish the window initialisation\r\n                    await IPC.send(\"WindowHandler.initialise\", {}, windowID);\r\n\r\n                    // Store the opened window and delete the opening promise\r\n                    this.openedWindows[windowID] = window;\r\n                    delete this.openingWindows[windowID];\r\n                }\r\n            ));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Close a window (Doesn't properly dispose the modules loaded inside it)\r\n     * @param {number} [windowID] - The ID of the window to close\r\n     * @returns {Promise} Resolves once the window has fulyl closed\r\n     * @async\r\n     * @protected\r\n     */\r\n    static async _close(windowID) {\r\n        // If no windowID is provided, use the ID of the window this code is running in\r\n        if (!windowID) windowID = this.ID;\r\n\r\n        // Check if we are trying to open a window with a valid ID\r\n        if (windowID < 1) {\r\n            throw Error(\"Window IDs must start from 0\");\r\n        } else {\r\n            // Check if this code is ran in the main process\r\n            if (!isMain) {\r\n                // If it is not ran in the main process, forward the call to the main process\r\n                return IPC.send(\"WindowHandler.close\", {\r\n                    ID: windowID,\r\n                });\r\n            } else {\r\n                // If the window is not opened, throw an error\r\n                if (!this.openedWindows[windowID])\r\n                    throw Error(\"Window must be opened in order to close\");\r\n\r\n                // Get the window in order to close it\r\n                const window = this.openedWindows[windowID];\r\n\r\n                // Indicate that the window is no longer opened\r\n                this.openedWindows[windowID] = null;\r\n\r\n                // Tell IPC that this window no longer exists\r\n                IPC._deregisterWindow(windowID);\r\n\r\n                // Close the actual window\r\n                // Give stuff some time to properly finish\r\n                // TODO: do more research as to why it crashes on immediate close\r\n                window.hide();\r\n                setTimeout(() => {\r\n                    window.close();\r\n                }, 10);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Opens a module in the proper window, will automatically open the window if it isn't already\r\n     * @param {object} moduleData - The settings data for the module to open\r\n     * @param {Registry~Request} request - The request that caused this module to be opened\r\n     * @param {string} modulePath - The path to the class of the module to be instantiated\r\n     * @returns {Promise<ChannelSender>} A channel to the module that has been created\r\n     * @async\r\n     * @public\r\n     */\r\n    static async openModuleInstance(moduleData, request, modulePath) {\r\n        // Retrieve the infoormation for where to instanciate the module\r\n        const windowID = moduleData.location.window;\r\n        const sectionID = moduleData.location.section;\r\n\r\n        // If the request defines a windowID, use that instead\r\n        if (request.destinationWindowID != null) {\r\n            windowID = request._destinationWindowID;\r\n            sectionID = request._destinationSectionID || 0;\r\n        }\r\n\r\n        // Check if the request was made by the window\r\n        const sourceRequestPath = new RequestPath(request.source);\r\n        if (windowID != this.ID) {\r\n            // If this wasn't an internal requestCall, make sure to open the window that the module should be instanciated in\r\n            await this.__open(windowID);\r\n        }\r\n\r\n        // Send a request to main to create the instance, and return its unique request path\r\n        const requestPath = (await IPC.send(\r\n            \"WindowHandler.openModule\",\r\n            {\r\n                request: request,\r\n                modulePath: modulePath,\r\n                moduleData: moduleData,\r\n            },\r\n            windowID\r\n        ))[0];\r\n\r\n        // Check if a request path is returned, if it wasn't, it could be that the window was just closing\r\n        if (requestPath) {\r\n            // Return the channelSender to cummonicate with the instanciated module\r\n            return await Registry.getModuleChannel(\r\n                requestPath,\r\n                undefined,\r\n                request.source\r\n            );\r\n\r\n            //Make sure the requestPath wasn't not returned because of an error\r\n        } else if (requestPath !== false) {\r\n            // Try again\r\n            await this.openModuleInstance.apply(this, arguments);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The initial setup method to be called by this file itself, initialises the static fields of the class\r\n     * @return {undefined}\r\n     * @private\r\n     */\r\n    static __setup() {\r\n        if (isMain) {\r\n            // Set the own process/window ID to be 0\r\n            this.ID = 0;\r\n\r\n            // Forward a window open request to the __open method\r\n            IPC.on(\"WindowHandler.open\", event => {\r\n                const data = event.data;\r\n                const ID = data.ID;\r\n                return this.__open(ID);\r\n            });\r\n\r\n            // Forward a window clsoe request to the __close method\r\n            IPC.on(\"WindowHandler.close\", event => {\r\n                const data = event.data;\r\n                const ID = data.ID;\r\n                this._close(ID != null ? ID : event.sourceID);\r\n            });\r\n\r\n            // Keep track of what windows are currently opened and what windows are currently openeing\r\n            this.openedWindows = {};\r\n            this.openingWindows = {};\r\n        } else {\r\n            // Open a module when a request is received\r\n            IPC.on(\"WindowHandler.openModule\", async event => {\r\n                const data = event.data;\r\n                try {\r\n                    // Load the module class from the passed module path\r\n                    const ModuleClass = Registry._loadModule(data.modulePath);\r\n\r\n                    // Instanciate the module from the class\r\n                    const module = new ModuleClass(data.request);\r\n\r\n                    // Wait for the module to finish initialising\r\n                    await module.onInit();\r\n\r\n                    // Retrieve the unique path to the module\r\n                    const path = module.getPath().toString(true);\r\n\r\n                    // If the module is an GUI module, do something with that GUI\r\n                    if (module.core.elementCreator) {\r\n                        // Check whether we are requesting a module to be embeded directly to the page\r\n                        if (!data.request.embedGUI) {\r\n                            //TODO: replace test code with proper code\r\n                            this.dockingContainer.$openModule(path, 0);\r\n                            // const ReactDOM = require(\"react-dom\");\r\n                            // ReactDOM.render(\r\n                            //     module.core.elementCreator,\r\n                            //     document.body\r\n                            // );\r\n                        }\r\n                    }\r\n\r\n                    // Return the the unique path to the module\r\n                    return path;\r\n                } catch (e) {\r\n                    // TODO: properply handle the error when something goes wrong\r\n                    console.error(\r\n                        `Something went wrong while trying to instantiate ${\r\n                            data.modulePath\r\n                        }`,\r\n                        e\r\n                    );\r\n                    return false;\r\n                }\r\n            });\r\n\r\n            // Use low level IPC to assign the correct window ID\r\n            ipcRenderer.once(\"WindowHandler.assignID\", async (event, args) => {\r\n                const windowID = args.ID;\r\n                window.ID = IPC.ID = this.ID = windowID;\r\n\r\n                // Notify the main process that the ID was assigned\r\n                ipcRenderer.send(\"WindowHandler.assignedID\", {ID: windowID});\r\n            });\r\n\r\n            // Use higher level IPC to finish the initiialisation\r\n            IPC.once(\"WindowHandler.initialise\", async event => {\r\n                const windowID = this.ID;\r\n\r\n                // Load the window settings\r\n                const windowSettings = await SettingsHandler._create(\r\n                    \"windowCore\"\r\n                );\r\n                const settings = windowSettings.get(`windows.${windowID}`);\r\n                window.settings = settings;\r\n\r\n                /* Set up docking systen */\r\n\r\n                // Create a Window channel for the dockingContainer to communicate with\r\n                const windowChannelReceiver = await ChannelHandler.createReceiver(\r\n                    \">Window\",\r\n                    {}\r\n                );\r\n\r\n                // Create a subchannel on the window receiver, that answers DockingContainer\r\n                windowChannelReceiver.createSubChannel(\"DockingContainer\", {});\r\n\r\n                // Retrieve the class for the docking system\r\n                this.dockingContainer = await Registry.requestHandle({\r\n                    type: \"DockingContainer\",\r\n                    source: \">Window\",\r\n                    embedGUI: true,\r\n                    data: settings.sections,\r\n                });\r\n\r\n                // Render the docking container's GUI in the window\r\n                ReactDOM.render(\r\n                    this.dockingContainer.__data.elementCreator,\r\n                    document.getElementById(\"body\")\r\n                );\r\n\r\n                // TODO: setup GUI sections and load the modules\r\n                console.log(settings, this.dockingContainer);\r\n            });\r\n        }\r\n    }\r\n}\r\nWindowHandler.__setup();\r\n"]}