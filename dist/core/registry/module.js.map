{"version":3,"sources":["../../../src/core/registry/module.js"],"names":["Module","constructor","request","canBeDirectlyInstantiated","registerPromiseResolve","registerPromise","resolve","reject","core","registration","registered","BooleanProcess","initPromise","handlers","source","__register","Error","false","turningTrue","requestPath","RequestPath","augmentPath","getClass","modulePath","Registry","_registerModuleInstance","promises","push","ChannelHandler","createReceiver","toString","__createChannelMethods","then","receiver","channelReceiver","createSender","type","channel","SettingsHandler","createModuleSettings","getConfig","settings","all","true","__init","method","__onRegister","ctch","catch","onInit","getPath","__proto__","config","getSource","getSettings","__getMethods","regexFilter","output","nextProto","prototype","proto","forEach","varName","variable","isChannelMethod","Function","test","methods","methodName","event","apply","concat","data","close","dispose","disconnectDescendant","__disconnectDescendant","handler","channels","filter","_getID","length","turningFalse","channelDisposalPromises","map","_deregisterModuleInstance","requestHandle","createSubChannel","Array"],"mappings":"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","file":"module.js","sourcesContent":["import ChannelHandler from \"../communication/channel/channelHandler\";\r\nimport SettingsHandler from \"../communication/data/settings/settingsHandler\";\r\nimport Registry from \"./registry\";\r\nimport RequestPath from \"./requestPath/requestPath\";\r\nimport BooleanProcess from \"../utils/booleanProcess\";\r\n\r\nexport default class Module {\r\n    /**\r\n     * Create a module instance which is the core building block for LM\r\n     * @param {Request} request - The request that caused this module to be instantiated\r\n     * @param {boolean} canBeDirectlyInstantiated - Whether or not this module should be instantiatable without a request\r\n     * @constructs Module\r\n     * @public\r\n     */\r\n    constructor(request, canBeDirectlyInstantiated) {\r\n        // Create the promise that gets resolved on registration\r\n        let registerPromiseResolve = null;\r\n        const registerPromise = new Promise((resolve, reject) => {\r\n            registerPromiseResolve = resolve;\r\n        });\r\n\r\n        // Create the core data of the module\r\n        this.core = {\r\n            registration: {\r\n                registered: new BooleanProcess(0),\r\n                registerPromise: registerPromise,\r\n                registerPromiseResolve: registerPromiseResolve,\r\n            },\r\n            initPromise: registerPromise, // Other methods may build upon this promise\r\n            handlers: {},\r\n            source: {},\r\n        };\r\n\r\n        // Check if the module was instanciated with a request\r\n        if (request) {\r\n            // Store the request\r\n            this.core.source = {\r\n                request: request,\r\n            };\r\n\r\n            // Register the module in the registry\r\n            this.__register();\r\n        } else if (!canBeDirectlyInstantiated) {\r\n            // Throw an error if this module was instanciated without a request but isn't allowed to\r\n            throw Error(\r\n                \"This module can only be instantiated from a handle request\"\r\n            );\r\n        } else {\r\n            this.core.initPromise = Promise.resolve();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Registers the module if it wasn't registered already\r\n     * @returns {Module} A reference to itself\r\n     * @async\r\n     * @private\r\n     */\r\n    async __register() {\r\n        // Chech if the module is currently unregistered\r\n        if (this.core.registration.registered.false()) {\r\n            // Indicate that we are now in the process of registering the moduke\r\n            this.core.registration.registered.turningTrue(true);\r\n\r\n            // Get the module source\r\n            const source = this.core.source;\r\n\r\n            // Check if the source contains a request that instanciated it\r\n            if (source.request) {\r\n                // Store the requestPath to this module by agumenting the request's requestPath by this module\r\n                const requestPath = new RequestPath(source.request.source);\r\n                source.requestPath = requestPath.augmentPath(\r\n                    this.getClass().modulePath,\r\n                    0\r\n                );\r\n\r\n                // Register this module in the registry (which will automatically assign a unique module ID)\r\n                await Registry._registerModuleInstance(this);\r\n\r\n                const promises = [];\r\n                // Create a channel receiver that can be used to receive messages from other modules\r\n                promises.push(\r\n                    ChannelHandler.createReceiver(\r\n                        source.requestPath.toString(true),\r\n                        this.__createChannelMethods()\r\n                    ).then(receiver => {\r\n                        // Store the channel receiver\r\n                        this.core.channelReceiver = receiver;\r\n                    })\r\n                );\r\n\r\n                // Create a channel sender to the module that requested this module\r\n                promises.push(\r\n                    ChannelHandler.createSender(\r\n                        source.request.source,\r\n                        source.request.type,\r\n                        source.requestPath.toString(true)\r\n                    ).then(channel => {\r\n                        // Store the channel sender\r\n                        source.channel = channel;\r\n                    })\r\n                );\r\n\r\n                // Load the settings of the module\r\n                promises.push(\r\n                    SettingsHandler.createModuleSettings(\r\n                        source.requestPath,\r\n                        this.getClass().getConfig().settings || {}\r\n                    ).then(settings => {\r\n                        // Store the settings\r\n                        this.core.settings = settings;\r\n                    })\r\n                );\r\n\r\n                // Wait for both to finish\r\n                await Promise.all(promises);\r\n\r\n                // Indicate that registering has finished and resolve the promise\r\n                this.core.registration.registered.true(true);\r\n                this.core.registration.registerPromiseResolve(this);\r\n            } else {\r\n                // If the module was not instantiated by a request, the request path is simply this module path\r\n                source.requestPath = new RequestPath(\r\n                    this.getClass().modulePath,\r\n                    0\r\n                );\r\n\r\n                // Register this module in the registry (which will automatically assign a unique module ID)\r\n                await Registry._registerModuleInstance(this);\r\n\r\n                // Create a channel receiver that can be used to receive message from other modules\r\n                this.core.channelReceiver = await ChannelHandler.createReceiver(\r\n                    source.requestPath.toString(true),\r\n                    this.__createChannelMethods()\r\n                );\r\n\r\n                // Indicate that registering has finished and resolve th epromise\r\n                this.core.registration.registered.true(true);\r\n                this.core.registration.registerPromiseResolve(this);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a function to run before indicating that initialisation has finished\r\n     * @param {function} method - The function to run (may be async)\r\n     * @returns {Promise} A promise that resolves when the module is initialised\r\n     * @private\r\n     */\r\n    __init(method) {\r\n        // Add the method to the chain and return the chain\r\n        return (this.core.initPromise = this.core.initPromise.then(method));\r\n    }\r\n\r\n    /**\r\n     * Adds a then and catch function to the registration completion promise\r\n     * @param {function} [then] - The function to run when registration has finished\r\n     * @param {function} [ctch] - The function to run if something goes wrong during registration\r\n     * @returns {Promise<Module>} A reference to this module instance\r\n     * @async\r\n     * @private\r\n     */\r\n    __onRegister(then, ctch) {\r\n        return this.core.registration.registerPromise.then(then).catch(ctch);\r\n    }\r\n\r\n    /**\r\n     * Adds a then and catch function to the initialization completion promise\r\n     * @param {function} [then] - The function to run when initialization has finished\r\n     * @param {function} [ctch] - The function to run if something goes wrong during initialization\r\n     * @returns {Promise<Module>} A reference to this module instance\r\n     * @async\r\n     * @private\r\n     */\r\n    onInit(then, ctch) {\r\n        return this.core.initPromise.then(then).catch(ctch);\r\n    }\r\n\r\n    // Registry related methods\r\n    /**\r\n     * Returns the path to this module instance\r\n     * @returns {string} The path to this module instance\r\n     * @public\r\n     */\r\n    toString() {\r\n        // Get the request path and get its unique string representation\r\n        return this.getPath().toString(true);\r\n    }\r\n\r\n    /**\r\n     * Returns the class of this module instance\r\n     * @returns {Class<Module>} The class of this module instance\r\n     * @public\r\n     */\r\n    getClass() {\r\n        // Get the class out of this object instance\r\n        return this.__proto__.constructor;\r\n    }\r\n\r\n    /**\r\n     * Returns the requestPath that created this module instance\r\n     * @returns {RequestPath} The request path\r\n     * @public\r\n     */\r\n    getPath() {\r\n        // Get the channel sender that has been created in the __register method\r\n        return this.core.source.requestPath;\r\n    }\r\n\r\n    /**\r\n     * Returns the config file of this class\r\n     * @returns {Config} The module config\r\n     * @public\r\n     */\r\n    static getConfig() {\r\n        // Get the config that has been assigned by the registry when loading the module class\r\n        return this.config;\r\n    }\r\n\r\n    /**\r\n     * Returns the path to this module class\r\n     * @returns {string} The path to this module class\r\n     * @public\r\n     */\r\n    static getPath() {\r\n        // Get the modulePath that has been assigned by the registry when loading the module class\r\n        return this.modulePath;\r\n    }\r\n\r\n    /**\r\n     * Returns the path to this module class\r\n     * @returns {string} The path to this module class\r\n     * @public\r\n     */\r\n    static toString() {\r\n        return this.getPath();\r\n    }\r\n\r\n    /**\r\n     * Returns the channelSender to communicate with the module that instanciated this module\r\n     * @returns {ChannelSender} The channelSender to communicate with the module\r\n     * @public\r\n     */\r\n    getSource() {\r\n        return this.core.source.channel;\r\n    }\r\n\r\n    /**\r\n     * Returns the settings of the module\r\n     * @returns {ModuleSettings} The settings that apply to this module instance\r\n     * @public\r\n     */\r\n    getSettings() {\r\n        return this.core.settings;\r\n    }\r\n\r\n    // Channel related methods\r\n    /**\r\n     * Gets all the methods of this module that are available for channels\r\n     * @param {Regex} regexFilter - The filter to apply to determine whether or not the method should be returned\r\n     * @returns {Object} All methods indexed by name\r\n     * @private\r\n     */\r\n    __getMethods(regexFilter) {\r\n        // Set up an object to store the output methods\r\n        const output = {};\r\n\r\n        // Go through the inheritence chain\r\n        let nextProto = this.__proto__;\r\n        while (nextProto && nextProto != Module.prototype) {\r\n            // Get the prototype of which to get the methods\r\n            const proto = nextProto;\r\n            nextProto = proto.__proto__;\r\n\r\n            // Go through all methods in the class\r\n            Object.getOwnPropertyNames(proto).forEach(varName => {\r\n                // Get the variable\r\n                const variable = this.__proto__[varName];\r\n\r\n                // Check if the variable is a method that should be available for the chanenl\r\n                const isChannelMethod =\r\n                    variable instanceof Function &&\r\n                    regexFilter.test(varName) &&\r\n                    !output[varName];\r\n\r\n                if (isChannelMethod) {\r\n                    // If the method should be avaiable, remove the prefix and store it in the output\r\n                    output[varName] = this.__proto__[varName];\r\n                }\r\n            });\r\n        }\r\n\r\n        // Return the output\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     * Creates all methods to interact with this module over a channel\r\n     * @returns {Object} All methods indexed by name\r\n     * @private\r\n     */\r\n    __createChannelMethods() {\r\n        // Set up an object to store the output methods\r\n        const output = {};\r\n\r\n        // Get the methpds that are available for the channel\r\n        const methods = this.__getMethods(/^\\$/);\r\n\r\n        // Go through all the methods to correctly map the channel data\r\n        Object.keys(methods).forEach(methodName => {\r\n            // Get the method from its name\r\n            const method = methods[methodName];\r\n\r\n            // Apply the event followed by the channel data as arguments for the method\r\n            output[methodName] = event => {\r\n                return method.apply(this, [event].concat(event.data));\r\n            };\r\n        });\r\n\r\n        // Set up a close method for the channel\r\n        output.close = event => {\r\n            return this.dispose();\r\n        };\r\n\r\n        // Set up a disconnectDescendant method for the channel that will detach a descendant from itself\r\n        output.disconnectDescendant = event => {\r\n            return this.__disconnectDescendant.apply(this, event.data);\r\n        };\r\n\r\n        // Return the output\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     * Disconnects a module from this module (But doesn't dispose it)\r\n     * @param {RequestPath} requestPath - The request path for the module to disconnect\r\n     * @param {string} type - The type of request that the module was instiated for\r\n     * @returns {undefined}\r\n     * @private\r\n     */\r\n    __disconnectDescendant(requestPath, type) {\r\n        // Get the handler for this request type if available\r\n        const handler = this.core.handlers[type];\r\n        if (handler) {\r\n            // Extract the channels from this handler\r\n            const channels = handler.channels;\r\n\r\n            // Remove the channel that matches the requestPath\r\n            handler.channels = channels.filter(channel => {\r\n                return channel._getID() != requestPath;\r\n            });\r\n\r\n            // Remove the handler if all channels have been closed\r\n            if (handler.channels.length == 0) delete this.core.handlers[type];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes this module entirely, also getting rid of its connections to other modules\r\n     * @returns {Promise} The promise that resolves once disposal has completed\r\n     * @async\r\n     * @public\r\n     */\r\n    async dispose() {\r\n        // Check if the module is not still registering\r\n        if (this.core.registration.registered.turningTrue())\r\n            throw Error(\"Module is still registering\");\r\n\r\n        // Check if the module is registered in the first place\r\n        if (this.core.registration.registered.true()) {\r\n            // Indicate that the module is now in the process of deregestering\r\n            this.core.registration.registered.turningFalse(true);\r\n\r\n            // Object to track all the promises of modules being disposed\r\n            const channelDisposalPromises = [];\r\n\r\n            // Go through all the handlers to dispose them\r\n            Object.keys(this.core.handlers).forEach(type => {\r\n                // Get the handler and its channels\r\n                const handler = this.core.handlers[type];\r\n                const channels = handler.channels;\r\n\r\n                // Close all the handle modules and track their promises\r\n                channelDisposalPromises.push.apply(\r\n                    channelDisposalPromises,\r\n                    channels.map(channel => {\r\n                        return channel.close();\r\n                    })\r\n                );\r\n            });\r\n\r\n            // Wait for all modules to finish disposing\r\n            await Promise.all(channelDisposalPromises);\r\n\r\n            // If this module has a source channel, indicate that this module has been closed by disconnecting it\r\n            if (this.core.source.channel) {\r\n                await this.core.source.channel.disconnectDescendant(\r\n                    this.getPath().toString(true),\r\n                    this.core.source.request.type\r\n                );\r\n            }\r\n\r\n            // Dispose the channel receiver properly\r\n            await this.core.channelReceiver.close();\r\n\r\n            // Dispose the settings\r\n            await this.getSettings().dispose();\r\n\r\n            // Tell the registry that this module no longer exists\r\n            await Registry._deregisterModuleInstance(this);\r\n\r\n            // Indicate that deregistering has finished\r\n            this.core.registration.registered.false(true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Request modules to handle the passed data and establish a connection with these modules\r\n     * @param  {Registry~Request} request - The information on how to handle the data\r\n     * @returns {Promise<ChannelSender[]>} The channel(s) that have been created to answer the request\r\n     * @async\r\n     * @public\r\n     */\r\n    async requestHandle(request) {\r\n        // Check if the module is not currently deregistering, if it is, throw an error\r\n        if (this.core.registration.registered.turningFalse())\r\n            throw Error(\"Module is currently deregistering\");\r\n\r\n        // Check if the module is currently not registered\r\n        if (this.core.registration.registered.false()) {\r\n            // Wait for the module to finish registering\r\n            await this.__register();\r\n\r\n            // Check if the module is currently registering\r\n        } else if (this.core.registration.registered.turningTrue()) {\r\n            // Wait for th emodule to finish regestering\r\n            await this.__onRegister();\r\n        }\r\n\r\n        // If no extra methods have been assigned to the request, assign it an empty object\r\n        if (!request.methods) request.methods = {};\r\n\r\n        // Set this module to be the source of the request\r\n        request.source = this;\r\n\r\n        // If this module has already made a request for this type, return those channels instead\r\n        if (this.core.handlers[request.type])\r\n            return this.core.handler[request.type].channels;\r\n\r\n        // Create a subchannel in this channel receiver to handle received data from the requested handlers\r\n        this.core.channelReceiver.createSubChannel(\r\n            request.type,\r\n            request.methods\r\n        );\r\n\r\n        // Send the request to the registry and receive its created channels\r\n        const channels = await Registry.requestHandle(request);\r\n\r\n        // Store the created handlers locally\r\n        this.core.handlers[request.type] = {\r\n            request: request,\r\n            channels: channels instanceof Array ? channels : [channels], // Make sure it is an array of channels\r\n        };\r\n\r\n        // Return the received channels\r\n        return channels;\r\n    }\r\n}\r\n"]}