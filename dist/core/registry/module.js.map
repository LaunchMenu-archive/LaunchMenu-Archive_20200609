{"version":3,"sources":["../../../src/core/registry/module.js"],"names":["Module","constructor","request","canBeDirectlyInstantiated","registerPromiseResolve","registerPromise","resolve","reject","core","registration","registered","BooleanProcess","initPromise","handlers","byType","byPath","source","__register","Error","false","turningTrue","serializationData","requestPath","RequestPath","augmentPath","getClass","modulePath","Registry","_registerModuleInstance","uniqueID","promises","push","ChannelHandler","createReceiver","toString","__createChannelMethods","then","receiver","channelReceiver","_broadCastProcessChange","createSender","type","channel","SettingsHandler","createModuleSettings","getConfig","settings","concat","__loadHandlers","all","true","__deserialize","__init","_broadCastDisabled","_registerModuleInstanceCompleted","forEach","handlerType","map","handler","channels","index","channelData","receiverPromise","mappedHandler","method","__onRegister","ctch","catch","onInit","getPath","__proto__","config","getSource","getRequest","_isEmbeded","getSettings","__serialize","data","getModuleID","ID","serializedHandlers","embedGUI","_getChannelIdentifier","moveTo","moduleLocation","location","dispose","WindowHandler","openModuleInstance","__getMethods","regexFilter","output","nextProto","prototype","proto","varName","variable","isChannelMethod","Function","test","methods","methodName","__proxyChannelFunction","close","event","disconnectDescendant","__disconnectDescendant","apply","func","senderID","sender","filter","_getID","length","fully","turningFalse","_deregisterModuleInstance","channelDisposalPromises","requestHandle","createSubChannel","_normalizeHandleRequest","Array","use"],"mappings":"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","file":"module.js","sourcesContent":["import ChannelHandler from \"../communication/channel/channelHandler\";\r\nimport WindowHandler from \"../window/windowHandler\";\r\nimport SettingsHandler from \"../communication/data/settings/settingsHandler\";\r\nimport Registry from \"./registry\";\r\nimport RequestPath from \"./requestPath/requestPath\";\r\nimport BooleanProcess from \"../utils/booleanProcess\";\r\n\r\nexport default class Module {\r\n    /**\r\n     * Create a module instance which is the core building block for LM\r\n     * @param {Request} request - The request that caused this module to be instantiated\r\n     * @param {boolean} canBeDirectlyInstantiated - Whether or not this module should be instantiatable without a request\r\n     * @constructs Module\r\n     * @public\r\n     */\r\n    constructor(request, canBeDirectlyInstantiated) {\r\n        // Create the promise that gets resolved on registration\r\n        let registerPromiseResolve = null;\r\n        const registerPromise = new Promise((resolve, reject) => {\r\n            registerPromiseResolve = resolve;\r\n        });\r\n\r\n        // Create the core data of the module\r\n        this.core = {\r\n            registration: {\r\n                registered: new BooleanProcess(0),\r\n                registerPromise: registerPromise,\r\n                registerPromiseResolve: registerPromiseResolve,\r\n            },\r\n            initPromise: registerPromise, // Other methods may build upon this promise\r\n            handlers: {\r\n                byType: {},\r\n                byPath: {},\r\n            },\r\n            source: {},\r\n        };\r\n\r\n        // Check if the module was instanciated with a request\r\n        if (request) {\r\n            // Store the request\r\n            this.core.source = {\r\n                request: request,\r\n            };\r\n\r\n            // Register the module in the registry\r\n            this.__register();\r\n        } else if (!canBeDirectlyInstantiated) {\r\n            // Throw an error if this module was instanciated without a request but isn't allowed to\r\n            throw Error(\r\n                \"This module can only be instantiated from a handle request\"\r\n            );\r\n        } else {\r\n            this.core.initPromise = Promise.resolve();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Registers the module if it wasn't registered already\r\n     * @returns {Module} A reference to itself\r\n     * @async\r\n     * @private\r\n     */\r\n    async __register() {\r\n        // Chech if the module is currently unregistered\r\n        if (this.core.registration.registered.false()) {\r\n            // Indicate that we are now in the process of registering the moduke\r\n            this.core.registration.registered.turningTrue(true);\r\n\r\n            // Get the module source\r\n            const source = this.core.source;\r\n\r\n            // Check if the source contains a request that instanciated it\r\n            if (source.request) {\r\n                // Store the serializationData if present\r\n                const serializationData = source.request.serializationData;\r\n\r\n                // Store the requestPath to this module by agumenting the request's requestPath by this module\r\n                const requestPath = new RequestPath(source.request.source);\r\n                source.requestPath = requestPath.augmentPath(\r\n                    this.getClass().modulePath,\r\n                    0\r\n                );\r\n\r\n                // Check if the request provided a 'unique' ID that should be used\r\n                if (serializationData) {\r\n                    // If there a uniqueID was provided, this means an already existing module is being moved\r\n                    // Register this module in the registry, and make use of this previously defined ID\r\n                    await Registry._registerModuleInstance(\r\n                        this,\r\n                        serializationData.uniqueID\r\n                    );\r\n                } else {\r\n                    // Register this module in the registry (which will automatically assign a unique module ID)\r\n                    await Registry._registerModuleInstance(this);\r\n                }\r\n\r\n                let promises = [];\r\n\r\n                // Create a channel receiver that can be used to receive messages from other modules\r\n                promises.push(\r\n                    ChannelHandler.createReceiver(\r\n                        source.requestPath.toString(true),\r\n                        this.__createChannelMethods()\r\n                    )\r\n                        .then(receiver => {\r\n                            // Store the channel receiver\r\n                            this.core.channelReceiver = receiver;\r\n\r\n                            // Forward the receiver\r\n                            return receiver;\r\n                        })\r\n                        .then(receiver => {\r\n                            // Check if this receiver is the receiver for a previously defined channel\r\n                            if (serializationData) {\r\n                                // If it is, notify the process ID change\r\n                                return receiver._broadCastProcessChange();\r\n                            }\r\n                        })\r\n                );\r\n\r\n                // Create a channel sender to the module that requested this module\r\n                promises.push(\r\n                    ChannelHandler.createSender(\r\n                        source.request.source,\r\n                        source.request.type,\r\n                        source.requestPath.toString(true)\r\n                    ).then(channel => {\r\n                        // Store the channel sender\r\n                        source.channel = channel;\r\n                    })\r\n                );\r\n\r\n                // Load the settings of the module\r\n                promises.push(\r\n                    SettingsHandler.createModuleSettings(\r\n                        source.requestPath,\r\n                        this.getClass().getConfig().settings || {}\r\n                    ).then(settings => {\r\n                        // Store the settings\r\n                        this.core.settings = settings;\r\n                    })\r\n                );\r\n\r\n                // Setup any handlers if provided in the serializationData\r\n                if (serializationData) {\r\n                    promises = promises.concat(\r\n                        this.__loadHandlers(serializationData)\r\n                    );\r\n                }\r\n\r\n                // Wait for all to finish\r\n                await Promise.all(promises);\r\n\r\n                // Indicate that registering has finished and resolve the promise\r\n                this.core.registration.registered.true(true);\r\n                this.core.registration.registerPromiseResolve(this);\r\n\r\n                // Check if there is serializationData, I.E. if this module moved\r\n                if (serializationData) {\r\n                    // If so, load this data\r\n                    this.__deserialize(serializationData);\r\n\r\n                    // and reenable the channel once the module is initialised\r\n                    this.__init(() => {\r\n                        this.core.channelReceiver._broadCastDisabled(false);\r\n                    });\r\n                }\r\n\r\n                // Notify the registry that the module finished setup\r\n                this.__init(() => {\r\n                    Registry._registerModuleInstanceCompleted(this);\r\n                }, \"4\");\r\n            } else {\r\n                // If the module was not instantiated by a request, the request path is simply this module path\r\n                source.requestPath = new RequestPath(\r\n                    this.getClass().modulePath,\r\n                    0\r\n                );\r\n\r\n                // Register this module in the registry (which will automatically assign a unique module ID)\r\n                await Registry._registerModuleInstance(this);\r\n\r\n                // Create a channel receiver that can be used to receive message from other modules\r\n                this.core.channelReceiver = await ChannelHandler.createReceiver(\r\n                    source.requestPath.toString(true),\r\n                    this.__createChannelMethods()\r\n                );\r\n\r\n                // Indicate that registering has finished and resolve th epromise\r\n                this.core.registration.registered.true(true);\r\n                this.core.registration.registerPromiseResolve(this);\r\n\r\n                // Notify the registry that the module finished setup\r\n                this.__init(() => {\r\n                    Registry._registerModuleInstanceCompleted(this);\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets up receivers for handlers defined in the serialization data of a module instance\r\n     * @param {object} serializationData - The data to extract the handlers from\r\n     * @returns {Promise[]} A list of promises that resolve when all channels are created\r\n     * @async\r\n     * @private\r\n     */\r\n    __loadHandlers(serializationData) {\r\n        // The promises to return\r\n        const promises = [];\r\n\r\n        // Go through all types of handlers\r\n        Object.keys(serializationData.handlers).forEach(handlerType => {\r\n            // Get the handlers for this handler type\r\n            const handlers = serializationData.handlers[handlerType];\r\n\r\n            // Map the handlers and store them\r\n            this.core.handlers.byType[handlerType] = handlers.map(handler => {\r\n                // Create an object and store the channels afterwards\r\n                return {\r\n                    request: handler.request,\r\n                    channels: [],\r\n                };\r\n            });\r\n\r\n            // Create channel receivers for all handlers\r\n            handlers.forEach((handler, index) => {\r\n                // Get the channels of the handler\r\n                handler.channels.forEach(channelData => {\r\n                    // Create a receiver for the channel\r\n                    const receiverPromise = ChannelHandler.createSender(\r\n                        channelData\r\n                    ).then(receiver => {\r\n                        // Get the mapped handler, and store it in it\r\n                        const mappedHandler = this.core.handlers.byType[\r\n                            handlerType\r\n                        ][index];\r\n\r\n                        // Add the channel\r\n                        mappedHandler.channels.push(receiver);\r\n                    });\r\n\r\n                    // Store the promise in the promises we want to await\r\n                    promises.push(receiverPromise);\r\n                });\r\n            });\r\n        });\r\n\r\n        // Return the promises that have to be waited for\r\n        return promises;\r\n    }\r\n\r\n    /**\r\n     * Adds a function to run before indicating that initialisation has finished\r\n     * @param {function} method - The function to run (may be async)\r\n     * @returns {Promise} A promise that resolves when the module is initialised\r\n     * @private\r\n     */\r\n    __init(method) {\r\n        // Add the method to the chain and return the chain\r\n        return (this.core.initPromise = this.core.initPromise.then(method));\r\n    }\r\n\r\n    /**\r\n     * Adds a then and catch function to the registration completion promise\r\n     * @param {function} [then] - The function to run when registration has finished\r\n     * @param {function} [ctch] - The function to run if something goes wrong during registration\r\n     * @returns {Promise<Module>} A reference to this module instance\r\n     * @async\r\n     * @private\r\n     */\r\n    __onRegister(then, ctch) {\r\n        return this.core.registration.registerPromise.then(then).catch(ctch);\r\n    }\r\n\r\n    /**\r\n     * Adds a then and catch function to the initialization completion promise\r\n     * @param {function} [then] - The function to run when initialization has finished\r\n     * @param {function} [ctch] - The function to run if something goes wrong during initialization\r\n     * @returns {Promise<Module>} A reference to this module instance\r\n     * @async\r\n     * @private\r\n     */\r\n    onInit(then, ctch) {\r\n        return this.core.initPromise.then(then).catch(ctch);\r\n    }\r\n\r\n    // Registry related methods\r\n    /**\r\n     * Returns the path to this module instance\r\n     * @returns {string} The path to this module instance\r\n     * @public\r\n     */\r\n    toString() {\r\n        // Get the request path and get its unique string representation\r\n        return this.getPath().toString(true);\r\n    }\r\n\r\n    /**\r\n     * Returns the class of this module instance\r\n     * @returns {Class<Module>} The class of this module instance\r\n     * @public\r\n     */\r\n    getClass() {\r\n        // Get the class out of this object instance\r\n        return this.__proto__.constructor;\r\n    }\r\n\r\n    /**\r\n     * Returns the requestPath that created this module instance\r\n     * @returns {RequestPath} The request path\r\n     * @public\r\n     */\r\n    getPath() {\r\n        // Get the channel sender that has been created in the __register method\r\n        return this.core.source.requestPath;\r\n    }\r\n\r\n    /**\r\n     * Returns the config file of this class\r\n     * @returns {Config} The module config\r\n     * @public\r\n     */\r\n    static getConfig() {\r\n        // Get the config that has been assigned by the registry when loading the module class\r\n        return this.config;\r\n    }\r\n\r\n    /**\r\n     * Returns the path to this module class\r\n     * @returns {string} The path to this module class\r\n     * @public\r\n     */\r\n    static getPath() {\r\n        // Get the modulePath that has been assigned by the registry when loading the module class\r\n        return this.modulePath;\r\n    }\r\n\r\n    /**\r\n     * Returns the path to this module class\r\n     * @returns {string} The path to this module class\r\n     * @public\r\n     */\r\n    static toString() {\r\n        return this.getPath();\r\n    }\r\n\r\n    /**\r\n     * Returns the channelSender to communicate with the module that instanciated this module\r\n     * @returns {ChannelSender} The channelSender to communicate with the module\r\n     * @public\r\n     */\r\n    getSource() {\r\n        return this.core.source.channel;\r\n    }\r\n\r\n    /**\r\n     * Returns the request that created this module instance\r\n     * @returns {Registry~Request} The request that was passed with this module's instanciation\r\n     * @public\r\n     */\r\n    getRequest() {\r\n        return this.core.source.request;\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not this module is embeded in another (only applicable to GUI modules)\r\n     * @returns {boolean} Whether or not the module is embded GUI\r\n     * @protected\r\n     */\r\n    _isEmbeded() {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns the settings of the module\r\n     * @returns {ModuleSettings} The settings that apply to this module instance\r\n     * @public\r\n     */\r\n    getSettings() {\r\n        return this.core.settings;\r\n    }\r\n\r\n    // Module instance transfer related methods\r\n    /**\r\n     * Serializes the module instance such that it can be transfered to another window\r\n     * @returns {Object} All the relevant data in order to rebuild the module instance\r\n     * @private\r\n     */\r\n    __serialize() {\r\n        // The base serialization data to return\r\n        const data = {\r\n            uniqueID: this.getPath().getModuleID().ID,\r\n            handlers: {},\r\n        };\r\n\r\n        // Go through all handlers and map them\r\n        Object.keys(this.core.handlers.byType).forEach(handlerType => {\r\n            const handlers = this.core.handlers.byType[handlerType];\r\n\r\n            // Map the handler to something that can be transferred\r\n            const serializedHandlers = [];\r\n            handlers.forEach(handler => {\r\n                // Add the handler to the serialized handler if it is not an embeded request\r\n                if (!handler.request.embedGUI)\r\n                    serializedHandlers.push({\r\n                        request: handler.request,\r\n                        channels: handler.channels.map(channel =>\r\n                            channel._getChannelIdentifier()\r\n                        ),\r\n                    });\r\n            });\r\n\r\n            // Store the handler in data\r\n            data.handlers[handlerType] = serializedHandlers;\r\n        });\r\n\r\n        // Return the gathered serialization data\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Deserializes the data in order to restore the module instance to a previously captured state\r\n     * @param {Object} data - The data obtained through the serialize method\r\n     * @returns {undefined}\r\n     * @private\r\n     */\r\n    __deserialize(data) {}\r\n\r\n    /**\r\n     * Moves a module from one section/window to another, will destroy this object and return a channelSender to the new instance\r\n     * @param {WindowHandler~moduleLocation} moduleLocation - The location that the module should be moved to\r\n     * @returns {Promise<ChannelSender>} The channelSender to communicate with the new module instance\r\n     * @public\r\n     * @async\r\n     */\r\n    async moveTo(moduleLocation) {\r\n        // Get the data that defines this module instance\r\n        const data = this.__serialize();\r\n\r\n        // Create a special request that contains this serialization data\r\n        const request = this.core.source.request;\r\n        request.serializationData = data;\r\n\r\n        // Modify the request to contain embed if the location does\r\n        if (location.embedGUI) request.embedGUI = true;\r\n\r\n        // Dispose the module instance partially\r\n        await this.dispose(false);\r\n\r\n        // Open this same module at the specified location\r\n        return WindowHandler.openModuleInstance(\r\n            moduleLocation,\r\n            request,\r\n            this.getClass()\r\n        );\r\n    }\r\n\r\n    // Channel related methods\r\n    /**\r\n     * Gets all the methods of this module that are available for channels\r\n     * @param {Regex} regexFilter - The filter to apply to determine whether or not the method should be returned\r\n     * @returns {Object} All methods indexed by name\r\n     * @private\r\n     */\r\n    __getMethods(regexFilter) {\r\n        // Set up an object to store the output methods\r\n        const output = {};\r\n\r\n        // Go through the inheritence chain\r\n        let nextProto = this.__proto__;\r\n        while (nextProto && nextProto != Module.prototype) {\r\n            // Get the prototype of which to get the methods\r\n            const proto = nextProto;\r\n            nextProto = proto.__proto__;\r\n\r\n            // Go through all methods in the class\r\n            Object.getOwnPropertyNames(proto).forEach(varName => {\r\n                // Get the variable\r\n                const variable = this.__proto__[varName];\r\n\r\n                // Check if the variable is a method that should be available for the chanenl\r\n                const isChannelMethod =\r\n                    variable instanceof Function &&\r\n                    regexFilter.test(varName) &&\r\n                    !output[varName];\r\n\r\n                if (isChannelMethod) {\r\n                    // If the method should be avaiable, remove the prefix and store it in the output\r\n                    output[varName] = this.__proto__[varName];\r\n                }\r\n            });\r\n        }\r\n\r\n        // Return the output\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     * Creates all methods to interact with this module over a channel\r\n     * @returns {Object} All methods indexed by name\r\n     * @private\r\n     */\r\n    __createChannelMethods() {\r\n        // Set up an object to store the output methods\r\n        const output = {};\r\n\r\n        // Get the methpds that are available for the channel\r\n        const methods = this.__getMethods(/^\\$/);\r\n\r\n        // Go through all the methods to correctly map the channel data\r\n        Object.keys(methods).forEach(methodName => {\r\n            // Get the method from its name\r\n            const method = methods[methodName];\r\n\r\n            // Apply the event followed by the channel data as arguments for the method\r\n            output[methodName] = this.__proxyChannelFunction(method);\r\n        });\r\n\r\n        // Set up a close method for the channel\r\n        output.close = event => {\r\n            return this.dispose();\r\n        };\r\n\r\n        // Set up a disconnectDescendant method for the channel that will detach a descendant from itself\r\n        output.disconnectDescendant = event => {\r\n            return this.__disconnectDescendant.apply(this, event.data);\r\n        };\r\n\r\n        // Return the output\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     * Proxies the function such that the sender channel is inserted if available, and data comes as arguments\r\n     * @param {function} func - The function that has to be proxied\r\n     * @returns {function} The wrapper (proxy) around the provided function\r\n     * @async\r\n     * @private\r\n     */\r\n    __proxyChannelFunction(func) {\r\n        return event => {\r\n            // Get the senderID\r\n            const senderID = event.senderID;\r\n\r\n            // Check if the sender is available in our handlers\r\n            if (this.core.handlers.byPath[senderID]) {\r\n                // If so, store the sender as a channel\r\n                event.sender = this.core.handlers.byPath[senderID];\r\n            }\r\n\r\n            // Forward the data\r\n            return func.apply(this, [event].concat(event.data));\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Disconnects a module from this module (But doesn't dispose it)\r\n     * @param {RequestPath} requestPath - The request path for the module to disconnect\r\n     * @param {string} type - The type of request that the module was instiated for\r\n     * @returns {undefined}\r\n     * @private\r\n     */\r\n    __disconnectDescendant(requestPath, type) {\r\n        // Get the handlers for this request type if available\r\n        const handlers = this.core.handlers.byType[type];\r\n        if (handlers) {\r\n            // Go through all handlers\r\n            handlers.forEach(handler => {\r\n                // Extract the channels from this handler\r\n                const channels = handler.channels;\r\n\r\n                // Remove the channel that matches the requestPath\r\n                handler.channels = channels.filter(channel => {\r\n                    return channel._getID() != requestPath;\r\n                });\r\n\r\n                // Remove the handler if all channels have been closed\r\n                if (handler.channels.length == 0)\r\n                    delete this.core.handlers.byType[type];\r\n            });\r\n        }\r\n\r\n        // Remove the handler by path from the object\r\n        delete this.core.handlers.byPath[requestPath.toString(true)];\r\n    }\r\n\r\n    /**\r\n     * Disposes this module entirely, also getting rid of its connections to other modules\r\n     * @param {boolean} [fully=true] - Whether we are also disposing descendants, and indicate that we disposed this module to the parent\r\n     * @returns {Promise} The promise that resolves once disposal has completed\r\n     * @async\r\n     * @public\r\n     */\r\n    async dispose(fully = true) {\r\n        // Check if the module is not still registering\r\n        if (this.core.registration.registered.turningTrue())\r\n            throw Error(\"Module is still registering\");\r\n\r\n        // Check if the module is registered in the first place\r\n        if (this.core.registration.registered.true()) {\r\n            // Indicate that the module is now in the process of deregestering\r\n            this.core.registration.registered.turningFalse(true);\r\n\r\n            // If we aren't fully disposing the module, temporarly disable traffic on the channel receiver\r\n            if (!fully)\r\n                await this.core.channelReceiver._broadCastDisabled(true);\r\n\r\n            // Tell the registry that this module no longer exists\r\n            await Registry._deregisterModuleInstance(this);\r\n\r\n            // Object to track all the promises of modules being disposed\r\n            const channelDisposalPromises = [];\r\n\r\n            // Go through all the handlers to dispose them\r\n            Object.keys(this.core.handlers.byType).forEach(type => {\r\n                // Get the handlers of this type\r\n                const handlers = this.core.handlers.byType[type];\r\n\r\n                // Go through all handlers\r\n                handlers.forEach(handler => {\r\n                    // Get the channels and request of the handler\r\n                    const channels = handler.channels;\r\n                    const request = handler.request;\r\n\r\n                    // Either dispose the module if we want to fully dispose or it is an embeded module\r\n                    if (fully || request.embedGUI) {\r\n                        // Close all the handle modules and track their promises\r\n                        channelDisposalPromises.push.apply(\r\n                            channelDisposalPromises,\r\n                            channels.map(channel => {\r\n                                return channel.close();\r\n                            })\r\n                        );\r\n                    }\r\n\r\n                    // Dispose the channel senders themselves\r\n                    channels.forEach(channel => {\r\n                        channel.dispose();\r\n                    });\r\n                });\r\n            });\r\n\r\n            // Wait for all modules to finish disposing\r\n            await Promise.all(channelDisposalPromises);\r\n\r\n            // If this module has a source channel, indicate that this module has been closed by disconnecting it\r\n            if (this.core.source.channel && fully) {\r\n                await this.core.source.channel.disconnectDescendant(\r\n                    this.getPath().toString(true),\r\n                    this.core.source.request.type\r\n                );\r\n            }\r\n\r\n            // Dispose the sender to the source\r\n            await this.getSource().dispose();\r\n\r\n            // Dispose the channel receiver properly\r\n            await this.core.channelReceiver.dispose();\r\n\r\n            // Dispose the settings\r\n            await this.getSettings().dispose();\r\n\r\n            // Indicate that deregistering has finished\r\n            this.core.registration.registered.false(true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Request modules to handle the passed data and establish a connection with these modules\r\n     * @param  {Registry~Request} request - The information on how to handle the data\r\n     * @returns {Promise<ChannelSender[]>} The channel(s) that have been created to answer the request\r\n     * @async\r\n     * @public\r\n     */\r\n    async requestHandle(request) {\r\n        // Check if the module is not currently deregistering, if it is, throw an error\r\n        if (this.core.registration.registered.turningFalse())\r\n            throw Error(\"Module is currently deregistering\");\r\n\r\n        // Check if the module is currently not registered\r\n        if (this.core.registration.registered.false()) {\r\n            // Wait for the module to finish registering\r\n            await this.__register();\r\n\r\n            // Check if the module is currently registering\r\n        } else if (this.core.registration.registered.turningTrue()) {\r\n            // Wait for th emodule to finish regestering\r\n            await this.__onRegister();\r\n        }\r\n\r\n        // If no extra methods have been assigned to the request, assign it an empty object\r\n        if (!request.methods) request.methods = {};\r\n\r\n        // Map the methods such that it replaces senderID by the sender channel\r\n        Object.keys(request.methods).forEach(methodName => {\r\n            request.methods[methodName] = this.__proxyChannelFunction(\r\n                request.methods[methodName]\r\n            );\r\n        });\r\n\r\n        // Set this module to be the source of the request\r\n        request.source = this;\r\n\r\n        // Create a subchannel in this channel receiver to handle received data from the requested handlers\r\n        this.core.channelReceiver.createSubChannel(\r\n            request.type,\r\n            request.methods\r\n        );\r\n\r\n        // Create an object for the return channels\r\n        let channels;\r\n\r\n        // If this module has already made a request for this type, return those channels instead, TODO: only return if the request data is equivalent\r\n        if (\r\n            this.core.handlers.byType[request.type] &&\r\n            this.core.handlers.byType[request.type][0]\r\n        ) {\r\n            // Get the channels that were already stored\r\n            channels = this.core.handlers.byType[request.type][0].channels;\r\n\r\n            // Despite not really requesting the modules, we should still normalize the request\r\n            Registry._normalizeHandleRequest(request);\r\n        } else {\r\n            // Send the request to the registry and receive its created channels\r\n            channels = await Registry.requestHandle(request);\r\n\r\n            // Make sure it is an array of channels\r\n            channels = channels instanceof Array ? channels : [channels];\r\n\r\n            // Store the created handlers locally\r\n            // Store them by type\r\n            if (!this.core.handlers.byType[request.type])\r\n                this.core.handlers.byType[request.type] = [];\r\n            this.core.handlers.byType[request.type].push({\r\n                request: request,\r\n                channels: channels,\r\n            });\r\n\r\n            // Store them by request path\r\n            channels.forEach(channel => {\r\n                this.core.handlers.byPath[channel._getID()] = channel;\r\n            });\r\n        }\r\n\r\n        // Check whether a single channel should be returned, or an array\r\n        if (request.use == \"one\") {\r\n            // Return a single received channel\r\n            return channels[0];\r\n        } else {\r\n            // Return all the received channels\r\n            return channels;\r\n        }\r\n    }\r\n}\r\n"]}