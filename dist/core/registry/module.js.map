{"version":3,"sources":["../../../src/core/registry/module.js"],"names":["Module","constructor","request","canBeDirectlyInstantiated","registerPromiseResolve","registerPromise","resolve","reject","core","registration","registered","BooleanProcess","initPromise","handlers","source","__register","error","Error","false","turningTrue","requestPath","RequestPath","augmentPath","getClass","modulePath","ID","Registry","_registerModuleInstance","channelReceiver","ChannelHandler","createReceiver","toString","__createChannelMethods","channel","createSender","type","true","__init","method","then","__onRegister","ctch","catch","onInit","__proto__","getPath","__getMethods","output","channelMethodRegex","nextProto","prototype","proto","forEach","varName","variable","Function","test","replace","methods","methodName","event","apply","concat","data","close","dispose","closeDescendant","__disconnectDescendant","handler","channels","Array","filter","_getID","length","turningFalse","channelDisposalPromises","map","push","all","_deregisterModuleInstance","requestHandle","createSubChannel"],"mappings":"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","file":"module.js","sourcesContent":["import ChannelHandler from \"../communication/channel/channelHandler\";\r\nimport Registry from \"./registry\";\r\nimport RequestPath from \"./requestPath\";\r\nimport BooleanProcess from \"../utils/booleanProcess\";\r\n\r\nexport default class Module {\r\n    /**\r\n     * Create a module instance which is the core building block for LM\r\n     * @param {Request} request - The request that caused this module to be instantiated\r\n     * @param {boolean} canBeDirectlyInstantiated - Whether or not this module should be instantiatable without a request\r\n     * @constructs Module\r\n     * @public\r\n     */\r\n    constructor(request, canBeDirectlyInstantiated) {\r\n        let registerPromiseResolve = null;\r\n        const registerPromise = new Promise((resolve, reject) => {\r\n            registerPromiseResolve = resolve;\r\n        });\r\n        this.core = {\r\n            registration: {\r\n                registered: new BooleanProcess(0),\r\n                registerPromise: registerPromise,\r\n                registerPromiseResolve: registerPromiseResolve,\r\n            },\r\n            initPromise: registerPromise, // Other methods may build upon this promise\r\n            handlers: {},\r\n            source: {},\r\n        };\r\n\r\n        if (request) {\r\n            this.core.source = {\r\n                request: request,\r\n            };\r\n            this.__register();\r\n        } else if (!canBeDirectlyInstantiated) {\r\n            const error = Error(\r\n                \"This module can only be instantiated from a handle request\"\r\n            );\r\n            reject(error);\r\n            throw error;\r\n        }\r\n    }\r\n    /**\r\n     * Registers the module if it wasn't registered already\r\n     * @returns {Module} A reference to itself\r\n     * @async\r\n     * @private\r\n     */\r\n    async __register() {\r\n        if (this.core.registration.registered.false()) {\r\n            this.core.registration.registered.turningTrue(true);\r\n            const source = this.core.source;\r\n            if (source.request) {\r\n                const requestPath = new RequestPath(source.request.source);\r\n                source.requestPath = requestPath.augmentPath(\r\n                    this.getClass().modulePath,\r\n                    0\r\n                );\r\n                const ID = await Registry._registerModuleInstance(this);\r\n\r\n                this.core.channelReceiver = await ChannelHandler.createReceiver(\r\n                    source.requestPath.toString(true),\r\n                    this.__createChannelMethods()\r\n                );\r\n                source.channel = await ChannelHandler.createSender(\r\n                    source.request.source,\r\n                    source.request.type,\r\n                    source.requestPath.toString(true)\r\n                );\r\n\r\n                this.core.registration.registered.true(true);\r\n                this.core.registration.registerPromiseResolve(this);\r\n            } else {\r\n                source.requestPath = new RequestPath(\r\n                    this.getClass().modulePath\r\n                );\r\n                const ID = await Registry._registerModuleInstance(this);\r\n                this.core.channelReceiver = await ChannelHandler.createReceiver(\r\n                    source.requestPath.toString(true),\r\n                    this.__createChannelMethods()\r\n                );\r\n                this.core.registration.registered.true(true);\r\n                this.core.registration.registerPromiseResolve(this);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a function to run before indicating that initialisation has finished\r\n     * @param {function} method - The function to run (may be async)\r\n     * @returns {Promise} A promise that resolves when the module is initialised\r\n     * @private\r\n     */\r\n    __init(method) {\r\n        return (this.core.initPromise = this.core.initPromise.then(method));\r\n    }\r\n\r\n    /**\r\n     * Adds a then and catch function to the registration completion promise\r\n     * @param {function} [then] - The function to run when registration has finished\r\n     * @param {function} [ctch] - The function to run if something goes wrong during registration\r\n     * @returns {Promise<Module>} A reference to this module instance\r\n     * @async\r\n     * @private\r\n     */\r\n    __onRegister(then, ctch) {\r\n        return this.core.registration.registerPromise.then(then).catch(ctch);\r\n    }\r\n\r\n    /**\r\n     * Adds a then and catch function to the initialization completion promise\r\n     * @param {function} [then] - The function to run when initialization has finished\r\n     * @param {function} [ctch] - The function to run if something goes wrong during initialization\r\n     * @returns {Promise<Module>} A reference to this module instance\r\n     * @async\r\n     * @private\r\n     */\r\n    onInit(then, ctch) {\r\n        return this.core.initPromise.then(then).catch(ctch);\r\n    }\r\n\r\n    // Registry related methods\r\n    /**\r\n     * Returns the path to this module class\r\n     * @returns {string} The path to this module class\r\n     * @public\r\n     */\r\n    toString() {\r\n        return this.getClass().toString();\r\n    }\r\n\r\n    /**\r\n     * Returns the class of this module instance\r\n     * @returns {Class<Module>} The class of this module instance\r\n     * @public\r\n     */\r\n    getClass() {\r\n        return this.__proto__.constructor;\r\n    }\r\n\r\n    /**\r\n     * Returns the requestPath that created this module instance\r\n     * @returns {RequestPath} The request path\r\n     * @public\r\n     */\r\n    getPath() {\r\n        return this.core.source.requestPath;\r\n    }\r\n\r\n    /**\r\n     * Returns the path to this module class\r\n     * @returns {string} The path to this module class\r\n     * @public\r\n     */\r\n    static getPath() {\r\n        return this.modulePath;\r\n    }\r\n\r\n    /**\r\n     * Returns the path to this module class\r\n     * @returns {string} The path to this module class\r\n     * @public\r\n     */\r\n    static toString() {\r\n        return this.getPath();\r\n    }\r\n\r\n    // Channel-related methods\r\n    /**\r\n     * Gets all the methods of this module that are not static\r\n     * @returns {Object} All methods indexed by name\r\n     * @private\r\n     */\r\n    __getMethods() {\r\n        const output = {};\r\n        const channelMethodRegex = /^\\$/g;\r\n        let nextProto = this.__proto__;\r\n        while (nextProto && nextProto != Module.prototype) {\r\n            const proto = nextProto;\r\n            nextProto = proto.__proto__;\r\n\r\n            Object.getOwnPropertyNames(proto).forEach(varName => {\r\n                const variable = this.__proto__[varName];\r\n                if (\r\n                    variable instanceof Function &&\r\n                    channelMethodRegex.test(varName) &&\r\n                    !output[varName]\r\n                ) {\r\n                    output[\r\n                        varName.replace(channelMethodRegex, \"\")\r\n                    ] = this.__proto__[varName];\r\n                }\r\n            });\r\n        }\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     * Creates all methods to interact with this module over a channel\r\n     * @returns {Object} All methods indexed by name\r\n     * @private\r\n     */\r\n    __createChannelMethods() {\r\n        const output = {};\r\n        const methods = this.__getMethods();\r\n        Object.keys(methods).forEach(methodName => {\r\n            const method = methods[methodName];\r\n            output[methodName] = event => {\r\n                return method.apply(this, [event].concat(event.data));\r\n            };\r\n        });\r\n        output.close = event => {\r\n            return this.dispose();\r\n        };\r\n        output.closeDescendant = event => {\r\n            return this.__disconnectDescendant.apply(this, event.data);\r\n        };\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     * Disconnects a module from this module (But doesn't dispose it)\r\n     * @param {RequestPath} requestPath - The request path for the module to disconnect\r\n     * @param {string} type - The type of request that the module was instiated for\r\n     * @returns {undefined}\r\n     * @private\r\n     */\r\n    __disconnectDescendant(requestPath, type) {\r\n        const handler = this.core.handlers[type];\r\n        if (handler) {\r\n            const channels = handler.channels;\r\n            if (channels instanceof Array) {\r\n                handler.channels = channels.filter(channel => {\r\n                    return channel._getID() != requestPath;\r\n                });\r\n\r\n                if (handler.channels.length == 0)\r\n                    delete this.core.handlers[type];\r\n            } else if (channels._getID() == requestPath) {\r\n                delete this.core.handlers[type];\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes this module entirely, also getting rid of its connections to other modules\r\n     * @returns {Promise} The promise that resolves once disposal has completed\r\n     * @async\r\n     * @public\r\n     */\r\n    async dispose() {\r\n        if (this.core.registration.registered.turningTrue())\r\n            throw Error(\"Module is still registering\");\r\n        if (this.core.registration.registered.true()) {\r\n            this.core.registration.registered.turningFalse(true);\r\n            const channelDisposalPromises = [];\r\n            Object.keys(this.core.handlers).forEach(type => {\r\n                const handler = this.core.handlers[type];\r\n                const channels = handler.channels;\r\n                if (channels instanceof Array) {\r\n                    channelDisposalPromises.concat(\r\n                        channels.map(channel => {\r\n                            return channel.close();\r\n                        })\r\n                    );\r\n                } else {\r\n                    channelDisposalPromises.push(channels.close());\r\n                }\r\n            });\r\n\r\n            await Promise.all(channelDisposalPromises);\r\n            if (this.core.source.channel) {\r\n                await this.core.source.channel.closeDescendant(\r\n                    this.getPath().toString(true),\r\n                    this.core.source.request.type\r\n                );\r\n            }\r\n\r\n            this.core.registration.registered.false(true);\r\n            await this.core.channelReceiver.close();\r\n\r\n            await Registry._deregisterModuleInstance(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Request modules to handle the passed data and establish a connection with these modules\r\n     * @param  {Registry~Request} request - The information on how to handle the data\r\n     * @returns {Promise<ChannelSender[]>} The channel(s) that have been created to answer the request\r\n     * @async\r\n     * @public\r\n     */\r\n    async requestHandle(request) {\r\n        if (this.core.registration.registered.turningFalse())\r\n            throw Error(\"Module is currently deregistering\");\r\n\r\n        if (this.core.registration.registered.false()) {\r\n            await this.__register();\r\n            // await this.__onRegister();\r\n        } else if (this.core.registration.registered.turningTrue()) {\r\n            await this.__onRegister();\r\n        }\r\n\r\n        if (!request.methods) request.methods = {};\r\n\r\n        request.source = this;\r\n\r\n        if (this.core.handlers[request.type])\r\n            return this.core.handler[request.type].channels;\r\n\r\n        this.core.channelReceiver.createSubChannel(\r\n            request.type,\r\n            request.methods\r\n        );\r\n        const channels = await Registry.requestHandle(request);\r\n        this.core.handlers[request.type] = {\r\n            request: request,\r\n            channels: channels,\r\n        };\r\n        return channels;\r\n    }\r\n}\r\n"]}