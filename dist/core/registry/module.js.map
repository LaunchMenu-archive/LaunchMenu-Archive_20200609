{"version":3,"sources":["../../../src/core/registry/module.js"],"names":["Module","constructor","request","canBeDirectlyInstantiated","registerPromiseResolve","registerPromise","resolve","reject","core","registration","registered","BooleanProcess","initPromise","handlers","source","__register","Error","false","turningTrue","requestPath","RequestPath","augmentPath","getClass","modulePath","Registry","_registerModuleInstance","promises","push","ChannelHandler","createReceiver","toString","__createChannelMethods","createSender","type","all","then","results","channelReceiver","channel","true","__init","method","__onRegister","ctch","catch","onInit","getPath","__proto__","getSource","__getMethods","regexFilter","output","nextProto","prototype","proto","forEach","varName","variable","isChannelMethod","Function","test","methods","methodName","event","apply","concat","data","close","dispose","disconnectDescendant","__disconnectDescendant","handler","channels","filter","_getID","length","turningFalse","channelDisposalPromises","map","_deregisterModuleInstance","requestHandle","createSubChannel","Array"],"mappings":"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","file":"module.js","sourcesContent":["import ChannelHandler from \"../communication/channel/channelHandler\";\r\nimport Registry from \"./registry\";\r\nimport RequestPath from \"./requestPath/requestPath\";\r\nimport BooleanProcess from \"../utils/booleanProcess\";\r\n\r\nexport default class Module {\r\n    /**\r\n     * Create a module instance which is the core building block for LM\r\n     * @param {Request} request - The request that caused this module to be instantiated\r\n     * @param {boolean} canBeDirectlyInstantiated - Whether or not this module should be instantiatable without a request\r\n     * @constructs Module\r\n     * @public\r\n     */\r\n    constructor(request, canBeDirectlyInstantiated) {\r\n        // Create the promise that gets resolved on registration\r\n        let registerPromiseResolve = null;\r\n        const registerPromise = new Promise((resolve, reject) => {\r\n            registerPromiseResolve = resolve;\r\n        });\r\n\r\n        // Create the core data of the module\r\n        this.core = {\r\n            registration: {\r\n                registered: new BooleanProcess(0),\r\n                registerPromise: registerPromise,\r\n                registerPromiseResolve: registerPromiseResolve,\r\n            },\r\n            initPromise: registerPromise, // Other methods may build upon this promise\r\n            handlers: {},\r\n            source: {},\r\n        };\r\n\r\n        // Check if the module was instanciated with a request\r\n        if (request) {\r\n            // Store the request\r\n            this.core.source = {\r\n                request: request,\r\n            };\r\n\r\n            // Register the module in the registry\r\n            this.__register();\r\n        } else if (!canBeDirectlyInstantiated) {\r\n            // Throw an error if this module was instanciated without a request but isn't allowed to\r\n            throw Error(\r\n                \"This module can only be instantiated from a handle request\"\r\n            );\r\n        } else {\r\n            this.core.initPromise = Promise.resolve();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Registers the module if it wasn't registered already\r\n     * @returns {Module} A reference to itself\r\n     * @async\r\n     * @private\r\n     */\r\n    async __register() {\r\n        // Chech if the module is currently unregistered\r\n        if (this.core.registration.registered.false()) {\r\n            // Indicate that we are now in the process of registering the moduke\r\n            this.core.registration.registered.turningTrue(true);\r\n\r\n            // Get the module source\r\n            const source = this.core.source;\r\n\r\n            // Check if the source contains a request that instanciated it\r\n            if (source.request) {\r\n                // Store the requestPath to this module by agumenting the request's requestPath by this module\r\n                const requestPath = new RequestPath(source.request.source);\r\n                source.requestPath = requestPath.augmentPath(\r\n                    this.getClass().modulePath,\r\n                    0\r\n                );\r\n\r\n                // Register this module in the registry (which will automatically assign a unique module ID)\r\n                await Registry._registerModuleInstance(this);\r\n\r\n                const promises = [];\r\n                // Create a channel receiver that can be used to receive messages from other modules\r\n                promises.push(\r\n                    ChannelHandler.createReceiver(\r\n                        source.requestPath.toString(true),\r\n                        this.__createChannelMethods()\r\n                    )\r\n                );\r\n\r\n                // Creat a channel sender to the module that requested this module\r\n                promises.push(\r\n                    ChannelHandler.createSender(\r\n                        source.request.source,\r\n                        source.request.type,\r\n                        source.requestPath.toString(true)\r\n                    )\r\n                );\r\n\r\n                // Wait for both to finish\r\n                await Promise.all(promises).then(results => {\r\n                    this.core.channelReceiver = results[0];\r\n                    source.channel = results[1];\r\n                });\r\n\r\n                // Indicate that registering has finished and resolve the promise\r\n                this.core.registration.registered.true(true);\r\n                this.core.registration.registerPromiseResolve(this);\r\n            } else {\r\n                // If the module was not instantiated by a request, the request path is simply this module path\r\n                source.requestPath = new RequestPath(\r\n                    this.getClass().modulePath,\r\n                    0\r\n                );\r\n\r\n                // Register this module in the registry (which will automatically assign a unique module ID)\r\n                await Registry._registerModuleInstance(this);\r\n\r\n                // Create a channel receiver that can be used to receive message from other modules\r\n                this.core.channelReceiver = await ChannelHandler.createReceiver(\r\n                    source.requestPath.toString(true),\r\n                    this.__createChannelMethods()\r\n                );\r\n\r\n                // Indicate that registering has finished and resolve th epromise\r\n                this.core.registration.registered.true(true);\r\n                this.core.registration.registerPromiseResolve(this);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a function to run before indicating that initialisation has finished\r\n     * @param {function} method - The function to run (may be async)\r\n     * @returns {Promise} A promise that resolves when the module is initialised\r\n     * @private\r\n     */\r\n    __init(method) {\r\n        // Add the method to the chain and return the chain\r\n        return (this.core.initPromise = this.core.initPromise.then(method));\r\n    }\r\n\r\n    /**\r\n     * Adds a then and catch function to the registration completion promise\r\n     * @param {function} [then] - The function to run when registration has finished\r\n     * @param {function} [ctch] - The function to run if something goes wrong during registration\r\n     * @returns {Promise<Module>} A reference to this module instance\r\n     * @async\r\n     * @private\r\n     */\r\n    __onRegister(then, ctch) {\r\n        return this.core.registration.registerPromise.then(then).catch(ctch);\r\n    }\r\n\r\n    /**\r\n     * Adds a then and catch function to the initialization completion promise\r\n     * @param {function} [then] - The function to run when initialization has finished\r\n     * @param {function} [ctch] - The function to run if something goes wrong during initialization\r\n     * @returns {Promise<Module>} A reference to this module instance\r\n     * @async\r\n     * @private\r\n     */\r\n    onInit(then, ctch) {\r\n        return this.core.initPromise.then(then).catch(ctch);\r\n    }\r\n\r\n    // Registry related methods\r\n    /**\r\n     * Returns the path to this module instance\r\n     * @returns {string} The path to this module instance\r\n     * @public\r\n     */\r\n    toString() {\r\n        // Get the request path and get its unique string representation\r\n        return this.getPath().toString(true);\r\n    }\r\n\r\n    /**\r\n     * Returns the class of this module instance\r\n     * @returns {Class<Module>} The class of this module instance\r\n     * @public\r\n     */\r\n    getClass() {\r\n        // Get the class out of this object instance\r\n        return this.__proto__.constructor;\r\n    }\r\n\r\n    /**\r\n     * Returns the requestPath that created this module instance\r\n     * @returns {RequestPath} The request path\r\n     * @public\r\n     */\r\n    getPath() {\r\n        // Get the channel sender that has been created in the __register method\r\n        return this.core.source.requestPath;\r\n    }\r\n\r\n    /**\r\n     * Returns the path to this module class\r\n     * @returns {string} The path to this module class\r\n     * @public\r\n     */\r\n    static getPath() {\r\n        // Get the modulePath that has been assigned by the registry when loading the module class\r\n        return this.modulePath;\r\n    }\r\n\r\n    /**\r\n     * Returns the path to this module class\r\n     * @returns {string} The path to this module class\r\n     * @public\r\n     */\r\n    static toString() {\r\n        return this.getPath();\r\n    }\r\n\r\n    /**\r\n     * Returns the channelSender to communicate with the module that instanciated this module\r\n     * @returns {ChannelSender} The channelSender to communicate with the module\r\n     * @public\r\n     */\r\n    getSource() {\r\n        return this.core.source.channel;\r\n    }\r\n\r\n    // Channel-related methods\r\n    /**\r\n     * Gets all the methods of this module that are available for channels\r\n     * @param {Regex} regexFilter - The filter to apply to determine whether or not the method should be returned\r\n     * @returns {Object} All methods indexed by name\r\n     * @private\r\n     */\r\n    __getMethods(regexFilter) {\r\n        // Set up an object to store the output methods\r\n        const output = {};\r\n\r\n        // Go through the inheritence chain\r\n        let nextProto = this.__proto__;\r\n        while (nextProto && nextProto != Module.prototype) {\r\n            // Get the prototype of which to get the methods\r\n            const proto = nextProto;\r\n            nextProto = proto.__proto__;\r\n\r\n            // Go through all methods in the class\r\n            Object.getOwnPropertyNames(proto).forEach(varName => {\r\n                // Get the variable\r\n                const variable = this.__proto__[varName];\r\n\r\n                // Check if the variable is a method that should be available for the chanenl\r\n                const isChannelMethod =\r\n                    variable instanceof Function &&\r\n                    regexFilter.test(varName) &&\r\n                    !output[varName];\r\n\r\n                if (isChannelMethod) {\r\n                    // If the method should be avaiable, remove the prefix and store it in the output\r\n                    output[varName] = this.__proto__[varName];\r\n                }\r\n            });\r\n        }\r\n\r\n        // Return the output\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     * Creates all methods to interact with this module over a channel\r\n     * @returns {Object} All methods indexed by name\r\n     * @private\r\n     */\r\n    __createChannelMethods() {\r\n        // Set up an object to store the output methods\r\n        const output = {};\r\n\r\n        // Get the methpds that are available for the channel\r\n        const methods = this.__getMethods(/^\\$/);\r\n\r\n        // Go through all the methods to correctly map the channel data\r\n        Object.keys(methods).forEach(methodName => {\r\n            // Get the method from its name\r\n            const method = methods[methodName];\r\n\r\n            // Apply the event followed by the channel data as arguments for the method\r\n            output[methodName] = event => {\r\n                return method.apply(this, [event].concat(event.data));\r\n            };\r\n        });\r\n\r\n        // Set up a close method for the channel\r\n        output.close = event => {\r\n            return this.dispose();\r\n        };\r\n\r\n        // Set up a disconnectDescendant method for the channel that will detach a descendant from itself\r\n        output.disconnectDescendant = event => {\r\n            return this.__disconnectDescendant.apply(this, event.data);\r\n        };\r\n\r\n        // Return the output\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     * Disconnects a module from this module (But doesn't dispose it)\r\n     * @param {RequestPath} requestPath - The request path for the module to disconnect\r\n     * @param {string} type - The type of request that the module was instiated for\r\n     * @returns {undefined}\r\n     * @private\r\n     */\r\n    __disconnectDescendant(requestPath, type) {\r\n        // Get the handler for this request type if available\r\n        const handler = this.core.handlers[type];\r\n        if (handler) {\r\n            // Extract the channels from this handler\r\n            const channels = handler.channels;\r\n\r\n            // Remove the channel that matches the requestPath\r\n            handler.channels = channels.filter(channel => {\r\n                return channel._getID() != requestPath;\r\n            });\r\n\r\n            // Remove the handler if all channels have been closed\r\n            if (handler.channels.length == 0) delete this.core.handlers[type];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes this module entirely, also getting rid of its connections to other modules\r\n     * @returns {Promise} The promise that resolves once disposal has completed\r\n     * @async\r\n     * @public\r\n     */\r\n    async dispose() {\r\n        // Check if the module is not still registering\r\n        if (this.core.registration.registered.turningTrue())\r\n            throw Error(\"Module is still registering\");\r\n\r\n        // Check if the module is registered in the first place\r\n        if (this.core.registration.registered.true()) {\r\n            // Indicate that the module is now in the process of deregestering\r\n            this.core.registration.registered.turningFalse(true);\r\n\r\n            // Object to track all the promises of modules being disposed\r\n            const channelDisposalPromises = [];\r\n\r\n            // Go through all the handlers to dispose them\r\n            Object.keys(this.core.handlers).forEach(type => {\r\n                // Get the handler and its channels\r\n                const handler = this.core.handlers[type];\r\n                const channels = handler.channels;\r\n\r\n                // Close all the handle modules and track their promises\r\n                channelDisposalPromises.push.apply(\r\n                    channelDisposalPromises,\r\n                    channels.map(channel => {\r\n                        return channel.close();\r\n                    })\r\n                );\r\n            });\r\n\r\n            // Wait for all modules to finish disposing\r\n            await Promise.all(channelDisposalPromises);\r\n\r\n            // If this module has a source channel, indicate that this module has been closed by disconnecting it\r\n            if (this.core.source.channel) {\r\n                await this.core.source.channel.disconnectDescendant(\r\n                    this.getPath().toString(true),\r\n                    this.core.source.request.type\r\n                );\r\n            }\r\n\r\n            // Dispose the channel receiver properly\r\n            await this.core.channelReceiver.close();\r\n\r\n            // Tell the registry that this module no longer exists\r\n            await Registry._deregisterModuleInstance(this);\r\n\r\n            // Indicate that deregistering has finished\r\n            this.core.registration.registered.false(true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Request modules to handle the passed data and establish a connection with these modules\r\n     * @param  {Registry~Request} request - The information on how to handle the data\r\n     * @returns {Promise<ChannelSender[]>} The channel(s) that have been created to answer the request\r\n     * @async\r\n     * @public\r\n     */\r\n    async requestHandle(request) {\r\n        // Check if the module is not currently deregistering, if it is, throw an error\r\n        if (this.core.registration.registered.turningFalse())\r\n            throw Error(\"Module is currently deregistering\");\r\n\r\n        // Check if the module is currently not registered\r\n        if (this.core.registration.registered.false()) {\r\n            // Wait for the module to finish registering\r\n            await this.__register();\r\n\r\n            // Check if the module is currently registering\r\n        } else if (this.core.registration.registered.turningTrue()) {\r\n            // Wait for th emodule to finish regestering\r\n            await this.__onRegister();\r\n        }\r\n\r\n        // If no extra methods have been assigned to the request, assign it an empty object\r\n        if (!request.methods) request.methods = {};\r\n\r\n        // Set this module to be the source of the request\r\n        request.source = this;\r\n\r\n        // If this module has already made a request for this type, return those channels instead\r\n        if (this.core.handlers[request.type])\r\n            return this.core.handler[request.type].channels;\r\n\r\n        // Create a subchannel in this channel receiver to handle received data from the requested handlers\r\n        this.core.channelReceiver.createSubChannel(\r\n            request.type,\r\n            request.methods\r\n        );\r\n\r\n        // Send the request to the registry and receive its created channels\r\n        const channels = await Registry.requestHandle(request);\r\n\r\n        // Store the created handlers locally\r\n        this.core.handlers[request.type] = {\r\n            request: request,\r\n            channels: channels instanceof Array ? channels : [channels], // Make sure it is an array of channels\r\n        };\r\n\r\n        // Return the received channels\r\n        return channels;\r\n    }\r\n}\r\n"]}