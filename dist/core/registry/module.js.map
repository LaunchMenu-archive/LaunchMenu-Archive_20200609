{"version":3,"sources":["../../../src/core/registry/module.js"],"names":["Module","constructor","request","canBeDirectlyInstantiated","registerPromiseResolve","registerPromise","resolve","reject","core","registration","registered","BooleanProcess","initPromise","handlers","source","__register","Error","false","turningTrue","requestPath","RequestPath","augmentPath","getClass","modulePath","Registry","_registerModuleInstance","channelReceiver","ChannelHandler","createReceiver","toString","__createChannelMethods","channel","createSender","type","true","__init","method","then","__onRegister","ctch","catch","onInit","getPath","__proto__","__getMethods","regexFilter","output","nextProto","prototype","proto","forEach","varName","variable","isChannelMethod","Function","test","replace","methods","methodName","event","apply","concat","data","close","dispose","disconnectDescendant","__disconnectDescendant","handler","channels","filter","_getID","length","turningFalse","channelDisposalPromises","push","map","all","_deregisterModuleInstance","requestHandle","createSubChannel","Array"],"mappings":"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","file":"module.js","sourcesContent":["import ChannelHandler from \"../communication/channel/channelHandler\";\r\nimport Registry from \"./registry\";\r\nimport RequestPath from \"./requestPath\";\r\nimport BooleanProcess from \"../utils/booleanProcess\";\r\n\r\nexport default class Module {\r\n    /**\r\n     * Create a module instance which is the core building block for LM\r\n     * @param {Request} request - The request that caused this module to be instantiated\r\n     * @param {boolean} canBeDirectlyInstantiated - Whether or not this module should be instantiatable without a request\r\n     * @constructs Module\r\n     * @public\r\n     */\r\n    constructor(request, canBeDirectlyInstantiated) {\r\n        // Create the promise that gets resolved on registration\r\n        let registerPromiseResolve = null;\r\n        const registerPromise = new Promise((resolve, reject) => {\r\n            registerPromiseResolve = resolve;\r\n        });\r\n\r\n        // Create the core data of the module\r\n        this.core = {\r\n            registration: {\r\n                registered: new BooleanProcess(0),\r\n                registerPromise: registerPromise,\r\n                registerPromiseResolve: registerPromiseResolve,\r\n            },\r\n            initPromise: registerPromise, // Other methods may build upon this promise\r\n            handlers: {},\r\n            source: {},\r\n        };\r\n\r\n        // Check if the module was instanciated with a request\r\n        if (request) {\r\n            // Store the request\r\n            this.core.source = {\r\n                request: request,\r\n            };\r\n\r\n            // Register the module in the registry\r\n            this.__register();\r\n        } else if (!canBeDirectlyInstantiated) {\r\n            // Throw an error if this module was instanciated without a request but isn't allowed to\r\n            throw Error(\r\n                \"This module can only be instantiated from a handle request\"\r\n            );\r\n        }\r\n    }\r\n    /**\r\n     * Registers the module if it wasn't registered already\r\n     * @returns {Module} A reference to itself\r\n     * @async\r\n     * @private\r\n     */\r\n    async __register() {\r\n        // Chech if the module is currently unregistered\r\n        if (this.core.registration.registered.false()) {\r\n            // Indicate that we are now in the process of registering the moduke\r\n            this.core.registration.registered.turningTrue(true);\r\n\r\n            // Get the module source\r\n            const source = this.core.source;\r\n\r\n            // Check if the source contains a request that instanciated it\r\n            if (source.request) {\r\n                // Store the requestPath to this module by agumenting the request's requestPath by this module\r\n                const requestPath = new RequestPath(source.request.source);\r\n                source.requestPath = requestPath.augmentPath(\r\n                    this.getClass().modulePath,\r\n                    0\r\n                );\r\n\r\n                // Register this module in the registry (which will automatically assign a unique module ID)\r\n                await Registry._registerModuleInstance(this);\r\n\r\n                // Create a channel receiver that can be used to receive messages from other modules\r\n                this.core.channelReceiver = await ChannelHandler.createReceiver(\r\n                    source.requestPath.toString(true),\r\n                    this.__createChannelMethods()\r\n                );\r\n\r\n                // Creat a channel sender to the module that requested this module\r\n                source.channel = await ChannelHandler.createSender(\r\n                    source.request.source,\r\n                    source.request.type,\r\n                    source.requestPath.toString(true)\r\n                );\r\n\r\n                // Indicate that registering has finished and resolve the promise\r\n                this.core.registration.registered.true(true);\r\n                this.core.registration.registerPromiseResolve(this);\r\n            } else {\r\n                // If the module was not instantiated by a request, the request path is simply this module path\r\n                source.requestPath = new RequestPath(\r\n                    this.getClass().modulePath,\r\n                    0\r\n                );\r\n\r\n                // Register this module in the registry (which will automatically assign a unique module ID)\r\n                await Registry._registerModuleInstance(this);\r\n\r\n                // Create a channel receiver that can be used to receive message from other modules\r\n                this.core.channelReceiver = await ChannelHandler.createReceiver(\r\n                    source.requestPath.toString(true),\r\n                    this.__createChannelMethods()\r\n                );\r\n\r\n                // Indicate that registering has finished and resolve th epromise\r\n                this.core.registration.registered.true(true);\r\n                this.core.registration.registerPromiseResolve(this);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a function to run before indicating that initialisation has finished\r\n     * @param {function} method - The function to run (may be async)\r\n     * @returns {Promise} A promise that resolves when the module is initialised\r\n     * @private\r\n     */\r\n    __init(method) {\r\n        // Add the method to the chain and return the chain\r\n        return (this.core.initPromise = this.core.initPromise.then(method));\r\n    }\r\n\r\n    /**\r\n     * Adds a then and catch function to the registration completion promise\r\n     * @param {function} [then] - The function to run when registration has finished\r\n     * @param {function} [ctch] - The function to run if something goes wrong during registration\r\n     * @returns {Promise<Module>} A reference to this module instance\r\n     * @async\r\n     * @private\r\n     */\r\n    __onRegister(then, ctch) {\r\n        return this.core.registration.registerPromise.then(then).catch(ctch);\r\n    }\r\n\r\n    /**\r\n     * Adds a then and catch function to the initialization completion promise\r\n     * @param {function} [then] - The function to run when initialization has finished\r\n     * @param {function} [ctch] - The function to run if something goes wrong during initialization\r\n     * @returns {Promise<Module>} A reference to this module instance\r\n     * @async\r\n     * @private\r\n     */\r\n    onInit(then, ctch) {\r\n        return this.core.initPromise.then(then).catch(ctch);\r\n    }\r\n\r\n    // Registry related methods\r\n    /**\r\n     * Returns the path to this module instance\r\n     * @returns {string} The path to this module instance\r\n     * @public\r\n     */\r\n    toString() {\r\n        // Get the request path and get its unique string representation\r\n        return this.getPath().toString(true);\r\n    }\r\n\r\n    /**\r\n     * Returns the class of this module instance\r\n     * @returns {Class<Module>} The class of this module instance\r\n     * @public\r\n     */\r\n    getClass() {\r\n        // Get the class out of this object instance\r\n        return this.__proto__.constructor;\r\n    }\r\n\r\n    /**\r\n     * Returns the requestPath that created this module instance\r\n     * @returns {RequestPath} The request path\r\n     * @public\r\n     */\r\n    getPath() {\r\n        return this.core.source.requestPath;\r\n    }\r\n\r\n    /**\r\n     * Returns the path to this module class\r\n     * @returns {string} The path to this module class\r\n     * @public\r\n     */\r\n    static getPath() {\r\n        // Get the modulePath that has been assigned by the registry when loading the module class\r\n        return this.modulePath;\r\n    }\r\n\r\n    /**\r\n     * Returns the path to this module class\r\n     * @returns {string} The path to this module class\r\n     * @public\r\n     */\r\n    static toString() {\r\n        return this.getPath();\r\n    }\r\n\r\n    // Channel-related methods\r\n    /**\r\n     * Gets all the methods of this module that are available for channels\r\n     * @param {Regex} regexFilter - The filter to apply to determine whether or not the method should be returned\r\n     * @returns {Object} All methods indexed by name\r\n     * @private\r\n     */\r\n    __getMethods(regexFilter) {\r\n        // Set up an object to store the output methods\r\n        const output = {};\r\n\r\n        // Go through the inheritence chain\r\n        let nextProto = this.__proto__;\r\n        while (nextProto && nextProto != Module.prototype) {\r\n            // Get the prototype of which to get the methods\r\n            const proto = nextProto;\r\n            nextProto = proto.__proto__;\r\n\r\n            // Go through all methods in the class\r\n            Object.getOwnPropertyNames(proto).forEach(varName => {\r\n                // Get the variable\r\n                const variable = this.__proto__[varName];\r\n\r\n                // Check if the variable is a method that should be available for the chanenl\r\n                const isChannelMethod =\r\n                    variable instanceof Function &&\r\n                    regexFilter.test(varName) &&\r\n                    !output[varName];\r\n\r\n                if (isChannelMethod) {\r\n                    // If the method should be avaiable, remove the prefix and store it in the output\r\n                    output[varName.replace(regexFilter, \"\")] = this.__proto__[\r\n                        varName\r\n                    ];\r\n                }\r\n            });\r\n        }\r\n\r\n        // Return the output\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     * Creates all methods to interact with this module over a channel\r\n     * @returns {Object} All methods indexed by name\r\n     * @private\r\n     */\r\n    __createChannelMethods() {\r\n        // Set up an object to store the output methods\r\n        const output = {};\r\n\r\n        // Get the methpds that are available for the channel\r\n        const methods = this.__getMethods(/^\\$/g);\r\n\r\n        // Go through all the methods to correctly map the channel data\r\n        Object.keys(methods).forEach(methodName => {\r\n            // Get the method from its name\r\n            const method = methods[methodName];\r\n\r\n            // Apply the event followed by the channel data as arguments for the method\r\n            output[methodName] = event => {\r\n                return method.apply(this, [event].concat(event.data));\r\n            };\r\n        });\r\n\r\n        // Set up a close method for the channel\r\n        output.close = event => {\r\n            return this.dispose();\r\n        };\r\n\r\n        // Set up a disconnectDescendant method for the channel that will detach a descendant from itself\r\n        output.disconnectDescendant = event => {\r\n            return this.__disconnectDescendant.apply(this, event.data);\r\n        };\r\n\r\n        // Return the output\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     * Disconnects a module from this module (But doesn't dispose it)\r\n     * @param {RequestPath} requestPath - The request path for the module to disconnect\r\n     * @param {string} type - The type of request that the module was instiated for\r\n     * @returns {undefined}\r\n     * @private\r\n     */\r\n    __disconnectDescendant(requestPath, type) {\r\n        // Get the handler for this request type if available\r\n        const handler = this.core.handlers[type];\r\n        if (handler) {\r\n            // Extract the channels from this handler\r\n            const channels = handler.channels;\r\n\r\n            // Remove the channel that matches the requestPath\r\n            handler.channels = channels.filter(channel => {\r\n                return channel._getID() != requestPath;\r\n            });\r\n\r\n            // Remove the handler if all channels have been closed\r\n            if (handler.channels.length == 0) delete this.core.handlers[type];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes this module entirely, also getting rid of its connections to other modules\r\n     * @returns {Promise} The promise that resolves once disposal has completed\r\n     * @async\r\n     * @public\r\n     */\r\n    async dispose() {\r\n        // Check if the module is not still registering\r\n        if (this.core.registration.registered.turningTrue())\r\n            throw Error(\"Module is still registering\");\r\n\r\n        // Check if the module is registered in the first place\r\n        if (this.core.registration.registered.true()) {\r\n            // Indicate that the module is now in the process of deregestering\r\n            this.core.registration.registered.turningFalse(true);\r\n\r\n            // Object to track all the promises of modules being disposed\r\n            const channelDisposalPromises = [];\r\n\r\n            // Go through all the handlers to dispose them\r\n            Object.keys(this.core.handlers).forEach(type => {\r\n                // Get the handler and its channels\r\n                const handler = this.core.handlers[type];\r\n                const channels = handler.channels;\r\n\r\n                // Close all the handle modules and track their promises\r\n                channelDisposalPromises.push.apply(\r\n                    channelDisposalPromises,\r\n                    channels.map(channel => {\r\n                        return channel.close();\r\n                    })\r\n                );\r\n            });\r\n\r\n            // Wait for all modules to finish disposing\r\n            await Promise.all(channelDisposalPromises);\r\n\r\n            // If this module has a source channel, indicate that this module has been closed by disconnecting it\r\n            if (this.core.source.channel) {\r\n                await this.core.source.channel.disconnectDescendant(\r\n                    this.getPath().toString(true),\r\n                    this.core.source.request.type\r\n                );\r\n            }\r\n\r\n            // Dispose the channel receiver properly\r\n            await this.core.channelReceiver.close();\r\n\r\n            // Tell the registry that this module no longer exists\r\n            await Registry._deregisterModuleInstance(this);\r\n\r\n            // Indicate that deregistering has finished\r\n            this.core.registration.registered.false(true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Request modules to handle the passed data and establish a connection with these modules\r\n     * @param  {Registry~Request} request - The information on how to handle the data\r\n     * @returns {Promise<ChannelSender[]>} The channel(s) that have been created to answer the request\r\n     * @async\r\n     * @public\r\n     */\r\n    async requestHandle(request) {\r\n        // Check if the module is not currently deregistering, if it is, throw an error\r\n        if (this.core.registration.registered.turningFalse())\r\n            throw Error(\"Module is currently deregistering\");\r\n\r\n        // Check if the module is currently not registered\r\n        if (this.core.registration.registered.false()) {\r\n            // Wait for the module to finish registering\r\n            await this.__register();\r\n\r\n            // Check if the module is currently registering\r\n        } else if (this.core.registration.registered.turningTrue()) {\r\n            // Wait for th emodule to finish regestering\r\n            await this.__onRegister();\r\n        }\r\n\r\n        // If no extra methods have been assigned to the request, assign it an empty object\r\n        if (!request.methods) request.methods = {};\r\n\r\n        // Set this module to be the source of the request\r\n        request.source = this;\r\n\r\n        // If this module has already made a request for this type, return those channels instead\r\n        if (this.core.handlers[request.type])\r\n            return this.core.handler[request.type].channels;\r\n\r\n        // Create a subchannel in this channel receiver to handle received data from the requested handlers\r\n        this.core.channelReceiver.createSubChannel(\r\n            request.type,\r\n            request.methods\r\n        );\r\n\r\n        // Send the request to the registry and receive its created channels\r\n        const channels = await Registry.requestHandle(request);\r\n\r\n        // Store the created handlers locally\r\n        this.core.handlers[request.type] = {\r\n            request: request,\r\n            channels: channels instanceof Array ? channels : [channels], // Make sure it is an array of channels\r\n        };\r\n\r\n        // Return the received channels\r\n        return channels;\r\n    }\r\n}\r\n"]}