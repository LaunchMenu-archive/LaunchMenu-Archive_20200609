{"version":3,"sources":["../../../src/core/registry/registry.js"],"names":["defaultModuleData","location","window","section","Registry","requestHandle","request","_normalizeHandleRequest","requestModules","isMain","__getRequestListeners","__data","requiringModules","IPC","send","instantiatePromises","forEach","module","source","RequestPath","augmentPath","moduleLocation","_destinationWindowID","_destinationSectionID","SettingsHandler","_getModuleLocation","push","WindowHandler","openModuleInstance","e","console","error","getModuleChannel","undefined","then","channel","$connect","channels","all","use","filter","hasInvalidUse","match","data","embedGUI","ID","Module","getPath","toString","requestModule","requests","_normalizeModuleRequest","apply","arguments","requestsModules","map","sendSync","length","response","i","type","isModuleRequest","__setupRequest","on","event","loadingModules","listenerType","__getListeners","priorities","configs","config","priority","isModuleClassConfig","modulePath","indexOf","sort","a","b","__getModulesFromConfigs","_loadModule","requestPath","subChannelType","senderID","channelSender","ChannelHandler","createSender","_getModuleInstance","elementCreator","core","path","moduleImport","require","__getModulesPath","index","splice","default","_getModule","moduleConfigs","_loadConfig","Array","dir","split","Path","sep","pop","join","replace","find","_loadAllConfigs","startPath","resolve","__dirname","readDir","reject","FS","readdir","err","files","outConfigs","promises","file","filePath","lstatSync","isDirectory","relativeFilePath","substring","configLists","back","process","cwd","listeners","registerRequestListener","getClass","getConfig","channelReceiver","_hasListener","Error","__setupRegisterRequestListener","_getModuleConfig","getModuleConfig","localModuleConfig","moduleConfig","__setupGetModuleConfig","_registerModuleInstance","moduleInstance","uniqueID","isEmbeded","_isEmbeded","getModuleID","moduleInstances","__setupRegisterModuleInstance","embeded","moduleClass","paths","requestPaths","pathList","moduleInstancePaths","sourceID","active","_registerModuleInstanceCompleted","__setupRegisterModuleInstanceCompleted","item","moduleAwaiters","waiter","pattern","acceptEmbeded","test","log","_deregisterModuleInstance","_close","__setupDeregisterModuleInstance","requestPathString","_getModuleInstances","getModuleInstanceChannels","subChannel","windowID","instancePaths","__setupGetModuleInstanceChannels","moveModuleTo","requestPathPattern","includeEmbeded","responses","modulePaths","__setupMoveModuleTo","RequestPathPattern","embedCheck","getRequest","promise","moveTo","awaitModuleCreation","__setupAwaitModuleCreation","moduleClassPaths","matches","uniquePaths","uniquePath","resolver","__setup"],"mappings":"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","file":"registry.js","sourcesContent":["import Path from \"path\";\r\nimport FS from \"fs\";\r\nimport isMain from \"../isMain\";\r\nimport RequestPath from \"./requestPath/requestPath\";\r\nimport RequestPathPattern from \"./requestPath/requestPathPattern\";\r\nimport SettingsHandler from \"../communication/data/settings/settingsHandler\";\r\nimport WindowHandler from \"../window/windowHandler\";\r\nimport Module from \"./module\";\r\nimport ChannelHandler from \"../communication/channel/channelHandler\";\r\nimport IPC from \"../communication/IPC\";\r\n\r\nconst defaultModuleData = {\r\n    location: {\r\n        window: 1,\r\n        section: 0,\r\n    },\r\n};\r\n\r\n/**\r\n * A request that can be made to retrieve a module\r\n * @typedef {Object} Registry~Request\r\n * @property {string} type - The type of handeling you are requesting\r\n * @property {('all'|'one'|function)} [use] - What modules to use to answer the request\r\n * @property {Object} [data] - Any extra data you want to pass that modules can use to determine if they can answer the request\r\n * @property {Module} [source] - The module that sent out the request (can be left out when usimg Module.requestHandle)\r\n * @property {Object} [methods] - Extra methods that can get called by the handle (is only used by Module.requestHandle)\r\n * @property {boolean} [embedGUI] - Whether the module GUI will be embeded into another module\r\n * @property {number} [_destinationWindowID] - The window that the module answering this request should be instanciated in (only used to force a value)\r\n * @property {number} [_destinationSectionID] - The section in the window that the module answering this request should be instanciated in (only used to force a value)\r\n */\r\n\r\n/**\r\n * The data that is stored to track what modules can answer what requests\r\n * @typedef {Object} Registry~Requestlistener\r\n * @property {string} type - The type of request to handle\r\n * @property {Object[]} listeners - The modules that can answer this request\r\n * @property {Class<Module>} listeners[].module - The module class that can answer the request\r\n * @property {function} listeners[].filter - The filter to make sure the class can handle this request\r\n */\r\n\r\n/**\r\n * The format that module configs should be in\r\n * @typedef {Object} Registry~Config\r\n * @property {string} type - The type of request to handle\r\n * @property {Function} [filter] - A method that will get passed a request, that determines whether to use this module and with what priority\r\n * @property {string} [module] - The relative path to the module to use\r\n * @property {Object} [settings] - The default settings to apply to modules of this type\r\n */\r\n\r\n/**\r\n * The format that module instance config should be in, which are used as request listeners\r\n * @typedef {Object} Registry~ModuleInstanceConfig\r\n * @property {string} [type] - The type of request to handle, defaults to the module instance's type\r\n * @property {Function} [filter] - A method that will get passed a request, that determines whether to use this module instance and with what priority\r\n * @property {(RequestPath|string)} [requestPath] - The requestPath for the module instance to use\r\n */\r\n\r\n/**\r\n * The location of a certain module, relative to the modules directory\r\n * @typedef {string} Registry~ModulePath\r\n */\r\n\r\n/**\r\n * @classdesc A class to track all the modules, and handle module requests\r\n * @class\r\n * @hideconstructor\r\n */\r\nexport default class Registry {\r\n    // Request related code\r\n    /**\r\n     * Request modules to handle the passed data and establish a connection with these modules\r\n     * @param  {Request} request - The information on how to handle the data\r\n     * @return {(Promise<ChannelSender>|Promise<ChannelSender[]>)} The channel(s) that have been created to answer the request\r\n     * @async\r\n     * @public\r\n     */\r\n    static async requestHandle(request) {\r\n        // Normalize the request\r\n        this._normalizeHandleRequest(request);\r\n\r\n        // Retrieve the modules to resolve the request\r\n        let requestModules;\r\n\r\n        // Check if we are in the main process\r\n        if (isMain) {\r\n            // Directly resolve the request as we have access to all modules\r\n            requestModules = this.__getRequestListeners(\r\n                request,\r\n                this.__data.requiringModules\r\n            );\r\n        } else {\r\n            // Send a command to the main window to look for modules to resolve the request\r\n            requestModules = (await IPC.send(\r\n                \"Registry.request\",\r\n                {\r\n                    request: request,\r\n                    requiringModules: this.__data.requiringModules,\r\n                },\r\n                0\r\n            ))[0];\r\n        }\r\n\r\n        // Instanciate all the modules\r\n\r\n        // In order to batch the await, instead of waiting between each open instance request\r\n        const instantiatePromises = [];\r\n\r\n        // Go through modules for 1 request\r\n        requestModules.forEach(module => {\r\n            // Check if the module is an existing module, or a module class\r\n            if (typeof module == \"function\") {\r\n                // The module is a module class\r\n\r\n                // Catch any errors that might occur while instanciating\r\n                try {\r\n                    // Create the proper request path\r\n                    let source;\r\n                    if (request.source) {\r\n                        source = new RequestPath(request.source).augmentPath(\r\n                            module\r\n                        );\r\n                    } else {\r\n                        source = new RequestPath(module);\r\n                    }\r\n\r\n                    // Attempt to retrieve the correct startup location\r\n                    let moduleLocation;\r\n\r\n                    // Check if the request defined a location\r\n                    if (request._destinationWindowID != null) {\r\n                        // If it did, use this\r\n                        moduleLocation = {\r\n                            window: request._destinationWindowID,\r\n                            section: request._destinationSectionID || 0,\r\n                        };\r\n                    } else {\r\n                        // Otherwise load the location from the settings\r\n                        moduleLocation = SettingsHandler._getModuleLocation(\r\n                            source\r\n                        );\r\n                    }\r\n\r\n                    // Open the window that the module should appear in\r\n                    instantiatePromises.push(\r\n                        WindowHandler.openModuleInstance(\r\n                            moduleLocation,\r\n                            request,\r\n                            module\r\n                        )\r\n                    );\r\n                } catch (e) {\r\n                    // TODO: properply handle the error if something goes wrong\r\n                    console.error(\r\n                        `Something went wrong while trying to instantiate ${module}: `,\r\n                        e\r\n                    );\r\n                }\r\n            } else {\r\n                // Create a channelSender\r\n                instantiatePromises.push(\r\n                    this.getModuleChannel(\r\n                        module,\r\n                        undefined,\r\n                        request.source\r\n                    ).then(async channel => {\r\n                        // Connect with the module instance\r\n                        await channel.$connect(request.source);\r\n\r\n                        // Forward the channel\r\n                        return channel;\r\n                    })\r\n                );\r\n            }\r\n        });\r\n\r\n        // Wait for all the promises to resolve and get their channels\r\n        const channels = await Promise.all(instantiatePromises);\r\n\r\n        // Determine whether to return only a single channel or an array of channels and return it\r\n        if (request.use == \"one\") {\r\n            return channels[0];\r\n        } else {\r\n            return channels.filter(channel => channel); // Remove failed instanciations\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Normalizes the handle request to a fixed format\r\n     * @param {Request} request - The request to normalize\r\n     * @returns {Request} The normalized request (same object as the paramater)\r\n     * @protected\r\n     */\r\n    static _normalizeHandleRequest(request) {\r\n        // Check if the request contains a valid use, if not set it to 'one'\r\n        const hasInvalidUse =\r\n            !request.use ||\r\n            (typeof request.use == \"string\" ||\r\n                !request.use.match(/^(one|all)$/g));\r\n        if (hasInvalidUse) request.use = \"one\";\r\n\r\n        // Ensure at least an empty data object is present in the request\r\n        if (!request.data) request.data = {};\r\n\r\n        // Make sure that when embeding GUI, the result element is opened in the same window\r\n        if (request.embedGUI) request._destinationWindowID = WindowHandler.ID;\r\n\r\n        // Check if the request source type is a module, if so, get its string identifier\r\n        if (request.source instanceof Module)\r\n            request.source = request.source.getPath().toString(true);\r\n\r\n        // Return the request\r\n        return request;\r\n    }\r\n\r\n    /**\r\n     * Request module classes of a specific type\r\n     * @param {Request} request - The information on what module to get\r\n     * @returns {(Class<Module>|Object<string, Class<Module>>)} The module(s) that it could find with the specified type\r\n     * @public\r\n     */\r\n    static requestModule(request) {\r\n        // Normalize all the possibly passed requests\r\n        const requests = this._normalizeModuleRequest.apply(this, arguments);\r\n\r\n        // Retrieve the request modules\r\n        let requestsModules;\r\n\r\n        // Check if we are in the main process\r\n        if (isMain) {\r\n            // Directly resolve the request as we have access to all modules\r\n            requestsModules = requests.map(request => {\r\n                return this.__getRequestListeners(\r\n                    request,\r\n                    this.__data.requiringModules\r\n                );\r\n            });\r\n        } else {\r\n            // Send a command to the main window to look for modules to resolve the request\r\n            requestsModules = IPC.sendSync(\"Registry.request\", {\r\n                requests: requests,\r\n                requiringModules: this.__data.requiringModules,\r\n            })[0];\r\n        }\r\n\r\n        // Format the response appropriately\r\n        if (requestsModules.length > 1) {\r\n            // Create a object to hold the output\r\n            const response = {};\r\n\r\n            // Map the modules to their request types\r\n            requestsModules.forEach((requestModules, i) => {\r\n                // Get the request corresponding to this module\r\n                const request = requests[i];\r\n\r\n                // Determine whether to return only a single channel or an array of module classes and return it\r\n                if (request.use == \"one\") {\r\n                    // Store a single request module under the correct name\r\n                    response[request.type] = requestModules[0];\r\n                } else {\r\n                    // Store all request modules under the correct name\r\n                    response[request.type] = requestModules;\r\n                }\r\n            });\r\n\r\n            // Return the modules indexed by request type\r\n            return response;\r\n        } else {\r\n            // Get the module class(es) corresponding to the request\r\n            const requestModules = requestsModules[0];\r\n\r\n            // Determine whether to return only a single channel or an array of module classes and return it\r\n            if (requests[0].use == \"one\") {\r\n                return requestModules[0];\r\n            } else {\r\n                return requestModules;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Normalizes the module request to a fixed format\r\n     * @param {Request} request - The request to normalize\r\n     * @returns {Request[]} The normalized requests in array form\r\n     * @protected\r\n     */\r\n    static _normalizeModuleRequest(request) {\r\n        // Get all the requests that were passed (multiple are allowed) TODO: indicate multiple in JSdoc\r\n        var requests = Array.from(arguments);\r\n\r\n        // Normalize the format of the requests\r\n        var requests = requests.map(request => {\r\n            // If the request is only a string rather than an object, turn it into an object\r\n            if (typeof request == \"string\") request = {type: request};\r\n\r\n            // Check if the request contains a valid use, if not set it to 'one'\r\n            const hasInvalidUse =\r\n                !request.use ||\r\n                (typeof request.use == \"string\" ||\r\n                    !request.use.match(/^(one|all)$/g));\r\n            if (hasInvalidUse) request.use = \"one\";\r\n\r\n            // Ensure at least an empty data object is present in the request\r\n            if (!request.data) request.data = {};\r\n\r\n            // Indicate that this is a moduleRequest\r\n            request.isModuleRequest = true;\r\n\r\n            // Return the new request variable\r\n            return request;\r\n        });\r\n\r\n        // Return the requests\r\n        return requests;\r\n    }\r\n\r\n    /**\r\n     * A method to set up the required IPC listener for the request method\r\n     * @returns {undefined}\r\n     * @private\r\n     */\r\n    static __setupRequest() {\r\n        // Make sure to only set this up in the main process\r\n        if (isMain) {\r\n            // Listen for requests getting routed through the main process\r\n            IPC.on(\"Registry.request\", event => {\r\n                // Check if there is a single request or multiples\r\n                if (event.data.request) {\r\n                    const request = event.data.request;\r\n                    const requiringModules = event.data.requiringModules;\r\n\r\n                    // Retrieve the priority mapping for the request\r\n                    const requestModules = this.__getRequestListeners(\r\n                        request,\r\n                        requiringModules\r\n                    );\r\n\r\n                    // Return the modules and their priorities\r\n                    return requestModules;\r\n                } else {\r\n                    const requests = event.data.requests;\r\n                    const requiringModules = event.data.requiringModules;\r\n\r\n                    // Retrieve the priority mapping for every request\r\n                    const requestsModules = requests.map(request => {\r\n                        return this.__getRequestListeners(\r\n                            request,\r\n                            requiringModules\r\n                        );\r\n                    });\r\n\r\n                    // Return the mapping of modules and their priorities\r\n                    return requestsModules;\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Retrieves the listeners that can handle the passed request\r\n     * @param {Registry~Request} request - The request to find module classes for\r\n     * @param {string[]} loadingModules - A list of module paths that are currently being required\r\n     * @returns {(Class<Module>|Array<Class<Module>>)} The module classes that have been chosen to handle the request\r\n     * @private\r\n     */\r\n    static __getRequestListeners(request, loadingModules) {\r\n        // Get the module listeners to handle this type of request\r\n        const listenerType = this.__getListeners(request.type);\r\n\r\n        // Map modules with their priority to this particular request\r\n        const priorities = listenerType.configs\r\n            .map(config => {\r\n                try {\r\n                    // Attempt to apply the filter and return the required data\r\n                    return {\r\n                        priority: config.filter(request),\r\n                        config: config,\r\n                    };\r\n                } catch (e) {\r\n                    console.error(\r\n                        \"Something went wrong while applying filter of config \",\r\n                        config\r\n                    );\r\n\r\n                    // Return the data with a priority of 0, as the filter errored\r\n                    return {\r\n                        priority: 0,\r\n                        config: config,\r\n                    };\r\n                }\r\n            })\r\n            .filter(priority => {\r\n                // Make sure it should be included in the first place\r\n                if (priority.priority == 0) return false;\r\n\r\n                // Check if the config is a module class config\r\n                if (priority.config.isModuleClassConfig) {\r\n                    // Check if the module isn't being loaded already\r\n                    const modulePath = priority.config.modulePath;\r\n                    if (loadingModules.indexOf(modulePath) != -1) return false;\r\n                } else {\r\n                    // Check if we allow non-classes\r\n                    if (request.isModuleRequest) return false;\r\n                }\r\n\r\n                // If all checks passed\r\n                return true;\r\n            });\r\n\r\n        // Sort the results\r\n        priorities.sort((a, b) => b.priority - a.priority);\r\n\r\n        // Determine what modules to return\r\n        if (request.use == \"all\") {\r\n            // If all modules should be returned, simply extract the modules from the priority data and return them\r\n            return this.__getModulesFromConfigs(priorities.map(a => a.config));\r\n        } else if (typeof request.use == \"Function\") {\r\n            // If a filter function is provided, apply it and then extract the modules from the data and return them\r\n            return this.__getModulesFromConfigs(\r\n                priorities.filter(request.use).map(a => a.config)\r\n            );\r\n        } else {\r\n            // Otherwise only a single module should be returned, so simply return this module\r\n            return (\r\n                priorities[0] &&\r\n                this.__getModulesFromConfigs([priorities[0].config])\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Goes through the array of configs and maps it to the modules of the configs (requires modules if needed)\r\n     * @param {Registry~Config[]} configs - The configs to get the modules from\r\n     * @returns {Array<Class<Module>>} The modules that got extracted fromt he configs\r\n     * @private\r\n     */\r\n    static __getModulesFromConfigs(configs) {\r\n        return configs.map(config => {\r\n            // Check if it is a module instance or class config\r\n            if (config.isModuleClassConfig) {\r\n                // Require the module from the config if this hasn't happened yet\r\n                if (!(config.module instanceof Module))\r\n                    this._loadModule(config);\r\n\r\n                // Return the module itself, which should now in no situation be a path\r\n                return config.module;\r\n            } else {\r\n                // Return the module's request path\r\n                return config.requestPath;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Establishes a connection with a module with the defined requestPath\r\n     * @param {(string|requestPath)} requestPath - The unique request path of the module you are trying to conenct to\r\n     * @param {string} [subChannelType=undefined] - The sub channel to connect with\r\n     * @param {(Module|string|requestPath)} [senderID=undefined] - The channel ID to send messages back to for communication\r\n     * @returns {ChannelSender} A channel set up for communication with the specified module\r\n     * @async\r\n     * @public\r\n     */\r\n    static async getModuleChannel(requestPath, subChannelType, senderID) {\r\n        // Normalize the path to a string\r\n        if (typeof requestPath != \"string\")\r\n            requestPath = requestPath.toString(true);\r\n\r\n        // Create a channel sender to this module instance and return it\r\n        const channelSender = await ChannelHandler.createSender(\r\n            requestPath,\r\n            subChannelType,\r\n            senderID\r\n        );\r\n\r\n        // Find the requested module instance in this window (if present in this window)\r\n        const module = Registry._getModuleInstance(requestPath);\r\n\r\n        // Check if the module exists, and if so extract its element creator\r\n        if (module) {\r\n            const elementCreator = module.core.elementCreator;\r\n\r\n            // Attach the elementCreator to the channel\r\n            channelSender.__data.elementCreator = elementCreator;\r\n        }\r\n\r\n        // Return the channelSender\r\n        return channelSender;\r\n    }\r\n\r\n    // Module loading and listener creation related methods\r\n    /**\r\n     * Loads a module at the specified path relative to the modules folder\r\n     * @param {string} path - The path to the module class\r\n     * @returns {Class<Module>} The module class that was loaded\r\n     * @protected\r\n     */\r\n    static _loadModule(config) {\r\n        // Get the path from the config\r\n        const path = config.modulePath;\r\n\r\n        // Only load the module if it hadn't been loaded already\r\n        if (!config.module) {\r\n            // Indicate that we have started requiring this module, to prevent import LM: recursion\r\n            this.__data.requiringModules.push(path);\r\n\r\n            // Require module\r\n            const moduleImport = require(this.__getModulesPath(path));\r\n\r\n            // Indicate that we are no longer in the process of loading this module\r\n            const index = this.__data.requiringModules.indexOf(path);\r\n            if (index != -1) this.__data.requiringModules.splice(index, 1);\r\n\r\n            if (moduleImport) {\r\n                // Get the module from the import\r\n                const module = moduleImport.default;\r\n\r\n                // Attach the config to the class\r\n                module.config = config;\r\n\r\n                // Attach the module to the config\r\n                config.module = module;\r\n            }\r\n        }\r\n\r\n        // Return the module\r\n        return config.module;\r\n    }\r\n\r\n    /**\r\n     * Loads a module at the specified path relative to the modules folder, should only be used once the module is already properly loaded, and only from the main process\r\n     * @param {string} modulePath - The modulePath for the module to return\r\n     * @returns {Class<Module>} The module that is located here\r\n     * @protected\r\n     */\r\n    static _getModule(modulePath) {\r\n        // Retrieve the config for this path\r\n        const config = this.__data.moduleConfigs[modulePath];\r\n\r\n        // If a config was found, return its module\r\n        if (config) return this._loadModule(config);\r\n    }\r\n\r\n    /**\r\n     * Loads a module config at the specified path relative to the modules folder\r\n     * @param {string} path - The path to the config\r\n     * @param {string} [modulePath] - The modulePath for the config to return\r\n     * @returns {Config[]} The config that was loaded\r\n     * @protected\r\n     */\r\n    static _loadConfig(path, modulePath) {\r\n        // Require the config\r\n        let configs = require(this.__getModulesPath(path)).default;\r\n\r\n        // Normalize it into an array of configs if needed\r\n        if (!(configs instanceof Array)) configs = [configs];\r\n\r\n        // Go through all configs\r\n        configs.forEach(config => {\r\n            // Add listener to the list of listeners for this request type\r\n            const listenerType = this.__getListeners(config.type);\r\n            const index = listenerType.configs.indexOf(config);\r\n            if (index != -1) return; // Don't add it, if it was already added\r\n\r\n            listenerType.configs.push(config);\r\n\r\n            // Get the module path\r\n            let modulePath;\r\n            if (config.module) {\r\n                // Get the directory of the config path\r\n                let dir = path.split(Path.sep);\r\n                dir.pop();\r\n                dir = dir.join(\"/\");\r\n\r\n                // Get the module path relative to this dir\r\n                modulePath = Path.join(dir, config.module);\r\n            } else {\r\n                modulePath = path.replace(/\\.?config/, \"\");\r\n            }\r\n\r\n            // Normalize the path's seperators\r\n            modulePath = modulePath.replace(/\\\\/g, \"/\");\r\n\r\n            // Add a filter to the config if not present\r\n            if (!config.filter) config.filter = () => true;\r\n\r\n            // Attach the location of the module to the config\r\n            config.modulePath = modulePath;\r\n\r\n            // Store the path of the config\r\n            config.path = path;\r\n\r\n            // Indicate that this config is indeed a config (as it will be used as a 'listener')\r\n            config.isModuleClassConfig = true;\r\n\r\n            // Store the config under its modulePath\r\n            this.__data.moduleConfigs[modulePath] = config;\r\n        });\r\n\r\n        // If a modulePath was defined, return only the config of said path\r\n        if (modulePath)\r\n            return configs.find(config => config.modulePath == modulePath);\r\n\r\n        // Return all the retrieved configs\r\n        return configs;\r\n    }\r\n\r\n    /**\r\n     * Loads all the configs of available modules\r\n     * @returns {Promise<Array<Config>>} All the configs that have been loaded\r\n     * @async\r\n     * @protected\r\n     */\r\n    static _loadAllConfigs() {\r\n        const startPath = Path.resolve(__dirname, this.__getModulesPath());\r\n        const readDir = path => {\r\n            return new Promise((resolve, reject) => {\r\n                FS.readdir(path, (err, files) => {\r\n                    // Store the resulting configs to return\r\n                    const outConfigs = [];\r\n\r\n                    // Store async dir reading promises that have to be resolved\r\n                    const promises = [];\r\n\r\n                    // Read the files\r\n                    files.forEach(file => {\r\n                        const filePath = Path.join(path, file);\r\n                        // Check if this file is a directory or not\r\n                        if (FS.lstatSync(filePath).isDirectory()) {\r\n                            // Recurse on the directory, and store the promise in order to wait for it\r\n                            promises.push(readDir(filePath));\r\n                        } else {\r\n                            // Check if the file is a config, and if so, load it\r\n                            if (file.match(/config\\.js$/g)) {\r\n                                // Get the file path relative to the modules folder\r\n                                const relativeFilePath = filePath.substring(\r\n                                    startPath.length + 1\r\n                                );\r\n\r\n                                // Load the config and add it to the output configs\r\n                                outConfigs.push.apply(\r\n                                    outConfigs,\r\n                                    this._loadConfig(relativeFilePath)\r\n                                );\r\n                            }\r\n                        }\r\n                    });\r\n\r\n                    // Wait for all the directory async recursions to finish\r\n                    Promise.all(promises).then(configLists => {\r\n                        // Add all returned lists to our main list\r\n                        configLists.forEach(configs => {\r\n                            outConfigs.push.apply(outConfigs, configs);\r\n                        });\r\n\r\n                        // Return our main list\r\n                        resolve(outConfigs);\r\n                    });\r\n                });\r\n            });\r\n        };\r\n\r\n        // start the recursive directory reading and return its promise\r\n        return readDir(startPath);\r\n    }\r\n\r\n    /**\r\n     * Returns the relative path from this class to the modules directory\r\n     * @param {String} [path=\"\"] - The path to append to the modules directory\r\n     * @returns {String} The relative path to the directory\r\n     * @private\r\n     */\r\n    static __getModulesPath(path = \"\") {\r\n        // Calculate how many dirs to go up to reach the root\r\n        let back = __dirname.substring(process.cwd().length).split(Path.sep);\r\n        back.pop();\r\n        back = back.map(() => \"..\").join(\"/\");\r\n\r\n        // Get the path from the root to the indicated module\r\n        return Path.join(back, \"dist\", \"modules\", path);\r\n    }\r\n\r\n    /**\r\n     * Creates an object to store what classes can answer a certain request type if it hasn't been created already, and returns it\r\n     * @param {String} type - The request type to return the object of\r\n     * @returns {Registry~Requestlistener} An object that tracks the listeners for a certain request type\r\n     * @private\r\n     */\r\n    static __getListeners(type) {\r\n        // Create listeners type variable if not available\r\n        if (!this.__data.listeners[type])\r\n            this.__data.listeners[type] = {\r\n                type: type,\r\n                configs: [],\r\n            };\r\n\r\n        // Return listener type\r\n        return this.__data.listeners[type];\r\n    }\r\n\r\n    /**\r\n     * Registers a module instance to be usable for multiple requests\r\n     * @param {Module} module - The module instance to use\r\n     * @param {Registry~ModuleInstanceConfig} [config] - A config for if you want to listen for a specific request]\r\n     * @returns {Promise<undefined>}\r\n     * @public\r\n     */\r\n    static async registerRequestListener(module, config) {\r\n        // Normalize the config\r\n        if (!config) config = {};\r\n        if (!config.type) config.type = module.getClass().getConfig().type;\r\n        if (!config.filter) config.filter = () => 1.1;\r\n        if (!config.requestPath)\r\n            config.requestPath = module.getPath().toString(true);\r\n\r\n        // Check if the module defined a connect method\r\n        if (!module.core.channelReceiver._hasListener(\"$connect\")) {\r\n            throw Error(\"The module should contain a $connect method\");\r\n        }\r\n\r\n        // Send the data to the main process to be stored as a listener\r\n        await IPC.send(\"Registry.registerRequestListener\", config, 0);\r\n    }\r\n    /**\r\n     * A method to set up the required IPC listener for the registerRequestListener method\r\n     * @returns {undefined}\r\n     * @private\r\n     */\r\n    static __setupRegisterRequestListener() {\r\n        // Make sure to only set this up in the main process\r\n        if (isMain) {\r\n            // Listen for windows/processes setting up a request listener\r\n            IPC.on(\"Registry.registerRequestListener\", event => {\r\n                // Retrieve the config\r\n                const config = event.data;\r\n\r\n                // Retrieve the config's type\r\n                const type = config.type;\r\n\r\n                // Get the listeners for this type\r\n                const listenerType = this.__getListeners(type);\r\n\r\n                // Add the config tot hte listeners\r\n                listenerType.configs.push(config);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a module's config' based on its location, if it has been loaded in this window/process\r\n     * @param {Registry~ModulePath} modulePath - The location of the module class to get the config from\r\n     * @returns {Registry~Config} The config that was found\r\n     * @protected\r\n     */\r\n    static _getModuleConfig(modulePath) {\r\n        return this.__data.moduleConfigs[modulePath];\r\n    }\r\n\r\n    /**\r\n     * Returns the config file of a certain module\r\n     * @param {Registry~ModulePath} modulePath - The location of the module\r\n     * @returns {Registry~Config} - The config that was found for this modulePath\r\n     * @public\r\n     */\r\n    static getModuleConfig(modulePath) {\r\n        // First check for a local config in this window/process\r\n        const localModuleConfig = this._getModuleConfig(modulePath);\r\n\r\n        // If present, return it\r\n        if (localModuleConfig) return localModuleConfig;\r\n\r\n        // Otherwise request the config from the main process\r\n        if (!isMain) {\r\n            const moduleConfig = IPC.send(\r\n                \"Registry.getModuleConfig\",\r\n                modulePath.toString()\r\n            );\r\n\r\n            // Check if a config was found\r\n            if (moduleConfig) {\r\n                // Store the config locally to improve future performance\r\n                this.__data.moduleConfigs[\r\n                    moduleConfig.modulePath\r\n                ] = moduleConfig;\r\n\r\n                // return the moduleConfig\r\n                return moduleConfig;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * A method to set up the required IPC listener for the getModuleConfig method\r\n     * @returns {undefined}\r\n     * @private\r\n     */\r\n    static __setupGetModuleConfig() {\r\n        // Make sure to only set this up in the main process\r\n        if (isMain) {\r\n            // Listen for windows/processes requesting a module config\r\n            IPC.on(\"Registry.getModuleConfig\", event => {\r\n                // Extract the modulePath\r\n                const modulePath = event.data;\r\n\r\n                // Return the config if found\r\n                return this.getModuleConfig(modulePath);\r\n            });\r\n        }\r\n    }\r\n\r\n    // Module registation related methods\r\n    /**\r\n     * Registers the module so the registry knows of its existence\r\n     * @param {Module} moduleInstance - The module to register\r\n     * @param {number} [uniqueID] - A specific uniqueID that the module should get (only used when moving modules)\r\n     * @returns {number} The unique ID that the module instance has now been assigned\r\n     * @async\r\n     * @protected\r\n     */\r\n    static async _registerModuleInstance(moduleInstance, uniqueID) {\r\n        // Extract data from the moduleInstance\r\n        const requestPath = moduleInstance.getPath();\r\n        const isEmbeded = moduleInstance._isEmbeded();\r\n\r\n        // Get the a unique ID for the request path\r\n        const ID = (await IPC.send(\r\n            \"Registry.registerModuleInstance\",\r\n            {\r\n                requestPath: requestPath.toString(true),\r\n                isEmbeded: isEmbeded,\r\n                uniqueID: uniqueID,\r\n            },\r\n            0\r\n        ))[0];\r\n\r\n        // Assign the ID to this request path and return it\r\n        requestPath.getModuleID().ID = ID;\r\n\r\n        // Store the instance in this module/process\r\n        this.__data.moduleInstances[\r\n            moduleInstance.getPath().toString(true)\r\n        ] = moduleInstance;\r\n\r\n        // Return the obtained ID\r\n        return ID;\r\n    }\r\n    /**\r\n     * A method to set up the required IPC listener for the registerModuleInstance method\r\n     * @returns {undefined}\r\n     * @private\r\n     */\r\n    static __setupRegisterModuleInstance() {\r\n        // Make sure to only set this up in the main process\r\n        if (isMain) {\r\n            // List for modules getting registered\r\n            IPC.on(\"Registry.registerModuleInstance\", event => {\r\n                // Get whether or not the module is embeded\r\n                const embeded = event.data.isEmbeded;\r\n\r\n                // Get the request path for the module to register\r\n                const requestPath = new RequestPath(event.data.requestPath);\r\n\r\n                // Get the module class of the path to register\r\n                const moduleClass = requestPath.getModuleID().module;\r\n\r\n                // Retrieve the path collection that exists for this non unique request path, or create it if non-existent\r\n                let paths = this.__data.requestPaths[requestPath.toString()];\r\n                if (!paths)\r\n                    paths = this.__data.requestPaths[\r\n                        requestPath.toString()\r\n                    ] = {};\r\n\r\n                // Create a unique ID for the path\r\n                let ID = 0;\r\n\r\n                // Check if a ID was provided by the event\r\n                if (event.data.uniqueID) {\r\n                    // If so, just use that ID\r\n                    ID = event.data.uniqueID;\r\n                } else {\r\n                    // Find a unique ID in this collection\r\n                    while (paths[ID]) ID++;\r\n                }\r\n\r\n                // Asssign this unique ID to the last module of the request path and store the path\r\n                requestPath.getModuleID().ID = ID;\r\n                paths[ID] = requestPath;\r\n\r\n                // Retrieve the request path list that exists for that class, or create it if non-existent\r\n                let pathList = this.__data.moduleInstancePaths[moduleClass];\r\n                if (!pathList)\r\n                    pathList = this.__data.moduleInstancePaths[\r\n                        moduleClass\r\n                    ] = [];\r\n\r\n                // Add this path to the list together with the window it is stored in\r\n                pathList.push({\r\n                    window: event.sourceID,\r\n                    path: requestPath.toString(true),\r\n                    embeded: embeded,\r\n                    active: false,\r\n                });\r\n\r\n                // Return the unique request path identifier\r\n                return ID;\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Indicates that the registration and initialisation process of a module instance has completed\r\n     * @param {Module} moduleInstance - The module that finished registration\r\n     * @returns {undefined}\r\n     * @async\r\n     * @protected\r\n     */\r\n    static async _registerModuleInstanceCompleted(moduleInstance) {\r\n        // Retiever the requestPath of the moduleInstance\r\n        const requestPath = moduleInstance.getPath();\r\n\r\n        // Forward the data to the main process\r\n        return IPC.send(\r\n            \"Registry.registerModuleInstanceCompleted\",\r\n            {requestPath: requestPath.toString(true)},\r\n            0\r\n        );\r\n    }\r\n    /**\r\n     * A method to set up the required IPC listener for the registerModuleInstanceComplete method\r\n     * @returns {undefined}\r\n     * @private\r\n     */\r\n    static __setupRegisterModuleInstanceCompleted() {\r\n        // Make sure to only set this up in the main process\r\n        if (isMain) {\r\n            // Listen for modules indicating that their setup has completed\r\n            IPC.on(\"Registry.registerModuleInstanceCompleted\", event => {\r\n                // Get the request path for the module to activate\r\n                const requestPath = new RequestPath(event.data.requestPath);\r\n\r\n                // Get the module class of the path to activate\r\n                const moduleClass = requestPath.getModuleID().module;\r\n\r\n                // Retrieve the request path list that exists for that class, or create it if non-existent\r\n                const pathList = this.__data.moduleInstancePaths[moduleClass];\r\n\r\n                // Get the item corresponding to this requestPath\r\n                const item = pathList.find(\r\n                    item => item.path == event.data.requestPath\r\n                );\r\n\r\n                // Make sure an item was found\r\n                if (item) {\r\n                    // Indicate that the module is now active\r\n                    item.active = true;\r\n\r\n                    // Check if there is a pattern waiting that matches this requestPath\r\n                    this.__data.moduleAwaiters.forEach((waiter, index) => {\r\n                        // Extract the pattern\r\n                        const pattern = waiter.pattern;\r\n\r\n                        // Make sure we either accept embeded modules, or this module isn't embeded\r\n                        if (!waiter.acceptEmbeded && item.embeded) return;\r\n\r\n                        // Test if the pattern matches the new module instance\r\n                        if (pattern.test(requestPath)) {\r\n                            // If it does, delete the item\r\n                            this.__data.moduleAwaiters.splice(index, 1);\r\n\r\n                            // And resolve the promise when the module finished registering\r\n                            waiter.resolve(requestPath.toString(true));\r\n                        }\r\n                    });\r\n                } else {\r\n                    // This should in theory not happen\r\n                    console.error(\r\n                        \"Something went wrong; \",\r\n                        event.data.requestPath + \" couldn't be found\"\r\n                    );\r\n                    console.log(pathList);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deregisters the module so the registry knows it is no longer used\r\n     * @param {Module} moduleInstance - The module to deregister\r\n     * @returns {undefined}\r\n     * @async\r\n     * @protected\r\n     */\r\n    static async _deregisterModuleInstance(moduleInstance) {\r\n        // Remove the module path in the main process\r\n        const requestPath = moduleInstance.getPath();\r\n        await IPC.send(\r\n            \"Registry.deregisterModuleInstance\",\r\n            {\r\n                requestPath: requestPath.toString(true),\r\n            },\r\n            0\r\n        );\r\n\r\n        // Remove the instance from this process/window\r\n        delete this.__data.moduleInstances[\r\n            moduleInstance.getPath().toString(true)\r\n        ];\r\n\r\n        // Close this window if there are no more modules in it\r\n        if (Object.keys(this.__data.moduleInstances).length == 0)\r\n            WindowHandler._close();\r\n    }\r\n    /**\r\n     * A method to set up the required IPC listener for the deregisterModuleInstance method\r\n     * @returns {undefined}\r\n     * @private\r\n     */\r\n    static __setupDeregisterModuleInstance() {\r\n        // Make sure to only set this up in the main process\r\n        if (isMain) {\r\n            // Listen for modules getting deregistered\r\n            IPC.on(\"Registry.deregisterModuleInstance\", event => {\r\n                // Get the request path for the module to deregister\r\n                const requestPath = new RequestPath(event.data.requestPath);\r\n\r\n                // Get the module class of the path to deregister\r\n                const moduleClass = requestPath.getModuleID().module;\r\n\r\n                // Get the paths that are stored for this class\r\n                const pathList = this.__data.moduleInstancePaths[moduleClass];\r\n                if (pathList) {\r\n                    // get the unique request path in string form\r\n                    const requestPathString = requestPath.toString(true);\r\n\r\n                    // Filter out the object that corresponds with this string\r\n                    this.__data.moduleInstancePaths[\r\n                        moduleClass\r\n                    ] = pathList.filter(path => {\r\n                        return path.path != requestPathString;\r\n                    });\r\n                }\r\n\r\n                // Get the unique path identifier from the request path\r\n                const ID = requestPath.getModuleID().ID;\r\n\r\n                // Retrieve the path collection that exists for this non unique request path, and delete the path with this unique ID\r\n                const paths = this.__data.requestPaths[requestPath.toString()];\r\n                if (paths) delete paths[ID];\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the modules that are currently registered\r\n     * @returns {Module[]} The modules are currently registered\r\n     * @protected\r\n     */\r\n    static _getModuleInstances() {\r\n        return this.__data.moduleInstances;\r\n    }\r\n\r\n    /**\r\n     * Returns the module with a certain request path if available in the window\r\n     * @param {(string|RequestPath)} requestPath - The unique request path of the module you are looking for\r\n     * @returns {(Module|null)} The modules that got found\r\n     * @protected\r\n     */\r\n    static _getModuleInstance(requestPath) {\r\n        // Normalize the path to a string\r\n        if (typeof requestPath != \"string\")\r\n            requestPath = requestPath.toString(true);\r\n\r\n        // Go through all instances to find a module that matches this path\r\n        return this.__data.moduleInstances[requestPath];\r\n    }\r\n\r\n    // Methods that help with hackability of modules (mainly in other windows)\r\n    // TODO: deprecate this method and replace it with something that uses\r\n    /**\r\n     * Gets channels to all instances of a specific module class\r\n     * @param {(Class<Module>|Module)} module - The module to get the instance of\r\n     * @param {string} [subChannel] - The sub channel to target\r\n     * @param {(Module|RequestPath|string)} source - The channelID to return messages to if needed\r\n     * @param {number} [windowID] - Only looks in this window for instances if provided\r\n     * @returns {Promise<ChannelSender[]>} The channels that were set up for the found modules\r\n     * @async\r\n     * @public\r\n     */\r\n    static async getModuleInstanceChannels(\r\n        module,\r\n        subChannel,\r\n        source,\r\n        windowID\r\n    ) {\r\n        // Get the module class path from the module\r\n        if (module.getClass) module = module.getClass();\r\n        if (module.getPath) module = module.getPath();\r\n\r\n        // Ask for all module instances from main\r\n        const instancePaths = (await IPC.send(\r\n            \"Registry.getModuleInstances\",\r\n            module,\r\n            0\r\n        ))[0];\r\n\r\n        // Get the actual unique request path from the module\r\n        if (source.getPath) source = source.getPath().toString(true);\r\n\r\n        // If a windowID is specified, filter the instancePaths so only ones in the correct window are kept\r\n        if (windowID != undefined)\r\n            instancePaths = instancePaths.filter(path => {\r\n                return path.windowID == windowID;\r\n            });\r\n\r\n        // Create a channel for each of retrieved instance paths\r\n        const channels = instancePaths.map(path => {\r\n            return this.getModuleChannel(path.path, subChannel, source);\r\n        });\r\n\r\n        // Wait for all channels to be created and then return them\r\n        return Promise.all(channels);\r\n    }\r\n    /**\r\n     * A method to set up the required IPC listener for the getModuleInstanceChannels method\r\n     * @returns {undefined}\r\n     * @private\r\n     */\r\n    static __setupGetModuleInstanceChannels() {\r\n        // Make sure to only set this up in the main process\r\n        if (isMain) {\r\n            // Listen for windows/processes requesting instances of a certain module\r\n            IPC.on(\"Registry.getModuleInstances\", event => {\r\n                // Extract the module class path that we are looking for\r\n                const data = event.data;\r\n                const modulePath = data.modulePath;\r\n\r\n                // Return the request path attached to this class\r\n                return this.__data.moduleInstancePaths[modulePath];\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Moves a specific module from one location to another\r\n     * @param {RequestPathPattern} requestPathPattern - A pattern for the module to target\r\n     * @param {WindowHandler~moduleLocation} moduleLocation - The location that the module should move to\r\n     * @param {boolean} [includeEmbeded=false] - Whether to also target embeded modules\r\n     * @returns {Promise<RequestPath[]>} - The request paths of the modules that were moved\r\n     * @async\r\n     * @public\r\n     */\r\n    static async moveModuleTo(\r\n        requestPathPattern,\r\n        moduleLocation,\r\n        includeEmbeded\r\n    ) {\r\n        // Send a request to move the module to all windows/processes\r\n        const responses = await IPC.send(\"Registry.moveModuleTo\", {\r\n            pattern: requestPathPattern.toString(),\r\n            location: moduleLocation,\r\n            includeEmbeded: includeEmbeded,\r\n        });\r\n\r\n        // Create an array to store all module paths\r\n        const modulePaths = [];\r\n\r\n        // Combine all responses to a single array\r\n        responses.forEach(response => {\r\n            // Push all paths to the array\r\n            modulePaths.push.apply(modulePaths, response);\r\n        });\r\n\r\n        // Return the module ids\r\n        return modulePaths;\r\n    }\r\n    /**\r\n     * A method to set up the required IPC listener for the moveModuleTo method\r\n     * @returns {undefined}\r\n     * @private\r\n     */\r\n    static __setupMoveModuleTo() {\r\n        // Listen for windows/processes trying to move modules\r\n        IPC.on(\"Registry.moveModuleTo\", event => {\r\n            // Extract the relevant information\r\n            const pattern = new RequestPathPattern(event.data.pattern);\r\n            const location = event.data.location;\r\n            const includeEmbeded = event.data.includeEmbeded;\r\n\r\n            // Go through all module instances to find any matches\r\n            const modulePaths = Object.keys(this.__data.moduleInstances).filter(\r\n                modulePath => {\r\n                    // Get the module corresponding to this modulePath\r\n                    const module = this.__data.moduleInstances[modulePath];\r\n\r\n                    // Check whether this module is not embeded\r\n                    const embedCheck =\r\n                        includeEmbeded ||\r\n                        !module.getRequest() ||\r\n                        !module.getRequest().embedGUI;\r\n\r\n                    // Check if the pattern matches\r\n                    return embedCheck && pattern.test(modulePath);\r\n                }\r\n            );\r\n\r\n            // Move all matching modules to the specified location and return a promise resolving in the path once the module moved\r\n            return Promise.all(\r\n                modulePaths.map(modulePath => {\r\n                    // Get the module corresponding to this modulePath\r\n                    const module = this.__data.moduleInstances[modulePath];\r\n\r\n                    // Move the module\r\n                    const promise = module.moveTo(location);\r\n\r\n                    // Make the promise resolve into the module's path\r\n                    return promise.then(channelSender => {\r\n                        return modulePath;\r\n                    });\r\n                })\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Waits for a particular module matching the given requestPath to be registered\r\n     * @param {RequestPathPattern} requestPathPattern - A pattern for the module to target\r\n     * @param {boolean} [acceptEmbeded=false] - Whether to also accept embeded modules\r\n     * @returns {Promise<RequestPath>} - The request path that matched the request\r\n     * @async\r\n     * @public\r\n     */\r\n    static async awaitModuleCreation(requestPathPattern, acceptEmbeded) {\r\n        // Send the await call to the main module and return it's promise\r\n        return IPC.send(\r\n            \"Registry.awaitModuleCreation\",\r\n            {\r\n                pattern: requestPathPattern.toString(),\r\n                acceptEmbeded: acceptEmbeded,\r\n            },\r\n            0\r\n        ).then(responses => responses[0]);\r\n    }\r\n    /**\r\n     * A method to set up the required IPC listener for the awaitModuleCreation method\r\n     * @returns {undefined}\r\n     * @private\r\n     */\r\n    static __setupAwaitModuleCreation() {\r\n        // Make sure to only set this up in the main process\r\n        if (isMain) {\r\n            // Listen for windows/processes listening for the creation of a module\r\n            IPC.on(\"Registry.awaitModuleCreation\", event => {\r\n                // Exactract the passed data\r\n                const acceptEmbeded = event.data.acceptEmbeded;\r\n                const pattern = new RequestPathPattern(event.data.pattern);\r\n\r\n                // Check if a module already exists that matches this pattern\r\n                const moduleClassPaths = Object.keys(\r\n                    this.__data.moduleInstancePaths\r\n                );\r\n\r\n                // Create a list to store the matches\r\n                const matches = [];\r\n\r\n                // Go through all paths\r\n                moduleClassPaths.forEach(requestPath => {\r\n                    // Get the list of unique module instance paths from the path\r\n                    const uniquePaths = this.__data.moduleInstancePaths[\r\n                        requestPath\r\n                    ];\r\n\r\n                    // Go through the unique paths\r\n                    uniquePaths.forEach(item => {\r\n                        // Make sure the module is active\r\n                        if (!item.active) return;\r\n\r\n                        // Make sure we either accept embeded modules, or this module isn't embeded\r\n                        if (!acceptEmbeded && item.embeded) return;\r\n\r\n                        // Get the unique path from the item\r\n                        const uniquePath = item.path;\r\n\r\n                        // Test the unique path\r\n                        if (pattern.test(uniquePath)) matches.push(uniquePath);\r\n                    });\r\n                });\r\n\r\n                // Check if any matches were found\r\n                if (matches.length > 0) return matches[0];\r\n\r\n                // If no matches were found, create a promise to return\r\n                let resolver;\r\n                const promise = new Promise(resolve => {\r\n                    resolver = resolve;\r\n                });\r\n\r\n                // Store the awaiter to be resolved later\r\n                this.__data.moduleAwaiters.push({\r\n                    pattern: pattern,\r\n                    acceptEmbeded: acceptEmbeded,\r\n                    resolve: resolver,\r\n                });\r\n\r\n                // Return the promise\r\n                return promise;\r\n            });\r\n        }\r\n    }\r\n\r\n    // Initialisation code for the class\r\n    /**\r\n     * The initial setup method to be called by this file itself, initialises the static fields of the class\r\n     * @return {undefined}\r\n     * @private\r\n     */\r\n    static __setup() {\r\n        // Create an object to store all variables\r\n        this.__data = {};\r\n\r\n        // Stores the listeners for handle and module requests, indexed by type\r\n        this.__data.listeners = {};\r\n\r\n        // Stores the configs, indexed by modulePath\r\n        this.__data.moduleConfigs = {};\r\n\r\n        // Stores instances of modules registered in this window/process by requestPath\r\n        this.__data.moduleInstances = {};\r\n\r\n        // Keep track of modules that are currently being required\r\n        this.__data.requiringModules = [];\r\n\r\n        // Add fields unique to the main process\r\n        if (isMain) {\r\n            // Stores unique module instance request paths, indexed by [request path][UID]\r\n            this.__data.requestPaths = {};\r\n\r\n            // Stores unique module instance request path lists, indexed by module path\r\n            this.__data.moduleInstancePaths = {};\r\n\r\n            // Store listeners for the creation of specific modules\r\n            this.__data.moduleAwaiters = [];\r\n        }\r\n\r\n        // Setup all IPC listeners\r\n        this.__setupRequest();\r\n        this.__setupRegisterRequestListener();\r\n        this.__setupRegisterModuleInstance();\r\n        this.__setupRegisterModuleInstanceCompleted();\r\n        this.__setupDeregisterModuleInstance();\r\n        this.__setupGetModuleInstanceChannels();\r\n        this.__setupMoveModuleTo();\r\n        this.__setupAwaitModuleCreation();\r\n        this.__setupGetModuleConfig();\r\n    }\r\n}\r\nRegistry.__setup();\r\n"]}