{"version":3,"sources":["../../../src/core/registry/registry.js"],"names":["defaultModuleData","location","window","section","Registry","requestHandle","request","hasInvalidUse","use","match","data","embedGUI","_destinationWindowID","WindowHandler","ID","source","Module","getPath","toString","__request","requestModule","requests","arguments","map","type","requestsModules","length","response","i","requestType","_loadModule","config","path","modulePath","moduleClasses","requiringModules","push","moduleImport","require","__getModulesPath","index","indexOf","splice","default","module","_loadConfig","configs","Array","forEach","listeners","__getListeners","dir","split","Path","sep","pop","join","replace","filter","find","_loadAllConfigs","startPath","resolve","__dirname","readDir","reject","FS","readdir","err","files","outConfigs","promises","file","filePath","lstatSync","isDirectory","relativeFilePath","substring","apply","all","then","configLists","back","process","cwd","_registerModuleInstance","moduleInstance","requestPath","IPC","send","getModuleID","moduleInstances","_deregisterModuleInstance","_close","_getModuleInstances","_getModuleInstance","getModuleChannel","subChannelType","senderID","channelSender","ChannelHandler","createSender","elementCreator","core","__data","__getModules","loadingModules","listenerType","priorities","priority","sort","a","b","__getModulesFromConfigs","synced","isMain","modules","sendSync","__finishRequest","requestModules","instantiatePromises","RequestPath","augmentPath","moduleLocation","_destinationSectionID","SettingsHandler","_getModuleLocation","openModuleInstance","e","console","error","channels","channel","getModuleInstanceChannels","subChannel","windowID","getClass","instancePaths","undefined","__setup","on","event","requestPaths","moduleInstancePaths","moduleClass","pathList","sourceID","paths","requestPathString"],"mappings":"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","file":"registry.js","sourcesContent":["import Path from \"path\";\r\nimport FS from \"fs\";\r\nimport isMain from \"../isMain\";\r\nimport Module from \"./module\";\r\nimport RequestPath from \"./requestPath/requestPath\";\r\nimport SettingsHandler from \"../communication/data/settings/settingsHandler\";\r\nimport WindowHandler from \"../window/windowHandler\";\r\nimport ChannelHandler from \"../communication/channel/channelHandler\";\r\nimport IPC from \"../communication/IPC\";\r\n\r\nconst defaultModuleData = {\r\n    location: {\r\n        window: 1,\r\n        section: 0,\r\n    },\r\n};\r\n\r\n/**\r\n * A request that can be made to retrieve a module\r\n * @typedef {Object} Registry~Request\r\n * @property {string} type - The type of handeling you are requesting\r\n * @property {('all'|'one'|function)} [use] - What modules to use to answer the request\r\n * @property {Object} [data] - Any extra data you want to pass that modules can use to determine if they can answer the request\r\n * @property {Module} [source] - The module that sent out the request (can be left out when usimg Module.requestHandle)\r\n * @property {Object} [methods] - Extra methods that can get called by the handle (is only used by Module.requestHandle)\r\n * @property {boolean} [embedGUI] - Whether the module GUI will be embeded into another module\r\n * @property {number} [_destinationWindowID] - The window that the module answering this request should be instanciated in (only used to force a value)\r\n * @property {number} [_destinationSectionID] - The section in the window that the module answering this request should be instanciated in (only used to force a value)\r\n */\r\n\r\n/**\r\n * The data that is stored to track what modules can answer what requests\r\n * @typedef {Object} Registry~Requestlistener\r\n * @property {string} type - The type of request to handle\r\n * @property {Object[]} listeners - The modules that can answer this request\r\n * @property {Class<Module>} listeners[].module - The module class that can answer the request\r\n * @property {function} listeners[].filter - The filter to make sure the class can handle this request\r\n */\r\n\r\n/**\r\n * The format that module configs should be in\r\n * @typedef {Object} Registry~Config\r\n * @property {string} type - The type of request to handle\r\n * @property {Function} [filter] - A method that will get passed a request, that determines whether to use this module and with what priority\r\n * @property {string} [module] - The relative path to the module to use\r\n */\r\n\r\n/**\r\n * @classdesc A class to track all the modules, and handle module requests\r\n * @class\r\n * @hideconstructor\r\n */\r\nexport default class Registry {\r\n    /**\r\n     * Request modules to handle the passed data and establish a connection with these modules\r\n     * @param  {Request} request - The information on how to handle the data\r\n     * @return {Promise<ChannelSender[]>} The channel(s) that have been created to answer the request\r\n     * @async\r\n     * @public\r\n     */\r\n    static requestHandle(request) {\r\n        // Check if the request contains a valid use, if not set it to 'one'\r\n        const hasInvalidUse =\r\n            !request.use ||\r\n            (typeof request.use == \"string\" ||\r\n                !request.use.match(/^(one|all)$/g));\r\n        if (hasInvalidUse) request.use = \"one\";\r\n\r\n        // Ensure at least an empty data object is present in the request\r\n        if (!request.data) request.data = {};\r\n\r\n        // Make sure that when embeding GUI, the result element is opened in the same window\r\n        if (request.embedGUI) request._destinationWindowID = WindowHandler.ID;\r\n\r\n        // Check if the request source type is a module, if so, get its string identifier\r\n        if (request.source instanceof Module)\r\n            request.source = request.source.getPath().toString(true);\r\n\r\n        // let the private __request method handle the request\r\n        return this.__request([request], \"handle\");\r\n    }\r\n\r\n    /**\r\n     * Request module classes of a specific type\r\n     * @param {Request} request - The information on what module to get\r\n     * @returns {(Class<Module>|Array<Class<Module>>)} The module(s) that it could find with the specified type\r\n     * @public\r\n     */\r\n    static requestModule(request) {\r\n        // Get all the requests that were passed (multiple are allowed) TODO: indicate multiple in JSdoc\r\n        var requests = Array.from(arguments);\r\n\r\n        // Normalize the format of the requests\r\n        var requests = requests.map(request => {\r\n            // If the request is only a string rather than an object, turn it into an object\r\n            if (typeof request == \"string\") request = {type: request};\r\n\r\n            // Check if the request contains a valid use, if not set it to 'one'\r\n            const hasInvalidUse =\r\n                !request.use ||\r\n                (typeof request.use == \"string\" ||\r\n                    !request.use.match(/^(one|all)$/g));\r\n            if (hasInvalidUse) request.use = \"one\";\r\n\r\n            // Ensure at least an empty data object is present in the request\r\n            if (!request.data) request.data = {};\r\n\r\n            // Return the new request variable\r\n            return request;\r\n        });\r\n\r\n        // Retrieve the request modules\r\n        const requestsModules = this.__request(requests, \"module\", true);\r\n\r\n        // Format the response appropriately\r\n        if (requestsModules.length > 1) {\r\n            const response = {};\r\n\r\n            // Map the modules to their request types\r\n            for (let i = 0; i < requestsModules.length; i++) {\r\n                const requestType = requests[i].type;\r\n                response[requestType] = requestsModules[i];\r\n            }\r\n\r\n            // Return the modules indexed by request type\r\n            return response;\r\n        } else {\r\n            // Directly return the modules from the only request\r\n            return requestsModules[0];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loads a module at the specified path relative to the modules folder\r\n     * @param {string} path - The path to the module class\r\n     * @returns {Class<Module>} The module class that was loaded\r\n     * @protected\r\n     */\r\n    static _loadModule(config) {\r\n        // Get the path from the config\r\n        const path = config.modulePath;\r\n\r\n        // Only load the module if it hadn't been loaded already\r\n        if (!this.moduleClasses[path]) {\r\n            // Indicate that we have started requiring this module\r\n            this.requiringModules.push(path);\r\n\r\n            // Require module\r\n            const moduleImport = require(this.__getModulesPath(path));\r\n\r\n            // Indicate that we are no longer in the process of loading this module\r\n            const index = this.requiringModules.indexOf(path);\r\n            if (index != -1) this.requiringModules.splice(index, 1);\r\n\r\n            if (moduleImport) {\r\n                // Register the module itself\r\n                this.moduleClasses[path] = moduleImport.default;\r\n\r\n                // Attach the location to the class\r\n                const module = moduleImport.default;\r\n                module.modulePath = path;\r\n\r\n                // Attach the config to the class\r\n                module.config = config;\r\n            }\r\n        }\r\n\r\n        // Return the module\r\n        return this.moduleClasses[path];\r\n    }\r\n\r\n    /**\r\n     * Loads a module config at the specified path relative to the modules folder\r\n     * @param {string} path - The path to the config\r\n     * @param {string} [modulePath] - The modulePath for the config to return\r\n     * @returns {Config[]} The config that was loaded\r\n     * @protected\r\n     */\r\n    static _loadConfig(path, modulePath) {\r\n        // Require the config\r\n        let configs = require(this.__getModulesPath(path)).default;\r\n\r\n        // Normalize it into an array of configs if needed\r\n        if (!(configs instanceof Array)) configs = [configs];\r\n\r\n        // Go through all configs\r\n        configs.forEach(config => {\r\n            // Add listener to the list of listeners for this request type\r\n            const listeners = this.__getListeners(config.type);\r\n            const index = listeners.configs.indexOf(config);\r\n            if (index != -1) return; // Don't add it, if it was already added\r\n\r\n            listeners.configs.push(config);\r\n\r\n            // Get the module path\r\n            let modulePath;\r\n            if (config.module) {\r\n                // Get the directory of the config path\r\n                let dir = path.split(Path.sep);\r\n                dir.pop();\r\n                dir = dir.join(\"/\");\r\n\r\n                // Get the module path relative to this dir\r\n                modulePath = Path.join(dir, config.module);\r\n            } else {\r\n                modulePath = path.replace(/\\.?config/, \"\");\r\n            }\r\n\r\n            // Normalize the path's seperators\r\n            modulePath = modulePath.replace(/\\\\/g, \"/\");\r\n\r\n            // Add a filter to the config if not present\r\n            if (!config.filter) config.filter = () => true;\r\n\r\n            // Attach the location of the module to the config\r\n            config.modulePath = modulePath;\r\n\r\n            // Store the path of the config\r\n            config.path = path;\r\n        });\r\n\r\n        // If a modulePath was defined, return only the config of said path\r\n        if (modulePath)\r\n            return configs.find(config => config.modulePath == modulePath);\r\n\r\n        // Return all the retrieved configs\r\n        return configs;\r\n    }\r\n\r\n    /**\r\n     * Loads all the configs of available modules\r\n     * @returns {Promise<Array<Config>>} All the configs that have been loaded\r\n     * @async\r\n     * @protected\r\n     */\r\n    static _loadAllConfigs() {\r\n        const startPath = Path.resolve(__dirname, this.__getModulesPath());\r\n        const readDir = path => {\r\n            return new Promise((resolve, reject) => {\r\n                FS.readdir(path, (err, files) => {\r\n                    // Store the resulting configs to return\r\n                    const outConfigs = [];\r\n\r\n                    // Store async dir reading promises that have to be resolved\r\n                    const promises = [];\r\n\r\n                    // Read the files\r\n                    files.forEach(file => {\r\n                        const filePath = Path.join(path, file);\r\n                        // Check if this file is a directory or not\r\n                        if (FS.lstatSync(filePath).isDirectory()) {\r\n                            // Recurse on the directory, and store the promise in order to wait for it\r\n                            promises.push(readDir(filePath));\r\n                        } else {\r\n                            // Check if the file is a config, and if so, load it\r\n                            if (file.match(/config\\.js$/g)) {\r\n                                // Get the file path relative to the modules folder\r\n                                const relativeFilePath = filePath.substring(\r\n                                    startPath.length + 1\r\n                                );\r\n\r\n                                // Load the config and add it to the output configs\r\n                                outConfigs.push.apply(\r\n                                    outConfigs,\r\n                                    this._loadConfig(relativeFilePath)\r\n                                );\r\n                            }\r\n                        }\r\n                    });\r\n\r\n                    // Wait for all the directory async recursions to finish\r\n                    Promise.all(promises).then(configLists => {\r\n                        // Add all returned lists to our main list\r\n                        configLists.forEach(configs => {\r\n                            outConfigs.push.apply(outConfigs, configs);\r\n                        });\r\n\r\n                        // Return our main list\r\n                        resolve(outConfigs);\r\n                    });\r\n                });\r\n            });\r\n        };\r\n\r\n        // start the recursive directory reading and return its promise\r\n        return readDir(startPath);\r\n    }\r\n\r\n    /**\r\n     * Returns the relative path from this class to the modules directory\r\n     * @param {String} [path=\"\"] - The path to append to the modules directory\r\n     * @returns {String} The relative path to the directory\r\n     * @private\r\n     */\r\n    static __getModulesPath(path = \"\") {\r\n        // Calculate how many dirs to go up to reach the root\r\n        let back = __dirname.substring(process.cwd().length).split(Path.sep);\r\n        back.pop();\r\n        back = back.map(() => \"..\").join(\"/\");\r\n\r\n        // Get the path from the root to the indicated module\r\n        return Path.join(back, \"dist\", \"modules\", path);\r\n    }\r\n\r\n    /**\r\n     * Registeres the module so the registry knows of its existence\r\n     * @param {Module} moduleInstance - The module to register\r\n     * @returns {number} The unique ID that the module instance has now been assigned\r\n     * @async\r\n     * @protected\r\n     */\r\n    static async _registerModuleInstance(moduleInstance) {\r\n        // Get the a unique ID for the request path\r\n        const requestPath = moduleInstance.getPath();\r\n        const ID = (await IPC.send(\r\n            \"Registry.registerModuleInstance\",\r\n            {\r\n                requestPath: requestPath.toString(true),\r\n            },\r\n            0\r\n        ))[0];\r\n\r\n        // Assign the ID to this request path and return it\r\n        requestPath.getModuleID().ID = ID;\r\n\r\n        // Store the instance in this module/process\r\n        this.moduleInstances[\r\n            moduleInstance.getPath().toString(true)\r\n        ] = moduleInstance;\r\n\r\n        // Return the obtained ID\r\n        return ID;\r\n    }\r\n\r\n    /**\r\n     * Deregisters the module so the registry knows it is no longer used\r\n     * @param {Module} moduleInstance - The module to deregister\r\n     * @returns {undefined}\r\n     * @async\r\n     * @protected\r\n     */\r\n    static async _deregisterModuleInstance(moduleInstance) {\r\n        // Remove the module path in the main process\r\n        const requestPath = moduleInstance.getPath();\r\n        await IPC.send(\r\n            \"Registry.deregisterModuleInstance\",\r\n            {\r\n                requestPath: requestPath.toString(true),\r\n            },\r\n            0\r\n        );\r\n\r\n        // Remove the instance from this process/window\r\n        delete this.moduleInstances[moduleInstance.getPath().toString(true)];\r\n\r\n        // Close this window if there are no more modules in it\r\n        if (Object.keys(this.moduleInstances).length == 0)\r\n            WindowHandler._close();\r\n    }\r\n\r\n    /**\r\n     * Returns the modules that are currently registered\r\n     * @returns {Module[]} The modules are currently registered\r\n     * @protected\r\n     */\r\n    static _getModuleInstances() {\r\n        return this.moduleInstances;\r\n    }\r\n\r\n    /**\r\n     * Returns the module with a certain request path if available in the window\r\n     * @param {(string|RequestPath)} requestPath - The unique request path of the module you are looking for\r\n     * @returns {(Module|null)} The modules that got found\r\n     * @protected\r\n     */\r\n    static _getModuleInstance(requestPath) {\r\n        // Normalize the path to a string\r\n        if (typeof requestPath != \"string\")\r\n            requestPath = requestPath.toString(true);\r\n\r\n        // Go through all instances to find a module that matches this path\r\n        return this.moduleInstances[requestPath];\r\n    }\r\n\r\n    /**\r\n     * Establishes a connection with a module with the defined requestPath\r\n     * @param {(string|requestPath)} requestPath - The unique request path of the module you are trying to conenct to\r\n     * @param {string} [subChannelType=undefined] - The sub channel to connect with\r\n     * @param {string} [senderID=undefined] - The channel ID to send messages back to for communication\r\n     * @returns {ChannelSender} A channel set up for communication with the specified module\r\n     * @async\r\n     * @public\r\n     */\r\n    static async getModuleChannel(requestPath, subChannelType, senderID) {\r\n        // Normalize the path to a string\r\n        if (typeof requestPath != \"string\")\r\n            requestPath = requestPath.toString(true);\r\n\r\n        // Create a channel sender to this module instance and return it\r\n        const channelSender = await ChannelHandler.createSender(\r\n            requestPath,\r\n            subChannelType,\r\n            senderID\r\n        );\r\n\r\n        // Find the requested module instance in this window (if present in this window)\r\n        const module = Registry._getModuleInstance(requestPath);\r\n\r\n        // Check if the module exists, and if so extract its element creator\r\n        if (module) {\r\n            const elementCreator = module.core.elementCreator;\r\n\r\n            // Attach the elementCreator to the channel\r\n            channelSender.__data.elementCreator = elementCreator;\r\n        }\r\n\r\n        // Return the channelSender\r\n        return channelSender;\r\n    }\r\n\r\n    /**\r\n     * Creates an object to store what classes can answer a certain request type if it hasn't been created already, and returns it\r\n     * @param {String} type - The request type to return the object of\r\n     * @returns {Registry~Requestlistener} An object that tracks the listeners for a certain request type\r\n     * @private\r\n     */\r\n    static __getListeners(type) {\r\n        // Create listeners type variable if not available\r\n        if (!this.listeners[type])\r\n            this.listeners[type] = {\r\n                type: type,\r\n                configs: [],\r\n            };\r\n\r\n        // Return listener type\r\n        return this.listeners[type];\r\n    }\r\n\r\n    /**\r\n     * Retrieves the modules that can handle the passed request\r\n     * @param {Registry~Request} request - The request to find module classes for\r\n     * @param {string[]} loadingModules - A list of module paths that are currently being required\r\n     * @returns {(Class<Module>|Array<Class<Module>>)} The module classes that have been chosen to handle the request\r\n     * @private\r\n     */\r\n    static __getModules(request, loadingModules) {\r\n        // Get the module listeners to handle this type of request\r\n        const listenerType = this.__getListeners(request.type);\r\n\r\n        // Map modules with their priority to this particular request\r\n        const priorities = listenerType.configs\r\n            .map(config => {\r\n                return {\r\n                    priority: config.filter(request),\r\n                    config: config,\r\n                };\r\n            })\r\n            .filter(\r\n                priority =>\r\n                    priority.priority > 0 &&\r\n                    loadingModules.indexOf(priority.config.modulePath) == -1\r\n            );\r\n\r\n        // Sort the results\r\n        priorities.sort((a, b) => b.priority - a.priority);\r\n\r\n        // Determine what modules to return\r\n        if (request.use == \"all\") {\r\n            // If all modules should be returned, simply extract the modules from the priority data and return them\r\n            return this.__getModulesFromConfigs(priorities.map(a => a.config));\r\n        } else if (typeof request.use == \"Function\") {\r\n            // If a filter function is provided, apply it and then extract the modules from the data and return them\r\n            return this.__getModulesFromConfigs(\r\n                priorities.filter(request.use).map(a => a.config)\r\n            );\r\n        } else {\r\n            // Otherwise only a single module should be returned, so simply return this module\r\n            return (\r\n                priorities[0] &&\r\n                this.__getModulesFromConfigs([priorities[0].config])[0]\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Goes through the array of configs and maps it to the modules of the configs (requires modules if needed)\r\n     * @param {Registry~config[]} configs - The configs to get the modules from\r\n     * @returns {Array<Class<Module>>} The modules that got extracted fromt he configs\r\n     * @private\r\n     */\r\n    static __getModulesFromConfigs(configs) {\r\n        return configs.map(config => {\r\n            // Require the module from its path if this hasn't happened yet\r\n            if (!(config.module instanceof Module)) {\r\n                // Load the module from the config\r\n                const module = this._loadModule(config);\r\n\r\n                // Store the module\r\n                config.module = module;\r\n            }\r\n\r\n            // Return the module itself, which should now in no situation be a path\r\n            return config.module;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Handles one or more requests and serves the responses\r\n     * @param {Registry~Request[]} requests - The requests to make\r\n     * @param {('module'|'handle')} type - The type of request that was made (either to handle data, or to get modules)\r\n     * @param {boolean} synced - Whether or not to request data synchronously (can only be synced if type=='module')\r\n     * @returns {(Promise<Array<Array<Class<Module>>>>|Promise<ChannelSender[]>|Promise<ChannelSender>)} The data that the request results in\r\n     * @private\r\n     */\r\n    static __request(requests, type, synced) {\r\n        if (synced) {\r\n            if (isMain) {\r\n                // Directly resolve the request as we have access to all modules\r\n                return requests.map(request => {\r\n                    return this.__getModules(request, this.requiringModules);\r\n                });\r\n            } else {\r\n                // Send a command to the main window to look for modules to resolve the request\r\n                const modules = IPC.sendSync(\"Registry.request\", {\r\n                    requests: requests,\r\n                    requiringModules: this.requiringModules,\r\n                });\r\n\r\n                return modules[0];\r\n            }\r\n        } else {\r\n            // Retrieve the modules to resolve the request\r\n            if (isMain) {\r\n                // Directly resolve the request as we have access to all modules\r\n                const requestsModules = requests.map(request => {\r\n                    return this.__getModules(request, this.requiringModules);\r\n                });\r\n                return this.__finishRequest(type, requests, requestsModules);\r\n            } else {\r\n                // Send a command to the main window to look for modules to resolve the request\r\n                const requestsModules = IPC.sendSync(\r\n                    \"Registry.request\",\r\n                    {\r\n                        requests: requests,\r\n                        requiringModules: this.requiringModules,\r\n                    },\r\n                    0\r\n                );\r\n                return this.__finishRequest(type, requests, requestsModules);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Finishes the request by serving the correct data based on the module classes that were found\r\n     * @param {('module'|'handle')} type - The type of request that was made (either to handle data, or to get modules)\r\n     * @param {Registry~Request[]} requests - The requests that are being finished (only contains 1 if type=='handle')\r\n     * @param {Array<Array<Class<Module>>>} requestsModules - The modules that are found to match each request\r\n     * @returns {(Promise<Array<Array<Class<Module>>>>|Promise<ChannelSender[]>|Promise<ChannelSender>)} The data that the request results in\r\n     * @async\r\n     * @private\r\n     */\r\n    static async __finishRequest(type, requests, requestsModules) {\r\n        // Resolve request by simply returning the module if it was a module request,\r\n        //      or instanciate a module and return a channel on a handle request\r\n        if (type == \"module\") {\r\n            return requestsModules;\r\n        } else if (type == \"handle\") {\r\n            // The handle type only permits 1 request to exist\r\n            let requestModules = requestsModules[0];\r\n            const request = requests[0];\r\n\r\n            // In order to batch the await, instead of waiting between each open instance request\r\n            const instantiatePromises = [];\r\n\r\n            if (!(requestModules instanceof Array))\r\n                requestModules = [requestModules];\r\n\r\n            // Go through modules for 1 request\r\n            requestModules.forEach(module => {\r\n                try {\r\n                    // Create the proper request path\r\n                    let source;\r\n                    if (request.source) {\r\n                        source = new RequestPath(request.source).augmentPath(\r\n                            module\r\n                        );\r\n                    } else {\r\n                        source = new RequestPath(module);\r\n                    }\r\n\r\n                    // Attempt to retrieve the correct startup location\r\n                    let moduleLocation;\r\n\r\n                    // Check if the request defined a location\r\n                    if (request._destinationWindowID != null) {\r\n                        // If it did, use this\r\n                        moduleLocation = {\r\n                            window: request._destinationWindowID,\r\n                            section: request._destinationSectionID || 0,\r\n                        };\r\n                    } else {\r\n                        // Otherwise load the location from the settings\r\n                        moduleLocation = SettingsHandler._getModuleLocation(\r\n                            source\r\n                        );\r\n                    }\r\n\r\n                    // Open the window that the module should appear in\r\n                    instantiatePromises.push(\r\n                        WindowHandler.openModuleInstance(\r\n                            moduleLocation,\r\n                            request,\r\n                            module\r\n                        )\r\n                    );\r\n                } catch (e) {\r\n                    // TODO: properply handle the error if something goes wrong\r\n                    console.error(\r\n                        `Something went wrong while trying to instantiate ${module}: `,\r\n                        e\r\n                    );\r\n                }\r\n            });\r\n\r\n            // Wait for all the promises to resolve and get their channels\r\n            const channels = await Promise.all(instantiatePromises);\r\n\r\n            // Determine whether to return only a single channel or an array of channels and return it\r\n            if (request.use == \"one\") {\r\n                return channels[0];\r\n            } else {\r\n                return channels.filter(channel => channel); // Remove failed instanciations\r\n            }\r\n        }\r\n    }\r\n\r\n    // TODO: test if this method works at all\r\n    /**\r\n     * Gets channels to all instances of a specific module class\r\n     * @param {(Class<Module>|Module)} module - The module to get the instance of\r\n     * @param {string} [subChannel] - The sub channel to target\r\n     * @param {(Module|string)} source - The channelID to return messages to if needed\r\n     * @param {number} [windowID] - Only looks in this window for instances if provided\r\n     * @returns {Promise<ChannelSender[]>} The channels that were set up for the found modules\r\n     * @async\r\n     * @public\r\n     */\r\n    static async getModuleInstanceChannels(\r\n        module,\r\n        subChannel,\r\n        source,\r\n        windowID\r\n    ) {\r\n        // Get the module class path from the module\r\n        if (module.getClass) module = module.getClass();\r\n        if (module.getPath) module = module.getPath();\r\n\r\n        // Ask for all module instances from main\r\n        const instancePaths = (await IPC.send(\r\n            \"Registry.getModuleInstances\",\r\n            module,\r\n            0\r\n        ))[0];\r\n\r\n        // Get the actual unique request path from the module\r\n        if (source.getPath) source = source.getPath().toString(true);\r\n\r\n        // If a windowID is specified, filter the instancePaths so only ones in the correct window are kept\r\n        if (windowID != undefined)\r\n            instancePaths = instancePaths.filter(path => {\r\n                return path.windowID == windowID;\r\n            });\r\n\r\n        // Create a channel for each of retrieved instance paths\r\n        const channels = instancePaths.map(path => {\r\n            return ChannelHandler.createSender(path.path, subChannel, source);\r\n        });\r\n\r\n        // Wait for all channels to be created and then return them\r\n        return Promise.all(channels);\r\n    }\r\n\r\n    /**\r\n     * The initial setup method to be called by this file itself, initialises the static fields of the class\r\n     * @return {undefined}\r\n     * @private\r\n     */\r\n    static __setup() {\r\n        // Stores the listeners for handle and module requests, indexed by type\r\n        this.listeners = {};\r\n\r\n        // Stores the registered modules themselves, indexed by path\r\n        this.moduleClasses = {};\r\n\r\n        // Stores instances of modules registered in this window/process by requestPath\r\n        this.moduleInstances = {};\r\n\r\n        // Keep track of modules that are currently being required\r\n        this.requiringModules = [];\r\n\r\n        // Set up the IPC listeners in the renderers and main process to allow renderers to request modules\r\n        if (isMain) {\r\n            // Filter out possible modules in this window to handle the handle request\r\n            IPC.on(\"Registry.request\", event => {\r\n                const requests = event.data.requests;\r\n                const requiringModules = event.data.requiringModules;\r\n\r\n                // Retrieve the priority mapping for every request\r\n                const requestsModules = requests.map(request => {\r\n                    return this.__getModules(request, requiringModules);\r\n                });\r\n\r\n                // Return the mapping of modules and their priorities\r\n                return requestsModules;\r\n            });\r\n\r\n            // Stores unique module instance request paths, indexed by [request path][UID]\r\n            this.requestPaths = {};\r\n\r\n            // Stores unique module instance request path lists, indexed by module path\r\n            this.moduleInstancePaths = {};\r\n\r\n            // Listen for module instances being registered\r\n            IPC.on(\"Registry.registerModuleInstance\", event => {\r\n                // Get the request path for the module to register\r\n                const requestPath = new RequestPath(event.data.requestPath);\r\n\r\n                // Get the module class of the path to register\r\n                const moduleClass = requestPath.getModuleID().module;\r\n\r\n                // Retrieve the request path list that exists for that class, or create it if non-existent\r\n                let pathList = this.moduleInstancePaths[moduleClass];\r\n                if (!pathList)\r\n                    pathList = this.moduleInstancePaths[moduleClass] = [];\r\n\r\n                // Add this path to the list together with the window it is stored in\r\n                pathList.push({\r\n                    window: event.sourceID,\r\n                    path: requestPath.toString(true),\r\n                });\r\n\r\n                // Retrieve the path collection that exists for this non unique request path, or create it if non-existent\r\n                let paths = this.requestPaths[requestPath.toString()];\r\n                if (!paths)\r\n                    paths = this.requestPaths[requestPath.toString()] = {};\r\n\r\n                // Find a unique ID in this collection\r\n                let ID = 0;\r\n                while (paths[ID]) ID++;\r\n\r\n                // Asssign this unique ID to the last module of the request path and store the path\r\n                requestPath.getModuleID().ID = ID;\r\n                paths[ID] = requestPath;\r\n\r\n                // Return the unique request path identifier\r\n                return ID;\r\n            });\r\n\r\n            // Listen for module instances being deregistered\r\n            IPC.on(\"Registry.deregisterModuleInstance\", event => {\r\n                // Get the request path for the module to deregister\r\n                const requestPath = new RequestPath(event.data.requestPath);\r\n\r\n                // Get the module class of the path to deregister\r\n                const moduleClass = requestPath.getModuleID().module;\r\n\r\n                // Get the paths that are stored for this class\r\n                const pathList = this.moduleInstancePaths[moduleClass];\r\n                if (pathList) {\r\n                    // get the unique request path in string form\r\n                    const requestPathString = requestPath.toString(true);\r\n\r\n                    // Filter out the object that corresponds with this string\r\n                    this.moduleInstancePaths[moduleClass] = pathList.filter(\r\n                        path => {\r\n                            return path.path != requestPathString;\r\n                        }\r\n                    );\r\n                }\r\n\r\n                // Get the unique path identifier from the request path\r\n                const ID = requestPath.getModuleID().ID;\r\n\r\n                // Retrieve the path collection that exists for this non unique request path, and delete the path with this unique ID\r\n                const paths = this.requestPaths[requestPath.toString()];\r\n                if (paths) delete paths[ID];\r\n            });\r\n\r\n            // Listen for windows/processes requesting instances of a certain module\r\n            IPC.on(\"Registry.getModuleInstances\", event => {\r\n                // Extract the module class path that we are looking for\r\n                const data = event.data;\r\n                const modulePath = data.modulePath;\r\n\r\n                // Return the request path attached to this class\r\n                return this.moduleInstancePaths[modulePath];\r\n            });\r\n        }\r\n    }\r\n}\r\nRegistry.__setup();\r\n"]}