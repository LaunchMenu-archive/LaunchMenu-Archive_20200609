{"version":3,"sources":["../../../src/core/registry/registry.js"],"names":["globalModulePath","Registry","requestHandle","data","request","use","__request","requestModule","register","Class","classListeners","modulePath","modules","class","listeners","forEach","listener","module","__getListeners","type","push","loadModule","path","require","__getModulesPath","loadAllModules","_registerModuleInstance","moduleInstance","resolve","reject","requestPath","getPath","IPC","send","toString","then","responses","ID","getModuleID","_deregisterModuleInstance","Path","join","__getModules","listenerType","priorities","map","priority","filter","sort","a","b","__resolveRequest","synced","isMain","sendSync","__setup","on","event","moduleInstancePaths","RequestPath","paths","IDS","indexOf"],"mappings":"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","file":"registry.js","sourcesContent":["import Path from \"path\";\r\nimport isMain from \"../isMain\";\r\nimport IPC from \"../communication/IPC\";\r\nvar globalModulePath;\r\n/**\r\n * A class to track all the modules, and handle module requests\r\n */\r\nclass Registry{\r\n    /**\r\n     * Request modules to handle the passed data and establish a connection with these modules\r\n     * @param  {{type:String, execute:String|function, data:Object, source:Module}} data The information on how to handle the data\r\n     * @return {Promise} The Promise that shall return the channels created to communicate with the modules\r\n     */\r\n    static requestHandle(data){\r\n        if(!request.use) request.use = \"all\";\r\n        return this.__request(request, \"handle\");\r\n    }\r\n    static requestModule(request){\r\n        if(!request.use) request.use = \"one\";\r\n        return this.__request(request, \"module\", true);\r\n    }\r\n    /**\r\n     * Registers a module in the registry such that it can be requested by other modules\r\n     * @param  {Class} Class The class of the module you want to register\r\n     * @param  {{type:String, filter:function(request)}} classListener An event you would like this module to act on\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    static register(Class, ...classListeners){\r\n        // Set the path of the module\r\n        Class.modulePath = globalModulePath;\r\n\r\n        // Register the module itself\r\n        this.modules[Class.modulePath] = {\r\n            class: Class,\r\n            listeners: classListeners\r\n        };\r\n\r\n        // Register all the listeners\r\n        classListeners.forEach(listener=>{\r\n            // Keep a connection with the module itself\r\n            listener.module = Class;\r\n\r\n            // Add to the list of listeners for this request type\r\n            const listeners = this.__getListeners(listener.type);\r\n            listeners.listeners.push(listener);\r\n        });\r\n    }\r\n\r\n    // Protected methods\r\n    static loadModule(path){\r\n        if(!this.modules[path]){\r\n            globalModulePath = path;\r\n            require(this.__getModulesPath(path));\r\n        }\r\n        return this.modules[path] && this.modules[path].class;\r\n    }\r\n    static loadAllModules(){\r\n        //TODO make a module loader\r\n    }\r\n\r\n    // Protected methods\r\n    static _registerModuleInstance(moduleInstance){\r\n        return new Promise((resolve, reject)=>{\r\n            const requestPath = moduleInstance.getPath();\r\n            IPC.send(\"Registry.registerModuleInstance\", {\r\n                requestPath: requestPath.toString(true)\r\n            }, 0).then(responses=>{\r\n                const ID = responses[0];\r\n                requestPath.getModuleID().ID = ID;\r\n                resolve(ID);\r\n            });\r\n        });\r\n    }\r\n    static _deregisterModuleInstance(moduleInstance){\r\n        return new Promise((resolve, reject)=>{\r\n            const requestPath = moduleInstance.getPath();\r\n            IPC.send(\"Registry.deregisterModuleInstance\", {\r\n                requestPath: requestPath.toString(true)\r\n            }, 0).then(responses=>{\r\n                resolve();\r\n            });\r\n        });\r\n    }\r\n\r\n    // Private methods\r\n    /**\r\n     * Creates the listener variable for a certain type if necessary, and returns it\r\n     * @param  {String} type The request type to return the listener of\r\n     * @return {{type:String, listeners:[{module:Module, filter:function(request)}, ...]}} An object that tracks the listeners for a certain request type\r\n     */\r\n    static __getListeners(type){\r\n        // Create listeners type variable if not available\r\n        if(!this.listeners[type])\r\n            this.listeners[type] = {\r\n                type: type,\r\n                listeners: []\r\n            };\r\n\r\n        // Return listener type\r\n        return this.listeners[type];\r\n    }\r\n    /**\r\n     * Returns the relative path from this class to the modules directory\r\n     * @param  {String} [path=\"\"] The path to append to the modules directory\r\n     * @return {String}           The relative path to the directory\r\n     */\r\n    static __getModulesPath(path=\"\"){\r\n        return Path.join(\"..\", \"..\", \"modules\", path);\r\n    }\r\n\r\n    static __getModules(request){\r\n        // Get the module listeners to handle this type of request\r\n        const listenerType = this.__getListeners(request.type);\r\n\r\n        // Map modules with their priority to this particular request\r\n        const priorities = listenerType.listeners.map(listener=>{\r\n            return {\r\n                priority:listener.filter(request),\r\n                module:listener.module\r\n            };\r\n        }).filter(priority=>priority.priority>0);\r\n\r\n        // Sort the results\r\n        priorities.sort((a,b)=>b.priority-a.priority);\r\n\r\n        // Determine what modules to return\r\n        if(request.use==\"all\"){\r\n            return priorities.map(a=>a.module);\r\n        }else if(typeof(request.use)==\"Function\"){\r\n            return priorities.filter(request.use).map(a=>a.module);\r\n        }else{\r\n            return priorities[0] && priorities[0].module;\r\n        }\r\n    }\r\n    static __resolveRequest(type, modules){\r\n        return new Promise((resolve, reject)=>{\r\n            // Resolve request by simply returning the module if it was a module request,\r\n            //      or instanciate a module and return a channel on a handle request\r\n            if(type==\"module\"){\r\n                resolve(modules);\r\n            }else if(type==\"handle\"){\r\n                //TODO make handle requests instantiate modules and return channels\r\n                modules.forEach(module=>{\r\n\r\n                });\r\n            }\r\n        })\r\n    }\r\n    static __request(request, type, synced){\r\n        if(synced){\r\n            if(isMain){\r\n                // Directly resolve the request as we have access to all modules\r\n                return this.__getModules(request.data);\r\n            }else{\r\n                // Send a command to the main window to look for modules to resolve the request\r\n                return IPC.sendSync(\"Registry.request\", request)[0];\r\n            }\r\n        }else{\r\n            // Retrieve the modules to resolve the request\r\n            return new Promise((resolve, reject)=>{\r\n                if(isMain){\r\n                    // Directly resolve the request as we have access to all modules\r\n                    const modules = this.__getModules(request);\r\n                    this.__resolveRequest(type, modules).then(resolve);\r\n                }else{\r\n                    // Send a command to the main window to look for modules to resolve the request\r\n                    IPC.send(\"Registry.request\", request, 0).then(responses=>{\r\n                        const modules = responses[0];\r\n\r\n                        this.__resolveRequest(type, modules).then(resolve);\r\n                    });\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The initial setup method to be called by this file itself, initialises the static fields of the class\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    static __setup(){\r\n        // Stores the listeners for handle and module requests, indexed by type\r\n        this.listeners = {};\r\n\r\n        // Stores the registered modules themselves, indexed by path\r\n        this.modules = {};\r\n\r\n        // Set up the IPC listeners in the renderers and main process to allow renderers to request modules\r\n        if(isMain){\r\n            // Filter out possible modules in this window to handle the handle request\r\n            IPC.on(\"Registry.request\", event=>{\r\n                const request = event.data;\r\n\r\n                // Retrieve the priority mapping\r\n                const modules = this.__getModules(request);\r\n\r\n                // Return the mapping of modules and their priorities\r\n                return modules;\r\n                // IPC.send(\"Registry.returnRequest\", {modules:modules, requestID:request.ID}, source);\r\n            });\r\n\r\n\r\n            // Stores lists of unique module instance request paths, indexed by request paths\r\n            this.moduleInstancePaths = {};\r\n\r\n            // Listen for module instances being registered\r\n            IPC.on(\"Registry.registerModuleInstance\", event=>{\r\n                const requestPath = new RequestPath(event.data.requestPath);\r\n                let paths = this.moduleInstancePaths[requestPath.toString()];\r\n                if(!paths)\r\n                paths = this.moduleInstancePaths[requestPath.toString()] = {};\r\n\r\n                let IDS = Object.values(paths).map(path=>path.getModuleID().ID);\r\n                let ID = 0;\r\n                while(IDS.indexOf(ID)!=-1) ID++;\r\n                requestPath.getModuleID().ID = ID;\r\n                this.moduleInstancePaths[requestPath.toString()] = requestPath;\r\n                return ID;\r\n            });\r\n\r\n            // Listen for module instances being deregistered\r\n            IPC.on(\"Registry.deregisterModuleInstance\", event=>{\r\n                const requestPath = new RequestPath(event.data.requestPath);\r\n                let paths = this.moduleInstancePaths[requestPath.toString()];\r\n                if(paths){\r\n                    delete paths[requestPath.toString(true)];\r\n                }\r\n            });\r\n        }\r\n    }\r\n};\r\nRegistry.__setup();\r\nexport default Registry;\r\n"]}