{"version":3,"sources":["../../../src/core/registry/registry.js"],"names":["defaultModuleData","location","window","section","Registry","requestHandle","request","use","match","source","Module","getPath","toString","__request","requestModule","requests","arguments","map","type","requestsModules","length","response","i","requestType","_loadModule","path","moduleClasses","data","require","__getModulesPath","clas","default","config","modulePath","module","listeners","__getListeners","push","_loadAllModules","_registerModuleInstance","moduleInstance","moduleInstances","requestPath","ID","IPC","send","getModuleID","_deregisterModuleInstance","index","indexOf","splice","WindowHandler","_close","_getModuleInstanceCount","Path","join","__getModules","listenerType","priorities","listener","priority","filter","sort","a","b","__finishRequest","requestModules","instantiatePromises","Array","forEach","RequestPath","augmentPath","moduleData","SettingsHandler","_getModuleFile","openModuleInstance","e","console","error","channels","all","channel","synced","isMain","sendSync","then","responses","getModuleInstanceChannels","subChannel","windowID","instancePaths","undefined","ChannelHandler","createSender","__setup","on","event","requestPaths","moduleInstancePaths","pathList","sourceID","paths","requestPathString"],"mappings":"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","file":"registry.js","sourcesContent":["import Path from \"path\";\r\nimport isMain from \"../isMain\";\r\nimport Module from \"./module\";\r\nimport RequestPath from \"./requestPath\";\r\nimport SettingsHandler from \"../communication/data/settings/settingsHandler\";\r\nimport WindowHandler from \"../window/windowHandler\";\r\nimport ChannelHandler from \"../communication/channel/channelHandler\";\r\nimport IPC from \"../communication/IPC\";\r\n\r\nconst defaultModuleData = {\r\n    location: {\r\n        window: 1,\r\n        section: 0,\r\n    },\r\n};\r\n\r\n/**\r\n * @typedef {Object} Registry~Request\r\n * @property {string} type - The type of handeling you are requesting\r\n * @property {('all'|'one'|'function')} [use] - What modules to use to answer the request\r\n * @property {Object} [data] - Any extra data you want to pass that modules can use to determine if they can answer the request\r\n * @property {Module} [source] - The module that sent out the request (can be left out when usimg Module.requestHandle)\r\n * @property {Object} [methods] - Extra methods that can get called by the handle (is only used by Module.requestHandle)\r\n */\r\n\r\n/**\r\n * @typedef {Object} Registry~Requestlistener\r\n * @property {string} type - The type of request to handle\r\n * @property {Object[]} listeners - The modules that can answer this request\r\n * @property {Class<Module>} listeners[].module - The module class that can answer the request\r\n * @property {function} listeners[].filter - The filter to make sure the class can handle this request\r\n */\r\n\r\n/**\r\n * @classdesc A class to track all the modules, and handle module requests\r\n * @class\r\n * @hideconstructor\r\n */\r\nclass Registry {\r\n    /**\r\n     * Request modules to handle the passed data and establish a connection with these modules\r\n     * @param  {Request} request - The information on how to handle the data\r\n     * @return {Promise<ChannelSender[]>} The channel(s) that have been created to answer the request\r\n     * @async\r\n     * @public\r\n     */\r\n    static requestHandle(request) {\r\n        if (\r\n            !request.use ||\r\n            (typeof request.use == \"string\" ||\r\n                !request.use.match(/^(one|all)$/g))\r\n        )\r\n            request.use = \"one\";\r\n        if (request.source instanceof Module)\r\n            request.source = request.source.getPath().toString(true);\r\n        return this.__request([request], \"handle\");\r\n    }\r\n\r\n    /**\r\n     * Request module classes of a specific type\r\n     * @param {Request} request - The information on what module to get\r\n     * @returns {(Class<Module>|Array<Class<Module>>)} The module(s) that it could find with the specified type\r\n     * @public\r\n     */\r\n    static requestModule(request) {\r\n        var requests = Array.from(arguments);\r\n\r\n        // Normalize the request format\r\n        var requests = requests.map(request => {\r\n            if (typeof request == \"string\") request = {type: request};\r\n            if (\r\n                !request.use ||\r\n                (typeof request.use == \"string\" ||\r\n                    !request.use.match(/^(one|all)$/g))\r\n            )\r\n                request.use = \"one\";\r\n            return request;\r\n        });\r\n\r\n        // Retrieve the request modules\r\n        const requestsModules = this.__request(requests, \"module\", true);\r\n\r\n        // Format the response appropriately\r\n        if (requestsModules.length > 1) {\r\n            const response = {};\r\n\r\n            // Map the modules to their request types\r\n            for (let i = 0; i < requestsModules.length; i++) {\r\n                const requestType = requests[i].type;\r\n                response[requestType] = requestsModules[i];\r\n            }\r\n\r\n            return response;\r\n        } else {\r\n            // Directly return the modules from the only request\r\n            return requestsModules[0];\r\n        }\r\n    }\r\n\r\n    // Protected methods\r\n    /**\r\n     * Loads a module at the specified path relative to the modules folder\r\n     * @param {string} path - The path to the module class\r\n     * @returns {Class<Module>} The module class\r\n     * @protected\r\n     */\r\n    static _loadModule(path) {\r\n        if (!this.moduleClasses[path]) {\r\n            // Require module\r\n            const data = require(this.__getModulesPath(path));\r\n\r\n            // Verify all necessary data is passed\r\n            if (data) {\r\n                const clas = data.default;\r\n                const config = data.config;\r\n                if (config) {\r\n                    // Augment data with some variables that can be extracted\r\n                    clas.modulePath = path;\r\n                    config.module = clas;\r\n\r\n                    // Register the module itself\r\n                    this.moduleClasses[path] = data;\r\n\r\n                    // Add listener to the list of listeners for this request type\r\n                    const listeners = this.__getListeners(config.type);\r\n                    listeners.listeners.push(config);\r\n                } else {\r\n                    return data;\r\n                }\r\n            }\r\n        }\r\n        return this.moduleClasses[path];\r\n    }\r\n    /**\r\n     * Loads all the modules\r\n     * @returns {Array<Class<Module>>} All the module classes that have been loaded\r\n     * @protected\r\n     */\r\n    static _loadAllModules() {\r\n        //TODO: make a module loader\r\n    }\r\n\r\n    /**\r\n     * Registeres the module so the registry knows of its existence\r\n     * @param {Module} moduleInstance - The module to register\r\n     * @returns {number} The unique ID that the module instance has now been assigned\r\n     * @async\r\n     * @protected\r\n     */\r\n    static async _registerModuleInstance(moduleInstance) {\r\n        // Store the instance in this module/process\r\n        this.moduleInstances.push(moduleInstance);\r\n\r\n        // Set the proper ID for the request path\r\n        const requestPath = moduleInstance.getPath();\r\n        const ID = (await IPC.send(\r\n            \"Registry.registerModuleInstance\",\r\n            {\r\n                requestPath: requestPath.toString(true),\r\n            },\r\n            0\r\n        ))[0];\r\n        requestPath.getModuleID().ID = ID;\r\n        return ID;\r\n    }\r\n\r\n    /**\r\n     * Deregisters the module so the registry knows it is no longer used\r\n     * @param {Module} moduleInstance - The module to deregister\r\n     * @returns {undefined}\r\n     * @async\r\n     * @protected\r\n     */\r\n    static async _deregisterModuleInstance(moduleInstance) {\r\n        // Remove the module path in the main process\r\n        const requestPath = moduleInstance.getPath();\r\n        await IPC.send(\r\n            \"Registry.deregisterModuleInstance\",\r\n            {\r\n                requestPath: requestPath.toString(true),\r\n            },\r\n            0\r\n        );\r\n\r\n        // Remove the instance from this module/process\r\n        const index = this.moduleInstances.indexOf(moduleInstance);\r\n        if (index !== -1) this.moduleInstances.splice(index, 1);\r\n        if (this.moduleInstances.length == 0) WindowHandler._close();\r\n    }\r\n\r\n    /**\r\n     * Returns the amount of modules that are currently registered\r\n     * @returns {number} The amount of modules are currently registered\r\n     * @protected\r\n     */\r\n    static _getModuleInstanceCount() {\r\n        return this.moduleInstances.length;\r\n    }\r\n\r\n    // Private methods\r\n    /**\r\n     * Creates an object to store what classes can answer a certain request type if it hasn't been created already, and returns it\r\n     * @param {String} type - The request type to return the object of\r\n     * @returns {Registry~Requestlistener} An object that tracks the listeners for a certain request type\r\n     * @private\r\n     */\r\n    static __getListeners(type) {\r\n        // Create listeners type variable if not available\r\n        if (!this.listeners[type])\r\n            this.listeners[type] = {\r\n                type: type,\r\n                listeners: [],\r\n            };\r\n\r\n        // Return listener type\r\n        return this.listeners[type];\r\n    }\r\n\r\n    /**\r\n     * Returns the relative path from this class to the modules directory\r\n     * @param {String} [path=\"\"] - The path to append to the modules directory\r\n     * @returns {String} The relative path to the directory\r\n     * @private\r\n     */\r\n    static __getModulesPath(path = \"\") {\r\n        return Path.join(\"..\", \"..\", \"modules\", path);\r\n    }\r\n\r\n    /**\r\n     * Retrieves the modules that can handle the passed request\r\n     * @param {Registry~Request} request - The request to find module classes for\r\n     * @returns {(Class<Module>|Array<Class<Module>>)} The module classes that have been chosen to handle the request\r\n     * @private\r\n     */\r\n    static __getModules(request) {\r\n        // Get the module listeners to handle this type of request\r\n        const listenerType = this.__getListeners(request.type);\r\n\r\n        // Map modules with their priority to this particular request\r\n        const priorities = listenerType.listeners\r\n            .map(listener => {\r\n                return {\r\n                    priority: listener.filter(request),\r\n                    module: listener.module,\r\n                };\r\n            })\r\n            .filter(priority => priority.priority > 0);\r\n\r\n        // Sort the results\r\n        priorities.sort((a, b) => b.priority - a.priority);\r\n\r\n        // Determine what modules to return\r\n        if (request.use == \"all\") {\r\n            return priorities.map(a => a.module);\r\n        } else if (typeof request.use == \"Function\") {\r\n            return priorities.filter(request.use).map(a => a.module);\r\n        } else {\r\n            return priorities[0] && priorities[0].module;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Finishes the request by serving the correct data based on the module classes that were found\r\n     * @param {('module'|'handle')} type - The type of request that was made (either to handle data, or to get modules)\r\n     * @param {Registry~Request[]} requests - The requests that are being finished (only contains 1 if type=='handle')\r\n     * @param {Array<Array<Class<Module>>>} requestsModules - The modules that are found to match each request\r\n     * @returns {(Promise<Array<Array<Class<Module>>>>|Promise<ChannelSender[]>|Promise<ChannelSender>)} The data that the request results in\r\n     * @async\r\n     * @private\r\n     */\r\n    static async __finishRequest(type, requests, requestsModules) {\r\n        // Resolve request by simply returning the module if it was a module request,\r\n        //      or instanciate a module and return a channel on a handle request\r\n        if (type == \"module\") {\r\n            return requestsModules;\r\n        } else if (type == \"handle\") {\r\n            // The handle type only permits 1 request to exist\r\n            let requestModules = requestsModules[0];\r\n            const request = requests[0];\r\n\r\n            // In order to batch the await, instead of waiting between each open instance request\r\n            const instantiatePromises = [];\r\n\r\n            if (!(requestModules instanceof Array))\r\n                requestModules = [requestModules];\r\n\r\n            // Go through modules for 1 request\r\n            requestModules.forEach(module => {\r\n                try {\r\n                    // Create the proper request path\r\n                    let source;\r\n                    if (request.source) {\r\n                        source = new RequestPath(request.source).augmentPath(\r\n                            module\r\n                        );\r\n                    } else {\r\n                        source = new RequestPath(module);\r\n                    }\r\n\r\n                    // Attempt to retrieve the correct startup settings\r\n                    let moduleData = SettingsHandler._getModuleFile(source);\r\n                    if (!moduleData)\r\n                        moduleData = SettingsHandler._getModuleFile(\r\n                            new RequestPath(module)\r\n                        );\r\n                    if (!moduleData) moduleData = defaultModuleData;\r\n\r\n                    // Open the window that the module should appear in\r\n                    instantiatePromises.push(\r\n                        WindowHandler.openModuleInstance(\r\n                            moduleData,\r\n                            request,\r\n                            module.toString()\r\n                        )\r\n                    );\r\n                } catch (e) {\r\n                    console.error(\r\n                        `Something went wrong while trying to instantiate ${module}: `,\r\n                        e\r\n                    );\r\n                }\r\n            });\r\n\r\n            // Return all the created channels once ready\r\n            const channels = await Promise.all(instantiatePromises);\r\n\r\n            if (request.use == \"one\") {\r\n                return channels[0];\r\n            } else {\r\n                return channels.filter(channel => channel); // Remove failed instanciations\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles one or more requests and serves the responses\r\n     * @param {Registry~Request[]} requests - The requests to make\r\n     * @param {('module'|'handle')} type - The type of request that was made (either to handle data, or to get modules)\r\n     * @param {boolean} synced - Whether or not to request data synchronously (can only be synced if type=='module')\r\n     * @returns {(Promise<Array<Array<Class<Module>>>>|Promise<ChannelSender[]>|Promise<ChannelSender>)} The data that the request results in\r\n     * @private\r\n     */\r\n    static __request(requests, type, synced) {\r\n        if (synced) {\r\n            if (isMain) {\r\n                // Directly resolve the request as we have access to all modules\r\n                return requests.map(request => {\r\n                    return this.__getModules(request);\r\n                });\r\n            } else {\r\n                // Send a command to the main window to look for modules to resolve the request\r\n                return IPC.sendSync(\"Registry.request\", requests)[0];\r\n            }\r\n        } else {\r\n            // Retrieve the modules to resolve the request\r\n            if (isMain) {\r\n                // Directly resolve the request as we have access to all modules\r\n                const requestsModules = requests.map(request => {\r\n                    return this.__getModules(request);\r\n                });\r\n                return this.__finishRequest(type, requests, requestsModules);\r\n            } else {\r\n                // Send a command to the main window to look for modules to resolve the request\r\n                return IPC.send(\"Registry.request\", requests, 0).then(\r\n                    responses => {\r\n                        const requestsModules = responses[0];\r\n\r\n                        return this.__finishRequest(\r\n                            type,\r\n                            requests,\r\n                            requestsModules\r\n                        );\r\n                    }\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    // TODO: test if this method works at all\r\n    /**\r\n     * Gets channels to all instances of a specific module class\r\n     * @param {(Class<Module>|Module)} module - The module to get the instance of\r\n     * @param {string} [subChannel] - The sub channel to target\r\n     * @param {(Module|string)} source - The channelID to return messages to if needed\r\n     * @param {number} [windowID] - Only looks in this window for instances if provided\r\n     * @returns {ChannelSender[]} The channels that were set up for the found modules\r\n     * @async\r\n     * @public\r\n     */\r\n    static async getModuleInstanceChannels(\r\n        module,\r\n        subChannel,\r\n        source,\r\n        windowID\r\n    ) {\r\n        if (module.getPath) module = module.getPath();\r\n        const responses = (await IPC.send(\r\n            \"Registry.getModuleInstances\",\r\n            module,\r\n            0\r\n        ))[0];\r\n        const instancePaths = responses;\r\n        if (source.getPath) source = source.getPath();\r\n\r\n        if (windowID != undefined)\r\n            instancePaths = instancePaths.filter(path => {\r\n                return path.windowID == windowID;\r\n            });\r\n\r\n        instancePaths = instancePaths.map(path => {\r\n            return ChannelHandler.createSender(path.path, subChannel, source);\r\n        });\r\n\r\n        return Promise.all(instancePaths);\r\n    }\r\n\r\n    /**\r\n     * The initial setup method to be called by this file itself, initialises the static fields of the class\r\n     * @return {undefined}\r\n     * @private\r\n     */\r\n    static __setup() {\r\n        // Stores the listeners for handle and module requests, indexed by type\r\n        this.listeners = {};\r\n\r\n        // Stores the registered modules themselves, indexed by path\r\n        this.moduleClasses = {};\r\n\r\n        // Stores instances of modules registered in this window/process\r\n        this.moduleInstances = [];\r\n\r\n        // Set up the IPC listeners in the renderers and main process to allow renderers to request modules\r\n        if (isMain) {\r\n            // Filter out possible modules in this window to handle the handle request\r\n            IPC.on(\"Registry.request\", event => {\r\n                const requests = event.data;\r\n\r\n                // Retrieve the priority mapping for every request\r\n                const requestsModules = requests.map(request => {\r\n                    return this.__getModules(request);\r\n                });\r\n\r\n                // Return the mapping of modules and their priorities\r\n                return requestsModules;\r\n            });\r\n\r\n            // Stores unique module instance request paths, indexed by [request path][UID]\r\n            this.requestPaths = {};\r\n\r\n            // Stores unique module instance request path lists, indexed by module path\r\n            this.moduleInstancePaths = {};\r\n\r\n            // Listen for module instances being registered\r\n            IPC.on(\"Registry.registerModuleInstance\", event => {\r\n                const requestPath = new RequestPath(event.data.requestPath);\r\n\r\n                const type = requestPath.getModuleID().module;\r\n                let pathList = this.moduleInstancePaths[type];\r\n                if (!pathList) pathList = this.moduleInstancePaths[type] = [];\r\n                pathList.push({\r\n                    window: event.sourceID,\r\n                    path: requestPath.toString(true),\r\n                });\r\n\r\n                let paths = this.requestPaths[requestPath.toString()];\r\n                if (!paths)\r\n                    paths = this.requestPaths[requestPath.toString()] = {};\r\n\r\n                let ID = 0;\r\n                while (paths[ID]) ID++;\r\n\r\n                requestPath.getModuleID().ID = ID;\r\n                paths[ID] = requestPath;\r\n                return ID;\r\n            });\r\n\r\n            // Listen for module instances being deregistered\r\n            IPC.on(\"Registry.deregisterModuleInstance\", event => {\r\n                const requestPath = new RequestPath(event.data.requestPath);\r\n\r\n                const type = requestPath.getModuleID().module;\r\n                const pathList = this.moduleInstancePaths[type];\r\n                if (pathList) {\r\n                    const requestPathString = requestPath.toString(true);\r\n                    this.moduleInstancePaths[type] = pathList.filter(path => {\r\n                        return path.path != requestPathString;\r\n                    });\r\n                }\r\n\r\n                const paths = this.requestPaths[requestPath.toString()];\r\n                const ID = requestPath.getModuleID().ID;\r\n                if (paths) delete paths[ID];\r\n            });\r\n\r\n            // Listen for windows/processes requesting instances of a certain module\r\n            IPC.on(\"Registry.getModuleInstances\", event => {\r\n                const data = event.data;\r\n                const modulePath = event.modulePath;\r\n                return this.moduleInstancePaths[modulePath];\r\n            });\r\n        }\r\n    }\r\n}\r\nRegistry.__setup();\r\nexport default Registry;\r\n"]}