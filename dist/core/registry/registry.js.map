{"version":3,"sources":["../../../src/core/registry/registry.js"],"names":["defaultModuleData","location","window","section","Registry","requestHandle","request","use","match","source","Module","getPath","toString","__request","requestModule","requests","arguments","map","type","requestsModules","length","response","i","requestType","_loadModule","path","modules","data","require","__getModulesPath","clas","default","config","modulePath","module","listeners","__getListeners","push","_loadAllModules","_registerModuleInstance","moduleInstance","resolve","reject","requestPath","IPC","send","then","responses","ID","getModuleID","_deregisterModuleInstance","Path","join","__getModules","listenerType","priorities","listener","priority","filter","sort","a","b","__resolveRequest","requestModules","instantiatePromises","Array","forEach","RequestPath","augmentPath","moduleData","SettingsHandler","_getModuleFile","WindowHandler","openModuleInstance","e","console","error","all","channels","channel","synced","isMain","sendSync","__setup","on","event","moduleInstancePaths","paths","IDS","indexOf"],"mappings":"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","file":"registry.js","sourcesContent":["import Path from \"path\";\r\nimport isMain from \"../isMain\";\r\nimport Module from \"./module\";\r\nimport RequestPath from \"./requestPath\";\r\nimport SettingsHandler from \"../communication/data/settingsHandler\";\r\nimport WindowHandler from \"../window/windowHandler\";\r\nimport IPC from \"../communication/IPC\";\r\n\r\nconst defaultModuleData = {\r\n    location: {\r\n        window: 1,\r\n        section: 0\r\n    }\r\n};\r\n\r\n/**\r\n * A class to track all the modules, and handle module requests\r\n */\r\nclass Registry{\r\n    /**\r\n     * Request modules to handle the passed data and establish a connection with these modules\r\n     * @param  {{type:String, execute:String|function, data:Object, source:Module}} request The information on how to handle the data\r\n     * @return {Promise} The Promise that shall return the channels created to communicate with the modules\r\n     */\r\n    static requestHandle(request){\r\n        if(!request.use || (typeof(request.use)==\"string\" || !request.use.match(/^(one|all)$/g)))\r\n            request.use = \"one\";\r\n        if(request.source instanceof Module)\r\n            request.source = request.source.getPath().toString(true);\r\n        return this.__request([request], \"handle\");\r\n    }\r\n    static requestModule(request){\r\n        var requests = Array.from(arguments);\r\n\r\n        // Normalize the request format\r\n        var requests = requests.map(request=>{\r\n            if(typeof(request)==\"string\")\r\n                request = {type: request};\r\n            if(!request.use || (typeof(request.use)==\"string\" || !request.use.match(/^(one|all)$/g)))\r\n                request.use = \"one\";\r\n            return request;\r\n        });\r\n\r\n        // Retrieve the request modules\r\n        const requestsModules = this.__request(requests, \"module\", true);\r\n\r\n        // Format the response appropriately\r\n        if(requestsModules.length>1){\r\n            const response = {};\r\n\r\n            // Map the modules to their request types\r\n            for(let i=0; i<requestsModules.length; i++){\r\n                const requestType = requests[i].type;\r\n                response[requestType] = requestsModules[i];\r\n            }\r\n\r\n            return response;\r\n        }else{\r\n            // Directly return the modules from the only request\r\n            return requestsModules[0];\r\n        }\r\n    }\r\n    // /**\r\n    //  * Registers a module in the registry such that it can be requested by other modules\r\n    //  * @param  {Class} Class The class of the module you want to register\r\n    //  * @param  {{type:String, filter:function(request)}} classListener An event you would like this module to act on\r\n    //  * @return {Undefined} The method returns no useful information\r\n    //  */\r\n    // static __register(Class, ...classListeners){\r\n    //     // Set the path of the module\r\n    //     Class.modulePath = globalModulePath;\r\n    //\r\n    //     // Register the module itself\r\n    //     this.modules[Class.modulePath] = {\r\n    //         class: Class,\r\n    //         listeners: classListeners\r\n    //     };\r\n    //\r\n    //     // Register all the listeners\r\n    //     classListeners.forEach(listener=>{\r\n    //         // Keep a connection with the module itself\r\n    //         listener.module = Class;\r\n    //\r\n    //         // Add to the list of listeners for this request type\r\n    //         const listeners = this.__getListeners(listener.type);\r\n    //         listeners.listeners.push(listener);\r\n    //     });\r\n    // }\r\n\r\n    // Protected methods\r\n    static _loadModule(path){\r\n        if(!this.modules[path]){\r\n            // Require module\r\n            const data = require(this.__getModulesPath(path));\r\n\r\n            // Verify all necessary data is passed\r\n            if(data){\r\n                const clas = data.default;\r\n                const config = data.config;\r\n                if(config){\r\n                    // Augment data with some variables that can be extracted\r\n                    clas.modulePath = path;\r\n                    config.module = clas;\r\n\r\n                    // Register the module itself\r\n                    this.modules[path] = data;\r\n\r\n                    // Add listener to the list of listeners for this request type\r\n                    const listeners = this.__getListeners(config.type);\r\n                    listeners.listeners.push(config);\r\n                }else{\r\n                    return data;\r\n                }\r\n            }\r\n        }\r\n        return this.modules[path];\r\n    }\r\n    static _loadAllModules(){\r\n        //TODO make a module loader\r\n    }\r\n\r\n    static _registerModuleInstance(moduleInstance){\r\n        return new Promise((resolve, reject)=>{\r\n            const requestPath = moduleInstance.getPath();\r\n            IPC.send(\"Registry.registerModuleInstance\", {\r\n                requestPath: requestPath.toString(true)\r\n            }, 0).then(responses=>{\r\n                const ID = responses[0];\r\n                requestPath.getModuleID().ID = ID;\r\n                resolve(ID);\r\n            });\r\n        });\r\n    }\r\n    static _deregisterModuleInstance(moduleInstance){\r\n        return new Promise((resolve, reject)=>{\r\n            const requestPath = moduleInstance.getPath();\r\n            IPC.send(\"Registry.deregisterModuleInstance\", {\r\n                requestPath: requestPath.toString(true)\r\n            }, 0).then(responses=>{\r\n                resolve();\r\n            });\r\n        });\r\n    }\r\n\r\n    // Private methods\r\n    /**\r\n     * Creates the listener variable for a certain type if necessary, and returns it\r\n     * @param  {String} type The request type to return the listener of\r\n     * @return {{type:String, listeners:[{module:Module, filter:function(request)}, ...]}} An object that tracks the listeners for a certain request type\r\n     */\r\n    static __getListeners(type){\r\n        // Create listeners type variable if not available\r\n        if(!this.listeners[type])\r\n            this.listeners[type] = {\r\n                type: type,\r\n                listeners: []\r\n            };\r\n\r\n        // Return listener type\r\n        return this.listeners[type];\r\n    }\r\n    /**\r\n     * Returns the relative path from this class to the modules directory\r\n     * @param  {String} [path=\"\"] The path to append to the modules directory\r\n     * @return {String}           The relative path to the directory\r\n     */\r\n    static __getModulesPath(path=\"\"){\r\n        return Path.join(\"..\", \"..\", \"modules\", path);\r\n    }\r\n\r\n    static __getModules(request){\r\n        // Get the module listeners to handle this type of request\r\n        const listenerType = this.__getListeners(request.type);\r\n\r\n        // Map modules with their priority to this particular request\r\n        const priorities = listenerType.listeners.map(listener=>{\r\n            return {\r\n                priority:listener.filter(request),\r\n                module:listener.module\r\n            };\r\n        }).filter(priority=>priority.priority>0);\r\n\r\n        // Sort the results\r\n        priorities.sort((a,b)=>b.priority-a.priority);\r\n\r\n        // Determine what modules to return\r\n        if(request.use==\"all\"){\r\n            return priorities.map(a=>a.module);\r\n        }else if(typeof(request.use)==\"Function\"){\r\n            return priorities.filter(request.use).map(a=>a.module);\r\n        }else{\r\n            return priorities[0] && priorities[0].module;\r\n        }\r\n    }\r\n    static __resolveRequest(type, requests, requestsModules){\r\n        return new Promise((resolve, reject)=>{\r\n            // Resolve request by simply returning the module if it was a module request,\r\n            //      or instanciate a module and return a channel on a handle request\r\n            if(type==\"module\"){\r\n                resolve(requestsModules);\r\n            }else if(type==\"handle\"){ // The handle type only permits 1 request to exist\r\n                let requestModules = requestsModules[0];\r\n                const request = requests[0];\r\n\r\n                const instantiatePromises = [];\r\n\r\n                if(!(requestModules instanceof Array))\r\n                    requestModules = [requestModules];\r\n\r\n                // Go through modules for 1 request\r\n                requestModules.forEach(module=>{\r\n                    try{\r\n                        // Create the proper request path\r\n                        let source;\r\n                        if(request.source){\r\n                            source = new RequestPath(request.source).augmentPath(module);\r\n                        }else{\r\n                            source = new RequestPath(module);\r\n                        }\r\n\r\n                        // Attempt to retrieve the correct startup settings\r\n                        let moduleData = SettingsHandler._getModuleFile(source);\r\n                        if(!moduleData)\r\n                            moduleData = SettingsHandler._getModuleFile(new RequestPath(module));\r\n                        if(!moduleData)\r\n                            moduleData = defaultModuleData;\r\n\r\n                        // Open the window that the module should appear in\r\n                        instantiatePromises.push(\r\n                            WindowHandler.openModuleInstance(\r\n                                moduleData,\r\n                                request,\r\n                                module.toString()\r\n                            )\r\n                        );\r\n                    }catch(e){\r\n                        console.error(`Something went wrong while trying to instantiate ${module}: `, e);\r\n                    }\r\n                });\r\n\r\n\r\n                // Return all the created channels once ready\r\n                Promise.all(instantiatePromises).then(channels=>{\r\n                    if(request.use==\"one\"){\r\n                        resolve(channels[0]);\r\n                    }else{\r\n                        resolve(\r\n                            channels.filter(channel=>channel) // Remove failed instanciations\r\n                        );\r\n                    }\r\n                });\r\n            }\r\n        })\r\n    }\r\n    static __request(requests, type, synced){\r\n        if(synced){\r\n            if(isMain){\r\n                // Directly resolve the request as we have access to all modules\r\n                return requests.map(request=>{\r\n                    return this.__getModules(request);\r\n                });\r\n            }else{\r\n                // Send a command to the main window to look for modules to resolve the request\r\n                return IPC.sendSync(\"Registry.request\", requests)[0];\r\n            }\r\n        }else{\r\n            // Retrieve the modules to resolve the request\r\n            return new Promise((resolve, reject)=>{\r\n                if(isMain){\r\n                    // Directly resolve the request as we have access to all modules\r\n                    const requestsModules = requests.map(request=>{\r\n                        return this.__getModules(request);\r\n                    });\r\n                    this.__resolveRequest(type, requests, requestsModules).then(resolve);\r\n                }else{\r\n                    // Send a command to the main window to look for modules to resolve the request\r\n                    IPC.send(\"Registry.request\", requests, 0).then(responses=>{\r\n                        const requestsModules = responses[0];\r\n\r\n                        this.__resolveRequest(type, requests, requestsModules).then(resolve);\r\n                    });\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The initial setup method to be called by this file itself, initialises the static fields of the class\r\n     * @return {Undefined} The method returns no useful information\r\n     */\r\n    static __setup(){\r\n        // Stores the listeners for handle and module requests, indexed by type\r\n        this.listeners = {};\r\n\r\n        // Stores the registered modules themselves, indexed by path\r\n        this.modules = {};\r\n\r\n        // Set up the IPC listeners in the renderers and main process to allow renderers to request modules\r\n        if(isMain){\r\n            // Filter out possible modules in this window to handle the handle request\r\n            IPC.on(\"Registry.request\", event=>{\r\n                const requests = event.data;\r\n\r\n                // Retrieve the priority mapping for every request\r\n                const requestsModules = requests.map(request=>{\r\n                    return this.__getModules(request);\r\n                });\r\n\r\n                // Return the mapping of modules and their priorities\r\n                return requestsModules;\r\n            });\r\n\r\n\r\n            // Stores lists of unique module instance request paths, indexed by request paths\r\n            this.moduleInstancePaths = {};\r\n\r\n            // Listen for module instances being registered\r\n            IPC.on(\"Registry.registerModuleInstance\", event=>{\r\n                const requestPath = new RequestPath(event.data.requestPath);\r\n                let paths = this.moduleInstancePaths[requestPath.toString()];\r\n                if(!paths)\r\n                    paths = this.moduleInstancePaths[requestPath.toString()] = {};\r\n\r\n                let IDS = Object.values(paths).map(path=>path.getModuleID().ID);\r\n                let ID = 0;\r\n                while(IDS.indexOf(ID)!=-1) ID++;\r\n\r\n                requestPath.getModuleID().ID = ID;\r\n                this.moduleInstancePaths[requestPath.toString()][ID] = requestPath;\r\n                return ID;\r\n            });\r\n\r\n            // Listen for module instances being deregistered\r\n            IPC.on(\"Registry.deregisterModuleInstance\", event=>{\r\n                const requestPath = new RequestPath(event.data.requestPath);\r\n                let paths = this.moduleInstancePaths[requestPath.toString()];\r\n                if(paths)\r\n                    delete paths[requestPath.toString(true)];\r\n            });\r\n        }\r\n    }\r\n};\r\nRegistry.__setup();\r\nexport default Registry;\r\n"]}