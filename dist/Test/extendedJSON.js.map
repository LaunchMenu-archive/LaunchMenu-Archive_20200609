{"version":3,"sources":["../../src/Test/extendedJSON.js"],"names":["pathSymbol","cleanSymbol","serializeSymbol","deserializeSymbol","ExtendedJSON","encode","object","encodeValue","path","Object","type","value","subType","__proto__","prototype","Array","key","ret","Module","console","error","module","getClass","modulePath","data","undefined","e","cleanupObject","encodedObject","decode","writeDecodedValue","parent","obj","split","shift","fieldKey","m","match","Registry","require","default","loadModule","instance","bind","apply","concat","constArgs","val","root","parse","string","JSON","stringify"],"mappings":"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","file":"extendedJSON.js","sourcesContent":["import Module from \"../core/registry/module\";\r\nvar pathSymbol = Symbol(\"path\");\r\nvar cleanSymbol = Symbol(\"clean\");\r\nvar serializeSymbol = Symbol(\"serialize\");\r\nvar deserializeSymbol = Symbol(\"deserialize\");\r\n\r\nexport {serializeSymbol, deserializeSymbol};\r\nexport default class ExtendedJSON{\r\n    /**\r\n     * Encode more complicated data into a serializable object\r\n     * @param  {Object} object The data you want to map\r\n     * @return {Object}        The object that represents your data as as serializable string\r\n     */\r\n    static encode(object){\r\n        /*\r\n            TODO:\r\n            -map recursive structures to none recursive structures\r\n            -map primitive values to strings\r\n            -map modules to their paths\r\n         */\r\n        /**\r\n         * Goes through an object and returns the object in the encoded format\r\n         * @param  {Object} object The object to convert\r\n         * @param  {String} path   The path within the parent object to reach this object so far\r\n         * @return {Object}        The encoded version of the input object\r\n         */\r\n        var encodeValue = function(object, path){\r\n            try{\r\n                if(object instanceof Object){ // Encode an object of data into the extended format\r\n                    // If object is null, return null object in the extended format\r\n                    if(!object)\r\n                        return {\r\n                            type: \"object\",\r\n                            value: null\r\n                        };\r\n\r\n                    // If object has already been encoded, return a path instead (handles recursive structures)\r\n                    if(object[pathSymbol]!=null)\r\n                        return {\r\n                            type: \"object\",\r\n                            subType: \"path\",\r\n                            value: object[pathSymbol]\r\n                        };\r\n\r\n                    // If object is an array or plain js object, recurse on this object\r\n                    if(object.__proto__==Object.prototype || object.__proto__==Array.prototype){\r\n                        // Indicate that this object is currently being handled, and prevent recusion\r\n                        object[pathSymbol] = path;\r\n\r\n                        // Go through all children and append their values to this value\r\n                        var value = {};\r\n                        for(var key in object)\r\n                            value[key] = encodeValue(object[key], path+\".\"+key);\r\n\r\n                        // Return either a plain js object type, or an array type\r\n                        var ret = {\r\n                            type: \"object\",\r\n                            value: value\r\n                        };\r\n                        if(object instanceof Array) ret.subType = \"array\";\r\n                        return ret;\r\n                    }\r\n\r\n                    // If object is a module and serializable, serialize it\r\n                    if(object instanceof Module)\r\n                        console.error(\"DETECT THIS\", object);\r\n                    if(object instanceof Module && object[serializeSymbol] && object[deserializeSymbol]){\r\n                        var module = object.getClass().modulePath;\r\n                        var data = object[serializeSymbol]();\r\n                        return {\r\n                            type: \"object\",\r\n                            subType: \"moduleInstance:\"+module,\r\n                            value: data\r\n                        };\r\n                    }\r\n\r\n                    // If object is a module class, return the path of the class\r\n                    if(typeof(object)==\"function\" && object.modulePath)\r\n                        return {\r\n                            type: \"object\",\r\n                            subType: \"module:\"+object.modulePath,\r\n                            value: undefined\r\n                        };\r\n\r\n                    // If none of the previous conditions apply, there is nothing left but ignore this value\r\n                    return {\r\n                        type: \"undefined\",\r\n                        value: undefined\r\n                    };\r\n                }else{ // Encode a primitive value in the extended format\r\n                    var type = typeof(object);\r\n                    return {\r\n                        type:type,\r\n                        value:object\r\n                    };\r\n                }\r\n            }catch(e){\r\n                console.error(e);\r\n                return undefined;\r\n            }\r\n        }\r\n        /**\r\n         * Goes through an object and returns all the pathSymbols from it\r\n         * @param  {Object} object The object to clean up\r\n         * @return {Undefined} The method returns no useful information\r\n         */\r\n        var cleanupObject = function(object){\r\n            // Only clean the object if it really is an object, if it isn't already cleaned and if there is still something to clean\r\n            if(object instanceof Object && !object[cleanSymbol] && object[pathSymbol]!=null){\r\n                // Prevent recursion while cleaning the object\r\n                object[cleanSymbol] = true;\r\n\r\n                // Remove the path if it is present\r\n                if(object[pathSymbol]!=null)\r\n                    delete object[pathSymbol];\r\n\r\n                // If no path is present, recurse on its children\r\n                for(var key in object)\r\n                    cleanupObject(object[key]);\r\n\r\n                // Remove the cleanSymbol which prevent recursion\r\n                delete object[cleanSymbol];\r\n            }\r\n        };\r\n\r\n        // Encode data\r\n        var encodedObject = encodeValue(object, \"\");\r\n        // Remove data added to the original object during the process\r\n        cleanupObject(object);\r\n\r\n        // Return the encoded data\r\n        return encodedObject;\r\n    }\r\n    /**\r\n     * Decode the more complicated data that was encoded into a serializable object\r\n     * @param  {Object} object The data you want return into its source data\r\n     * @return {Object}        The source data in its format before encoding was applied\r\n     */\r\n    static decode(object){\r\n        /*\r\n            TODO:\r\n            -map none recursive structure representations to their recursive structures\r\n            -map primitive value strings representations to their value\r\n            -map module paths to their module\r\n         */\r\n        /*\r\n            TODO implement module decoding, properly comment everything\r\n         */\r\n        var writeDecodedValue = function(parent, key, value, obj){\r\n            try{\r\n                if(value.type==\"object\"){\r\n                    if(value.subType){\r\n                        if(value.subType==\"path\"){\r\n                            var path = value.value.split(\".\");\r\n                            path.shift();\r\n\r\n                            var fieldKey;\r\n                            while((fieldKey = path.shift()) && obj)\r\n                                obj = obj[fieldKey];\r\n\r\n                            parent[key] = obj;\r\n                            return;\r\n                        }\r\n\r\n                        var m;\r\n                        if(m = value.subType.match(/module\\:(.*)/)){\r\n                            var Registry = require(\"../core/registry/registry\").default;\r\n                            var module = Registry.loadModule(m[1]);\r\n                            parent[key] = module;\r\n                            return;\r\n                        }\r\n                        if(m = value.subType.match(/moduleInstance\\:(.*)/)){\r\n                            var Registry = require(\"../core/registry/registry\").default;\r\n                            var data = value.value;\r\n                            var module = Registry.loadModule(m[1]);\r\n                            var instance = new (module.bind.apply(module, [module].concat(data.constArgs||[\"crap\"])))();\r\n                            instance[deserializeSymbol](data);\r\n                            parent[key] = instance;\r\n                            return;\r\n                        }\r\n                    }\r\n\r\n                    if(value.value==null){\r\n                        parent[key] = null;\r\n                        return;\r\n                    }\r\n\r\n                    var val = value.subType==\"array\"?[]:{};\r\n                    parent[key] = val;\r\n                    for(var fieldKey in value.value)\r\n                    writeDecodedValue(val, fieldKey, value.value[fieldKey], obj||val);\r\n                    return;\r\n                }else{\r\n                    parent[key] = value.value;\r\n                    return;\r\n                }\r\n            }catch(e){\r\n                if(parent) parent[key] = undefined;\r\n                console.error(e);\r\n            }\r\n        };\r\n\r\n        var obj = {};\r\n        writeDecodedValue(obj, \"root\", object);\r\n        return obj.root;\r\n    }\r\n\r\n    /**\r\n     * Use ExtendedJSON to turn a string into an object just like JSON would\r\n     * @param  {String} string The string to translate back into an object\r\n     * @return {Object}        The source object that the string was made from\r\n     */\r\n    static parse(string){\r\n        return this.decode(JSON.parse(string));\r\n    }\r\n    /**\r\n     * Use ExtendedJSON to turn an object into a string just like JSON would\r\n     * @param  {Object} object The source object to turn into a string\r\n     * @return {String}        The string that the object was translated into\r\n     */\r\n    static stringify(object){\r\n        return JSON.stringify(this.encode(object));\r\n    }\r\n\r\n    /**\r\n     * Get the serializeSymbol to use as a function name in your own class, allowing said class to be serialized by ExtendedJSON\r\n     * @type {Symbol}\r\n     */\r\n    static get serializeSymbol(){\r\n        return serializeSymbol;\r\n    }\r\n    /**\r\n     * Get the deserializeSymbol to use as a function name in your own class, allowing said class to be deserialized by ExtendedJSON\r\n     * @type {[type]}\r\n     */\r\n    static get deserializeSymbol(){\r\n        return deserializeSymbol;\r\n    }\r\n}\r\n"]}